import { IPdfObjectParams, PdfObject, PdfObjectConstructor } from "./object";
import { PdfObjectType } from "./object_type";
import { PdfName } from "./name";
import { PdfIndirectObject, PdfIndirectObjectType } from "./indirect_object";
import { Registry, RegistryTypes } from "../../internal/registry";
import { Names } from "../names";

export interface IPdfDictionaryParams extends IPdfObjectParams {
  values?: Map<string, PdfIndirectObjectType>;
}

export class PdfDictionary extends PdfObject {
  /**
   * @internal
   */
  public values: Map<string, PdfIndirectObjectType>;

  public constructor(param: IPdfDictionaryParams = {}) {
    super(param);
    this.values = param.values ?? new Map();
  }

  /**
   * Возвращает id если есть PdfIndirectObject родитель.
   * Иначе вернет ошибку.
   */
  public get id(): number {
    if (!this.parent) {
      throw new Error("Объект не имеет родителя");
    }

    if (
      this.parent instanceof PdfDictionary
      || this.parent instanceof PdfIndirectObject
      || this.parent instanceof Registry.get(RegistryTypes.PdfArray)
    ) {
      return this.parent.id;
    }

    throw new Error("Родитель должен быть PdfIndirectObject, PdfDictionary или PdfArray");
  }

  public get items(): ReadonlyMap<string, PdfIndirectObjectType> {
    return this.values;
  }

  protected override onConvert(obj: PdfObject): void {
    if (!(obj instanceof PdfDictionary)) {
      throw new Error(`Ошибка преобразования PdfDictionary в '${obj.constructor.name}'.`);
    }

    obj.values = this.values;
  }

  /**
   * Проверяет наличие элемента с заданным ключом.
   * @param key - Ключ для поиска.
   * @returns `true`, если элемент с заданным ключом существует, иначе `false`.
   */
  public has(key: string | PdfName): boolean {
    const name = key instanceof PdfName ? key.value : key;

    return this.values.has(name);
  }

  public find(key: string | PdfName): PdfObjectType | null;
  public find<T extends PdfObject>(key: string | PdfName, type: PdfObjectConstructor<T>): T | null;
  public find(key: string | PdfName, type?: PdfObjectConstructor): PdfObject | null {
    const name = key instanceof PdfName ? key.value : key;
    let res = this.values.get(name);

    if (res instanceof Registry.get(RegistryTypes.PdfIndirectObject)) {
      res = res.value;
    }

    if (!res) {
      return null;
    }

    if (!type) {
      return res;
    }

    try {
      return res.convert(type);
    } catch {
      return null;
    }
  }

  public get(key: string | PdfName): PdfObjectType;
  public get<T extends PdfObject>(key: string | PdfName, type: PdfObjectConstructor<T>): T;
  public get(key: string | PdfName, type?: PdfObjectConstructor): PdfObject {
    const res = this.find(key);
    if (!res) {
      throw new Error(`PdfDictionary: Элемент не найден '${key}'`);
    }

    if (!type) {
      return res;
    }

    return res.convert(type);
  }

  public set(key: string | PdfName, obj: PdfIndirectObjectType): void {
    this.change();
    const name = key instanceof PdfName ? key.value : key;
    this.values.set(name, obj); // TODO добавить инфу о parent
    if (!(obj instanceof Registry.get(RegistryTypes.PdfIndirectObject)) && !obj.parent) {
      obj.parent = this;
    }
    obj.xref = this.xref;
  }

  public findOrSet<T extends PdfObject>(key: string | PdfName, type: PdfObjectConstructor<T>, ref?: boolean): T;
  public findOrSet(key: string | PdfName, type: PdfObjectConstructor, ref?: boolean): PdfObject {
    let field = this.find(key, type) as PdfObjectType | null;

    // Если field нету то создаем новый.
    if (!field) {
      switch (true) {
        case type === Registry.get(RegistryTypes.PdfArray):
          field = this.doc.createArray();
          break;
        case type === PdfDictionary:
          field = this.doc.createDictionary();
          break;
        default:
          throw new Error("findOrSet(): Неподдерживаемый тип");
      }

      if (ref) {
        this.set(key, field.ref());
      } else {
        this.set(key, field);
      }

    }

    return field;
  }

  /**
   * Удаляет элемент с заданным ключом.
   * @param key - Ключ для поиска.
   * @returns `true`, если элемент с заданным ключом был удален, иначе `false`.
   */
  public remove(key: string | PdfName): boolean {
    this.change();
    const name = key instanceof PdfName ? key.value : key;

    return this.values.delete(name);
  }

  /**
   * Ищет значение с заданным ключом в текущем объекте или в его родительских объектах,
   * поднимаясь по иерархии объектов, пока не будет найдено значение с заданным ключом или пока не достигнется верхний уровень.
   *
   * @param key - Ключ для поиска.
   * @returns Найденное значение или `null`, если значение не найдено.
   */
  public findInherited(key: string | PdfName): PdfObjectType | null;
  /**
   * Ищет значение с заданным ключом и определенного типа в текущем объекте или в его родительских объектах,
   * поднимаясь по иерархии объектов, пока не будет найдено значение с заданным ключом и типом, или пока не достигнется верхний уровень.
   *
   * @param key - Ключ для поиска.
   * @param type - Ожидаемый тип значения.
   * @returns Найденное значение заданного типа или `null`, если значение не найдено.
   */
  public findInherited<T extends PdfObject>(key: string | PdfName, type: PdfObjectConstructor<T>): T | null;
  public findInherited(key: string | PdfName, type?: PdfObjectConstructor): PdfObject | null {
    let res = this.find(key);

    if (!res) {
      // Поиск родительского объекта.
      const parent = this.find(Names.Parent, PdfDictionary);
      if (!parent) {
        return null;
      }

      // Поиск значения по ключу в родительских объектах.
      res = parent.findInherited(key);
      if (!res) {
        return null;
      }
    }

    if (!type) {
      return res;
    }

    return res.convert(type);
  }

  /**
   * Получает значение с заданным ключом в текущем объекте или в его родительских объектах,
   * поднимаясь по иерархии объектов, пока не будет найдено значение с заданным ключом.
   *
   * @param key - Ключ для поиска.
   * @returns Найденное значение.
   * @throws Error, если значение не найдено.
   */
  public getInherited(key: string | PdfName): PdfObjectType;
  /**
   * Получает значение с заданным ключом и определенного типа в текущем объекте или в его родительских объектах,
   * поднимаясь по иерархии объектов, пока не будет найдено значение с заданным ключом и типом.
   *
   * @param key - Ключ для поиска.
   * @param type - Ожидаемый тип значения.
   * @returns Найденное значение заданного типа.
   * @throws Error, если значение не найдено или не соответствует ожидаемому типу.
   */
  public getInherited<T extends PdfObject>(key: string | PdfName, type: PdfObjectConstructor<T>): T;
  public getInherited(key: string | PdfName, type?: PdfObjectConstructor): PdfObject {
    const res = this.findInherited(key);
    if (!res) {
      throw new Error(`PdfDictionary: Элемент через родителей не найден '${key}'`);
    }

    if (!type) {
      return res;
    }

    return res.convert(type);
  }

}
