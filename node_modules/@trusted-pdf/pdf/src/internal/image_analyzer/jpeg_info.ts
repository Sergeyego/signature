import { ColorNames, ColorSpace, IBaseImage, IBaseInfo, ImageTypes } from "./analyzer";

const MARKERS = [
  0xffc0, 0xffc1, 0xffc2, 0xffc3,
  0xffc5, 0xffc6, 0xffc7, 0xffc8, 0xffc9,
  0xffca, 0xffcb, 0xffcc, 0xffcd, 0xffce, 0xffcf,
];

/**
 * Данные JPEG изображения.
 */
export interface IImageJpegInfo extends IBaseImage {
  /**
   * Тип изображения: JPEG.
   */
  type: ImageTypes.JPEG;
  /**
   * Дополнительная информация о JPEG.
   */
  info: IJpegInfo;
}

/**
 * Дополнительная информация о JPEG.
 */
export interface IJpegInfo extends IBaseInfo { }

export abstract class JpegInfo {

  public static getInfo(jpeg: Uint8Array): IImageJpegInfo {
    const view = new DataView(jpeg.buffer, jpeg.byteOffset, jpeg.byteLength);
    let offset = 0;

    // Проверяем jpeg тег.
    const tag = view.getUint16(offset);
    if (tag !== 0xffd8) {
      throw new Error("Тэг JPEG не найден в JPEG.");
    }
    offset += 2;

    let find = false;
    while (offset < view.byteLength) {
      const marker = view.getUint16(offset);
      offset += 2;

      if (MARKERS.includes(marker)) {
        find = true;
        break;
      }

      offset += view.getUint16(offset);
    }

    if (!find) {
      throw new Error("Поврежденный JPEG.");
    }
    offset += 2;

    // Получение bitsPerComponent.
    const bitsPerComponent = view.getUint8(offset++);

    // Получение высоты.
    const height = view.getUint16(offset);
    offset += 2;

    // Получение ширины.
    const width = view.getUint16(offset);
    offset += 2;

    // Получение colorSpace.
    const colorSpace = ColorNames[view.getUint8(offset++)] as ColorSpace;
    if (!colorSpace) {
      throw new Error("Неизвестный ColorSpace.");
    }

    return {
      type: ImageTypes.JPEG,
      buf: jpeg,
      info: {
        bitsPerComponent,
        width,
        height,
        colorSpace,
      }
    };
  }
}
