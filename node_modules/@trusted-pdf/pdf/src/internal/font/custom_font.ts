import * as fontkit from "@pdf-lib/fontkit";
import { PdfFontFlags } from "./font_flags";
import { Names } from "../../syntax/names";

export interface ICustomFontParams {
  /**
   * Массив байтов, содержащий данные шрифта.
   */
  fontData: Uint8Array;
}

/**
 * Класс `CustomFont` представляет пользовательский шрифт в формате PDF.
 * Этот класс позволяет работать с пользовательскими шрифтами, включая доступ к различным характеристикам и свойствам шрифта.
 */
export class CustomFont {
  /**
   * Массив байтов, содержащий данные шрифта.
   */
  public readonly fontData: Uint8Array;
  /**
   * Объект шрифта, созданный с использованием библиотеки fontkit.
   */
  public readonly font: fontkit.Font;

  /**
   * Создает новый экземпляр класса `PdfCustomFont`.
   * @param {ICustomFontParams} params - Параметры шрифта, включая данные шрифта в виде Uint8Array.
   */
  public constructor(params: ICustomFontParams) {
    this.fontData = params.fontData;
    // TODO: Изаменить импорт fontkit для работы на frontend части.
    //Сделан костыль для работы импорта fontkit на frontend и backend части.
    const fontkitInstance = (fontkit as any).default ? (fontkit as any).default : fontkit;
    this.font = fontkitInstance.create(this.fontData);
  }

  /**
   * Получает коэффициент масштабирования для шрифта.
   */
  public get scale(): number {
    return 1000 / this.font.unitsPerEm;
  }

  /**
   * Получает ограничивающий прямоугольник (BBox) шрифта.
   */
  public get fontBBox(): number[] {
    return [
      Math.round(this.font.bbox.minX * this.scale),
      Math.round(this.font.bbox.minY * this.scale),
      Math.round(this.font.bbox.maxX * this.scale),
      Math.round(this.font.bbox.maxY * this.scale),
    ];
  }

  /**
   * Получает значение ascent (восхождение) шрифта.
   */
  public get ascent(): number {
    return Math.round(this.font.ascent * this.scale);
  }

  /**
   * Получает значение descent (спуск) шрифта.
   */
  public get descent(): number {
    return Math.round(this.font.descent * this.scale);
  }

  /**
   * Получает значение capHeight (высота заглавных букв) шрифта.
   */
  public get capHeight(): number {
    return Math.round((this.font.capHeight || this.ascent) * this.scale);
  }

  /**
   * Получает значение xHeight (высота строчных букв) шрифта.
   */
  public get xHeight(): number {
    return Math.round((this.font.xHeight || 0) * this.scale);
  }

  /**
   * Получает угол наклона шрифта (italic angle).
   */
  public get italicAngle(): number {
    return Math.round(this.font.italicAngle);
  }

  /**
   * Получает флаги шрифта.
   */
  public get flags(): PdfFontFlags {
    const flags = new PdfFontFlags();
    const familyClass = this.font["OS/2"] ? this.font["OS/2"].sFamilyClass : 0;

    if (1 <= familyClass && familyClass <= 7) {
      flags.set("Serif");
    }

    if (this.font.post.isFixedPitch) {
      flags.set("FixedPitch");
    }

    flags.set("Symbolic");

    if (familyClass === 10) {
      flags.set("Script");
    }

    if (this.font.head.macStyle.italic) {
      flags.set("Italic");
    }

    return flags;
  }

  /**
   * Получает подтип шрифта.
   */
  public get subtype(): string {
    return this.font.cff ? Names.CIDFontType0 : Names.CIDFontType2;
  }

  /**
   * Получает отображение CID в GID (Character ID в Glyph ID).
   */
  public get cidToGIDMap(): string { return Names.Identity; }

  /**
   * Получает массив ширин глифов шрифта.
   */
  public get widths(): number[] {
    const scale = this.scale;
    const widths: number[] = [];
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const metrics = (this.font as any).hmtx.metrics.toArray();
    for (let index = 0; index < metrics.length; index++) {
      const metric = metrics[index];
      widths.push(metric.advance * scale);
    }

    return widths;
  }

  /**
   * Получает массив глифов шрифта.
   */
  public glyphs(): fontkit.Glyph[] {
    const glyphs: fontkit.Glyph[] = new Array(this.font.characterSet.length);
    for (let idx = 0, len = glyphs.length; idx < len; idx++) {
      const codePoint = this.font.characterSet[idx];
      glyphs[idx] = this.font.glyphForCodePoint(codePoint);
    }

    return this.sortedUniq(glyphs.sort((a: fontkit.Glyph, b: fontkit.Glyph) => a.id - b.id));
  }

  /**
   * Удаляет дубликаты и сортирует массив глифов.
   */
  private sortedUniq(glyphs: fontkit.Glyph[]) {
    const uniq: fontkit.Glyph[] = [];

    for (let idx = 0, len = glyphs.length; idx < len; idx++) {
      const curr = glyphs[idx];
      const prev = glyphs[idx - 1];
      if (idx === 0 || curr.id !== prev.id) {
        uniq.push(curr);
      }
    }

    return uniq;
  }

  /**
   * Получает идентификатор глифа.
   * @param {fontkit.Glyph} glyph - Глиф шрифта.
   * @returns {number} Идентификатор глифа.
   */
  private glyphId(glyph?: fontkit.Glyph): number {
    return glyph ? glyph.id : -1;
  }

  /**
   * Возвращает массив поддерживаемых языков.
   */
  public supportedLanguages(): string[] {
    const glyphs = this.font.characterSet;
    const scriptRanges: Record<string, [number, number]> = {
      "latin": [0x0000, 0x007F],
      "cyrillic": [0x0400, 0x04FF],
      "greek": [0x0370, 0x03FF],
      "hebrew": [0x0590, 0x05FF],
      "arabic": [0x0600, 0x06FF],
    };

    const supportedScripts: string[] = [];

    for (const script in scriptRanges) {
      const [start, end] = scriptRanges[script];
      for (let idx = start; idx <= end; idx++) {
        if (glyphs.includes(idx)) {
          supportedScripts.push(script);
          break;
        }
      }
    }

    return supportedScripts;
  }
}
