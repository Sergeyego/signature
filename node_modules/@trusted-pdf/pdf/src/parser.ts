import * as syntax from "./syntax";
import { type Document } from "./document";
import { PdfBuffer, StringConverter } from "./internal";
import { XRef } from "./syntax";

type IResultIs = {
  offset1: number;
  offset2: number;
  ok: boolean;
};

export type IResultRead<T extends syntax.RawData> = IResultReadTrue<T> | IResultReadFalse;
interface IResultReadTrue<T extends syntax.RawData> {
  offset1: number;
  offset2: number;
  ok: true;
  value: T;
}
interface IResultReadFalse {
  ok: false;
}

interface IResultIsPairsNumbers {
  ok: boolean;
  offset1: number;
  offset2: number;
  pair: IPairsNumbers;
}

export interface IPairsNumbers {
  num1: number;
  num2: number;
}

export class Parser {
  #doc: Document;

  public constructor(doc: Document) {
    this.#doc = doc;
  }

  public readXRef(): syntax.XRef {
    // Получаем offset последнего XRef.
    let offset = this.getLastEOF();
    if (offset === 0) {
      throw new Error("EOF не найден");
    }

    offset = Parser.skipWhiteSpaces(this.#doc.buffer, offset);

    // Определяем тип XRef.
    const xrefHeader = Parser.isWord(this.#doc.buffer, offset, syntax.CharWords.xref);

    // тип XRefTable.
    if (xrefHeader.ok) {
      return this.readXRefTable(offset);
    }

    // тип XRefStream.
    return this.readXRefStream(offset);
  }

  public readObject(index: number): syntax.PdfIndirectObjectType;
  public readObject<T extends syntax.PdfObject>(index: number, type: syntax.PdfObjectConstructor<T>, xref?: XRef): T;
  public readObject(index: number, type?: syntax.PdfObjectConstructor, xref?: XRef): syntax.PdfObject {
    const currentXref = xref ? xref : this.#doc.xref;

    const res = Parser.read(this.#doc.buffer, currentXref, index);
    if (!res.ok) {
      throw new Error(`Невозможно прочитать объект по индексу ${index}`);
    }

    if (type && !(res.value instanceof type)) {
      throw new Error("Тип объекта не соответствует нужному");
    }

    return res.value;
  }

  public static readComment(buffer: PdfBuffer, offset: number): IResultRead<syntax.PdfComment> {
    // Читаем начало комментария. Который начинается с '%'.
    const comment = Parser.isWord(buffer, offset, syntax.CharCodes.percent);
    if (!comment.ok) {
      return { ok: false };
    }

    // Читаем комментарий.
    const comment2 = Parser.findWord(buffer, comment.offset2, syntax.CharCodes.endLine);
    if (!comment2.ok) {
      return { ok: false };
    }

    // Пробуем читать строку как UTF8. Если не получается, то читаем как ASCII.
    const textRaw = buffer.subarray(comment.offset2 + 1, comment2.offset1).getRaw();
    let text = "";
    try {
      const decoder = new TextDecoder("utf-8");
      text = decoder.decode(textRaw);
    } catch {
      // Если декодирование UTF-8 не удалось, преобразовать в binary строку
      text = Array.from(textRaw).map(byte => String.fromCharCode(byte)).join("");
    }

    const commentObject = new syntax.PdfComment();
    commentObject.value = text;
    commentObject.raw = buffer.subarray(comment.offset1, comment2.offset2);

    return {
      ok: true,
      offset1: comment.offset1,
      offset2: comment2.offset2,
      value: commentObject,
    };
  }

  public readHeader(): syntax.Header {
    const pdf = Parser.findWord(this.#doc.buffer, 0, syntax.CharWords.pdf);
    if (!pdf.ok) {
      throw new Error("'%PDF-' не найден");
    }

    // Читаем версию.
    const version = Parser.readNumber(this.#doc.buffer, pdf.offset2 + 1);
    if (!version.ok) {
      throw new Error("Не удалось прочитать версию");
    }

    // Пропускаем пробелы.
    const spaces = Parser.skipWhiteSpaces(this.#doc.buffer, version.offset2 + 1);

    // Читаем комментарий с байтами, если есть.
    const comment = Parser.readComment(this.#doc.buffer, spaces);

    const header = new syntax.Header();
    header.version = version.value.value;
    header.raw = this.#doc.buffer.subarray(0, comment.ok ? comment.offset2 : version.offset2);
    header.comment = comment.ok ? comment.value : undefined;

    return header;
  }

  //#region private read
  /**
   * Читает любой тип данных из общего raw по индексу.
   * @param index Индекс начала чтении объекта.
   * @returns
   */
  public static read(buffer: PdfBuffer, xref: syntax.XRef, index: number): IResultRead<syntax.PdfIndirectObjectType> {
    // Проверяем Ref.
    // Должен выполнятся до проверки PdfNumber так как он состоит из двух чисел и буквы.
    const ref = Parser.isRef(buffer, index);
    if (ref.ok) {

      const ind = xref.findIndirectObject(ref.pair.num1);
      if (ind) {
        return {
          ok: true,
          offset1: ref.offset1,
          offset2: ref.offset2,
          value: ind
        };
      }

      return {
        ok: true,
        offset1: ref.offset1,
        offset2: ref.offset2,
        value: new syntax.PdfIndirectObject({
          id: ref.pair.num1,
          xref,
        })
      };
    }

    // Проверяем PdfDictionary.
    // Должен выполнятся до проверки PdfString так как он начинается с <<.
    const dictionary = Parser.readDictionary(buffer, xref, index);
    if (dictionary.ok) {
      return dictionary;
    }

    // Проверяем PdfBoolean.
    const bool = Parser.readBoolean(buffer, index);
    if (bool.ok) {
      return bool;
    }

    // Проверяем PdfString.
    const str = Parser.readString(buffer, index);
    if (str.ok) {
      return str;
    }

    // Проверяем PdfArray.
    const arr = Parser.readArray(buffer, xref, index);
    if (arr.ok) {
      return arr;
    }

    // Проверяем PdfNumber
    const num = Parser.readNumber(buffer, index);
    if (num.ok) {
      return num;
    }

    // Проверяем Null
    const nul = Parser.readNull(buffer, index);
    if (nul.ok) {
      return nul;
    }

    return { ok: false };
  }

  public static readHeaderObjectStream(buffer: PdfBuffer): Array<IPairsNumbers> {
    const res: Array<IPairsNumbers> = [];

    let offset = 0;
    while (true) {
      offset = Parser.skipWhiteSpaces(buffer, offset);

      const resPair = Parser.isPairNumbers(buffer, offset);
      if (!resPair.ok) {
        break;
      }
      offset = resPair.offset2;

      res.push(resPair.pair);
    }

    return res;
  }

  public readIndirectObject(offset: number, xref?: XRef): syntax.PdfObjectType {
    const header = Parser.isObject(this.#doc.buffer, offset);
    if (!header.ok) {
      return new syntax.PdfNull();
    }

    return this.readObject(Parser.skipWhiteSpacesAndComments(this.#doc.buffer, header.offset2 + 1), syntax.PdfObject, xref) as syntax.PdfObjectType;
  }

  public static readDictionary(buffer: PdfBuffer, xref: syntax.XRef, index: number): IResultRead<syntax.PdfDictionary | syntax.PdfStream> {
    const start = Parser.isWord(buffer, index, syntax.CharWords.startDictionary);
    if (!start.ok) {
      return { ok: false };
    }

    let dictionary = new syntax.PdfDictionary();
    dictionary.xref = xref;

    let offset2 = start.offset2;
    while (true) {
      offset2++;

      // Проверка на завершение документа.
      Parser.isEndFile(buffer, offset2);

      // Проверяем пробелы и комментарии.
      offset2 = Parser.skipWhiteSpacesAndComments(buffer, offset2);

      // Проверяем закончился dictionary или нет.
      const end = Parser.isWord(buffer, offset2, syntax.CharWords.endDictionary);
      if (end.ok) {
        const next = Parser.skipWhiteSpacesAndComments(buffer, end.offset2 + 1);
        const stream = Parser.isWord(buffer, next, syntax.CharWords.stream);
        if (stream.ok) {
          const length = dictionary.get(syntax.Names.Length, syntax.PdfNumber).value;
          const isValue = Parser.isStream(buffer, next, length);
          if (!isValue.ok) {
            throw new Error("Невозможно прочитать stream");
          }

          // Пропускаем перенос строки в начале стрима.
          let startOffsetStream = isValue.offset1;
          const isEndLine = Parser.isChar(buffer, startOffsetStream, syntax.CharCodes.endLine);
          if (!isEndLine) {
            const isEol = Parser.isWord(buffer, startOffsetStream, syntax.CharWords.eol);
            if (!isEol.ok) {
              throw new Error("Некорректный перенос строки в stream");
            }
            startOffsetStream = isEol.offset2 + 1;
          } else {
            startOffsetStream++;
          }

          const value = buffer.subarray(
            startOffsetStream,
            isValue.offset2,
          );

          const dictionaryStm = dictionary.convert(syntax.PdfStream);
          dictionaryStm.stream = value;
          dictionary = dictionaryStm;

          offset2 = isValue.offset2 + syntax.CharWords.endstream.length;
        } else {
          offset2 += 1;
        }
        break;
      }

      //#region Получение пары ключ-значение.
      // Получаем ключ.
      const name = Parser.readNameString(buffer, offset2);
      if (!name.ok) {
        throw new Error("Dictionary: Плохое имя");
      }
      offset2 = name.offset2 + 1;
      const key = name.value.value;

      // Проверяем пробелы.
      offset2 = Parser.skipWhiteSpaces(buffer, offset2);

      // Получаем значение.
      const obj = this.read(buffer, xref, offset2);
      if (!obj.ok) {
        throw new Error("Dictionary: Плохое значение");
      }
      offset2 = obj.offset2;

      const value = obj.value;
      value.xref = xref;
      //#endregion

      if (!(value.parent instanceof syntax.PdfIndirectObject) && !(value instanceof syntax.PdfIndirectObject)) {
        value.parent = dictionary;
      }
      dictionary.values.set(key, value);
    }

    dictionary.raw = buffer.subarray(index, offset2 + 1);

    return {
      ok: true,
      offset1: index,
      offset2,
      value: dictionary,
    };
  }

  public static readArray(buffer: PdfBuffer, xref: syntax.XRef, index: number): IResultRead<syntax.PdfArray> {
    const leftBracket = Parser.isChar(buffer, index, syntax.CharCodes.leftSquareBracket);
    if (!leftBracket) {
      return { ok: false };
    }
    const arr = new syntax.PdfArray();

    const objects: syntax.PdfIndirectObjectType[] = [];

    let offset2 = index;
    while (true) {
      offset2++;

      // Проверка на завершение документа.
      Parser.isEndFile(buffer, offset2);

      // Проверяем пробелы.
      offset2 = Parser.skipWhiteSpaces(buffer, offset2);

      // Проверяем закончился массив или нет.
      const rightBracket = Parser.isChar(buffer, offset2, syntax.CharCodes.rightSquareBracket);
      if (rightBracket) {
        offset2;
        break;
      }

      const obj = this.read(buffer, xref, offset2);
      if (obj.ok) {
        offset2 = obj.offset2;
        if (!(obj.value instanceof syntax.PdfIndirectObject)) {
          obj.value.parent = arr;
        }
        objects.push(obj.value);
        continue;
      }
    }

    arr.value = objects;
    arr.raw = buffer.subarray(index, offset2);

    return {
      ok: true,
      offset1: index,
      offset2,
      value: arr,
    };
  }

  /**
   * Пропускает пробелы и возвращает индекс следующий за пробелом/пробелами.
   * @param buffer
   * @param offset
   * @returns
   */
  public static skipWhiteSpaces(buffer: PdfBuffer, offset: number, reverse = false): number {
    let index = offset;
    const space = Parser.isType(buffer, index, syntax.CharTypes.whiteSpaces, reverse);
    if (space.ok) {
      index = space.offset2 + 1;
    }

    return index;
  }

  /**
   * Пропускает пробелы и комментарии и возвращает индекс следующий за пробелом/пробелами.
   * @param buffer
   * @param offset
   * @returns
   */
  public static skipWhiteSpacesAndComments(buffer: PdfBuffer, offset: number): number {
    let index = offset;
    while (true) {
      index = Parser.skipWhiteSpaces(buffer, index);
      const comment = Parser.readComment(buffer, index);
      if (comment.ok) {
        index = comment.offset2 + 1;
      } else {
        break;
      }
    }

    return index;
  }

  public static readBoolean(buffer: PdfBuffer, index: number): IResultRead<syntax.PdfBoolean> {
    const first = Parser.isWord(buffer, index, syntax.CharWords.false);
    if (first.ok) {
      const value = new syntax.PdfBoolean({ value: false });
      value.raw = buffer.subarray(index, first.offset2 + 1);

      return {
        ok: true,
        offset1: first.offset1,
        offset2: first.offset2,
        value,
      };
    }
    const second = Parser.isWord(buffer, index, syntax.CharWords.true);
    if (second.ok) {
      const value = new syntax.PdfBoolean({ value: true });
      value.raw = buffer.subarray(index, second.offset2 + 1);

      return {
        ok: true,
        offset1: second.offset1,
        offset2: second.offset2,
        value,
      };
    }

    return { ok: false };
  }

  public static readString(buffer: PdfBuffer, index: number): IResultRead<syntax.PdfHexString | syntax.PdfLiteralString | syntax.PdfName> {
    const name = Parser.readNameString(buffer, index);
    if (name.ok) {
      return name;
    }

    const hex = Parser.readHexString(buffer, index);
    if (hex.ok) {
      return hex;
    }

    const literal = Parser.readLiteralString(buffer, index);
    if (literal.ok) {
      return literal;
    }

    return { ok: false };
  }

  public static readHexString(buffer: PdfBuffer, index: number): IResultRead<syntax.PdfHexString> {
    const str = Parser.isBetween(buffer, index, syntax.CharCodes.leftAngleBracket, syntax.CharCodes.rightAngleBracket);
    if (!str.ok) {
      return { ok: false };
    }

    const value = buffer.subarray(
      str.offset1,
      str.offset2 + 1,
    );

    const hex = new syntax.PdfHexString({ value: StringConverter.readHex(value.getRaw()) });
    hex.raw = buffer.subarray(index, str.offset2 + 2);

    return {
      ok: true,
      offset1: index,
      offset2: str.offset2 + 1,
      value: hex,
    };
  }

  public static readLiteralString(buffer: PdfBuffer, index: number): IResultRead<syntax.PdfLiteralString> {
    const str = Parser.isLiteralString(buffer, index);
    if (!str.ok) {
      return { ok: false };
    }

    const value = buffer.subarray(
      str.offset1,
      str.offset2 + 1,
    );

    const literal = new syntax.PdfLiteralString({ value: StringConverter.readLiteral(value.getRaw()) });
    literal.raw = buffer.subarray(index, str.offset2 + 2);

    return {
      ok: true,
      offset1: index,
      offset2: str.offset2 + 1,
      value: literal,
    };
  }

  public static readNameString(buffer: PdfBuffer, index: number): IResultRead<syntax.PdfName> {
    const str = Parser.isBetween(buffer, index, syntax.CharCodes.forwardSlash, syntax.CharTypes.endNameString, true, true);
    if (!str.ok) {
      return { ok: false };
    }

    const value = buffer.subarray(
      str.offset1,
      str.offset2 + 1,
    );

    const name = new syntax.PdfName({ value: StringConverter.readName(value.getRaw()) });
    name.raw = buffer.subarray(index, str.offset2 + 1);

    return {
      ok: true,
      offset1: index,
      offset2: str.offset2,
      value: name,
    };
  }

  public static readNumber(buffer: PdfBuffer, index: number): IResultRead<syntax.PdfNumber> {
    const num = Parser.isType(buffer, index, syntax.CharTypes.numbers);
    if (!num.ok) {
      return { ok: false };
    }

    const value = Parser.getNumberByOffset(buffer, num.offset1, num.offset2);

    const obj = new syntax.PdfNumber({ value });
    obj.raw = buffer.subarray(index, num.offset2 + 1);

    return {
      ok: true,
      offset1: num.offset1,
      offset2: num.offset2,
      value: obj,
    };
  }

  public static readNull(buffer: PdfBuffer, index: number): IResultRead<syntax.PdfNull> {
    const nullWord = Parser.isWord(buffer, index, syntax.CharWords.null);
    if (!nullWord.ok) {
      return { ok: false };
    }

    const obj = new syntax.PdfNull();
    obj.raw = buffer.subarray(index, nullWord.offset2 + 1);

    return {
      ok: true,
      offset1: index,
      offset2: nullWord.offset2,
      value: obj,
    };
  }

  private static num(view: Uint8Array, defaultValue = 0) {
    if (!view.length) {
      return defaultValue;
    }

    let value = 0;
    for (const byte of view) {
      value = (value << 8) | byte;
    }

    return value;
  }

  /**
   * ```
   * <<
   *  /Type /XRef
   *  /Index [0 32]   %This section has one subsection with 32 objects
   *  /W [1 2 2]      %Each entry has 3 fields: 1, 2 & 2 bytes in width respectively
   *  /Filter /ASCIIHexDecode     %For readability in this example
   *  /Size 32
   *  ...
   * >>
   * stream
   *   00 0000 FFFF
   *   ... cross-references for objects 1 through 10 ...
   *   02 000F 0000
   *   02 000F 0001
   *   02 000F 0002
   *   ... cross-reference for object 14 ...
   *   01 BA5E 0000
   *   ...
   * endstream
   * endobj
   *
   * startxref
   * 54321
   * %%EOF
   * ```
   */
  private readXRefStream(offset1: number): syntax.XRefStream {
    const headerObj = Parser.isObject(this.#doc.buffer, offset1);
    if (!headerObj.ok) {
      throw new Error("XRefStream должен начинаться как IndirectObject");
    }
    const xRefStream = new syntax.XRefStream();
    xRefStream.doc = this.#doc;
    try {
      this.#doc.xref;
    } catch (error) {
      this.#doc.xref = xRefStream;
    }

    xRefStream.parent = new syntax.PdfIndirectObject({ id: headerObj.pair.num1, offset: offset1, type: syntax.IndirectObjectType.inUse });

    const offset2 = Parser.skipWhiteSpaces(this.#doc.buffer, headerObj.offset2 + 1);

    const stream = this.readObject(offset2, syntax.PdfStream);
    xRefStream.raw = stream.raw;
    xRefStream.values = stream.values;
    xRefStream.stream = stream.stream;

    //#region Чтение элементов.
    // Получение W.
    const w = xRefStream.W;
    if (w.length !== 3) {
      throw new Error(`W имеет длину ${w.length}`);
    }

    const objectSets: IPairsNumbers[] = [];

    // Определение наборов.
    for (let index = 0; index < xRefStream.Index.length; index++) {
      objectSets.push({
        num1: xRefStream.Index.get(index++, syntax.PdfNumber).value,
        num2: xRefStream.Index.get(index, syntax.PdfNumber).value,
      });
    }

    let offset = 0;
    const w1 = w.get(0, syntax.PdfNumber).value;
    const w2 = w.get(1, syntax.PdfNumber).value;
    const w3 = w.get(2, syntax.PdfNumber).value;

    const rawStream = new PdfBuffer(xRefStream.value);
    for (const set of objectSets) {
      for (let index = 0; index < set.num2; index++) {
        const objId = set.num1 + index;

        const field1 = Parser.num(rawStream.subarray(offset, offset + w1).getRaw());
        offset += w1;

        const field2 = Parser.num(rawStream.subarray(offset, offset + w2).getRaw());
        offset += w2;

        const field3 = Parser.num(rawStream.subarray(offset, offset + w3).getRaw());
        offset += w3;

        switch (field1) {
          // Free.
          case 0:
            // field2 - Номер объекта, следующего за данным free объектом.
            // field3 - Значение generation номера, которое будет использовано, если данный номер объекта будет использован повторно.
            // TODO в данный момент мы игнорируем удаленные объекты. в дальнейшем их надо поддержать.
            break;

          // InUse.
          case 1:
            // field2 - Байтовое смещение объекта, начиная с начала файла.
            // field3 - Значение generation номера для объекта.
            xRefStream.push(new syntax.PdfIndirectObject({ id: objId, offset: field2, type: syntax.IndirectObjectType.inUse }));
            break;

          // Compressed.
          case 2:
            // field2 - Номер IndirectObject потока, в котором хранится данный объект.
            // field3 - Индекс данного объекта внутри IndirectObject.
            xRefStream.push(new syntax.PdfIndirectObject({ id: objId, objStream: field2, index: field3, type: syntax.IndirectObjectType.compressed }));
            break;

          default:
            throw new Error(`Неподдерживаемый тип W ${field1}`);
        }
      }
    }
    //#endregion

    // Чтение предыдущих XRef.
    if (xRefStream.trailer.Prev) {
      xRefStream.prev = this.readXRefStream(xRefStream.trailer.Prev);
    }

    // Перебирает все временные IndirectObject в trailer и заменяет на уже созданные.
    for (const [key, value] of xRefStream.trailer.items) {
      if (value instanceof syntax.PdfIndirectObject) {
        const a = xRefStream.findIndirectObject(value.id);
        if (a) {
          xRefStream.trailer.values.set(key, a);
        }
      }
    }

    return xRefStream;
  }

  private getLastEOF(): number {
    let offset1 = 0;

    // Находим последний EOF. Перебор начинаем с конца документа.
    let index = this.#doc.buffer.length;
    while (index > 0) {
      const eof = Parser.isWord(this.#doc.buffer, index--, syntax.CharWords.eof, true);
      if (eof.ok) {
        index = eof.offset1 - 1;
        break;
      }
    }

    // Определяем offset начала XRef.
    while (index > 0) {
      const offsetXRef = Parser.isType(this.#doc.buffer, index--, syntax.CharTypes.numbers, true);
      if (offsetXRef.ok) {
        offset1 = Parser.getNumberByOffset(this.#doc.buffer, offsetXRef.offset1, offsetXRef.offset2);
        index = offsetXRef.offset1 - 1;
        break;
      }
    }

    return offset1;
  }

  private readXRefTable(offset1: number): syntax.XRefTable {
    const start = Parser.skipWhiteSpaces(this.#doc.buffer, offset1);
    const xrefHeader = Parser.isWord(this.#doc.buffer, start, syntax.CharWords.xref);
    if (!xrefHeader.ok) {
      throw new Error(`Заголовок 'xref' не найден ${offset1}`);
    }
    let offset2 = Parser.skipWhiteSpaces(this.#doc.buffer, xrefHeader.offset2 + 1);

    const xRefTable = syntax.XRefTable.createByParams({ doc: this.#doc });

    while (true) {
      offset2 = Parser.skipWhiteSpaces(this.#doc.buffer, offset2);
      // Перебираем символы пока не встретим слово trailer.
      const tr = Parser.isWord(this.#doc.buffer, offset2, syntax.CharWords.trailer);
      if (tr.ok) {
        offset2 = tr.offset2 + 1;
        break;
      }

      //#region Читаем Header таблицы. id n.
      offset2 = Parser.skipWhiteSpaces(this.#doc.buffer, offset2);

      // Первое число.
      const idResult = Parser.isType(this.#doc.buffer, offset2, syntax.CharTypes.numbers);
      if (!idResult.ok) {
        throw new Error(`Неправильный ID в заголовке таблицы XRefTable ${offset2}`);
      }
      offset2 = Parser.skipWhiteSpaces(this.#doc.buffer, idResult.offset2 + 1);

      // Второе число.
      const countResult = Parser.isType(this.#doc.buffer, offset2, syntax.CharTypes.numbers);
      if (!countResult.ok) {
        throw new Error(`Неправильный Count в заголовке таблицы XRefTable ${offset2}`);
      }
      offset2 = countResult.offset2 + 1;
      //#endregion

      const count = Parser.getNumberByOffset(this.#doc.buffer, countResult.offset1, countResult.offset2);
      const id = Parser.getNumberByOffset(this.#doc.buffer, idResult.offset1, idResult.offset2);
      for (let index = 0; index < count; index++) {
        //#region Поиск комбинаций потипу "0123456789 01234 n"
        offset2 = Parser.skipWhiteSpaces(this.#doc.buffer, offset2);
        // Первое число.
        const first = Parser.isType(this.#doc.buffer, offset2, syntax.CharTypes.numbers);
        if (!first.ok) {
          throw new Error(`Неправильный Offset в записи таблицы XRefTable ${offset2}`);
        }
        offset2 = Parser.skipWhiteSpaces(this.#doc.buffer, first.offset2 + 1);

        // Второе число.
        const second = Parser.isType(this.#doc.buffer, offset2, syntax.CharTypes.numbers);
        if (!first.ok) {
          throw new Error(`Неправильный Generation в записи таблицы XRefTable ${offset2}`);
        }
        offset2 = Parser.skipWhiteSpaces(this.#doc.buffer, second.offset2 + 1);

        // Флаг. Идет проверка только на не удаленные объекты.
        const flag = Parser.isChar(this.#doc.buffer, offset2, syntax.CharCodes.n);
        if (!flag) {
          offset2 = offset2 + 2;
          continue;
          // throw new Error(`Неправильный Flag в записи таблицы XRefTable ${offset2}`);
        }
        //#endregion

        // Проверяем offset на 0.
        const objOffset = Parser.getNumberByOffset(this.#doc.buffer, first.offset1, first.offset2);
        if (objOffset === 0) {
          offset2 = offset2 + 2;
          continue;
        }

        // Фиксируем номер объекта.
        let objId = id + index;
        if (xRefTable.Size <= objId) {
          xRefTable.Size = objId + 1;
        }

        // Проверка на соответствие индексов объектов с таблицей xref.
        const headerObject = Parser.isObject(this.#doc.buffer, objOffset);
        if (!headerObject) {
          throw new Error(`Индекс ${objOffset} из таблицы XRef указывает на несуществующий объект`);
        }
        if (objId !== headerObject.pair.num1) {
          objId = headerObject.pair.num1;
        }

        // Создание PdfIndirectObject.
        const generation = Parser.getNumberByOffset(this.#doc.buffer, second.offset1, second.offset2);
        xRefTable.push(new syntax.PdfIndirectObject({ id: objId, offset: objOffset, generation }));

        offset2 = offset2 + 2;
      }
    }

    // Читаем trailer.
    offset2 = Parser.skipWhiteSpaces(this.#doc.buffer, offset2);

    const tr = this.readObject(offset2, syntax.PdfDictionary);
    tr.xref = xRefTable;

    xRefTable.trailer = tr.convert(syntax.Trailer);
    if (xRefTable.trailer.Prev) {
      xRefTable.prev = this.readXRefTable(xRefTable.trailer.Prev);
    }
    offset2 += tr.raw.length + 1;

    // Перебирает все временные IndirectObject в trailer и заменяет на уже созданные.
    for (const [key, value] of xRefTable.trailer.items) {
      if (value instanceof syntax.PdfIndirectObject) {
        const a = xRefTable.getIndirectObject(value.id);
        xRefTable.trailer.values.set(key, a);
      }
    }

    // Формируем view XRef.
    const eof = Parser.findWord(this.#doc.buffer, offset2, syntax.CharWords.eof);
    if (!eof.ok) {
      throw new Error("Нет окончания EOF в XRefTable");
    }
    xRefTable.raw = this.#doc.buffer.subarray(offset1, eof.offset2 + 1);

    return xRefTable;
  }

  //#endregion

  //#region is
  private static isLiteralString(buffer: PdfBuffer, offset1: number): IResultIs {
    let offset2 = offset1;

    // Проверяем что начинается с '('.
    if (!Parser.isChar(buffer, offset2, syntax.CharCodes.leftParenthesis)) {
      return { ok: false, offset1, offset2 };
    }
    offset2++;

    for (; offset2 < buffer.raw.length; offset2++) {
      // Проверяем на закрытие ")".
      if (Parser.isChar(buffer, offset2, syntax.CharCodes.rightParenthesis)) {
        // Выравниваем индексы, так как они должны аналогично методу isBetween указывать на содержимое.
        return {
          ok: true,
          offset1: offset1 + 1,
          offset2: offset2 - 1
        };
      }

      // \ - символ экранирования
      if (Parser.isChar(buffer, offset2, syntax.CharCodes.slash)) {
        offset2++;
        continue;
      }

      // Проверяем на начало нового блока "(".
      const res = Parser.isLiteralString(buffer, offset2);
      if (res.ok) {
        offset2 = res.offset2 + 1;
      }
    }

    throw new Error(`Некорректный формат LiteralString по offset '${offset1}'`);
  }

  /**
   * Проверяет не вышел ли индекс за предел файла.
   * @param offset2 Проверяемый индекс.
   */
  private static isEndFile(buffer: PdfBuffer, offset2: number) {
    if (offset2 >= buffer.length) {
      throw new Error("Конец файла");
    }
  }

  /**
   * Проверяет является ли данный индекс началом stream.
   * @param index
   * @param length
   * @returns Если true то возвращает индексы содержимого stream.
   */
  private static isStream(buffer: PdfBuffer, index: number, length: number): IResultIs {
    let offset1 = index;
    let offset2 = index;

    const start = Parser.isWord(buffer, offset2, syntax.CharWords.stream);
    if (!start.ok) {
      return { ok: false, offset1, offset2 };
    }

    offset1 = start.offset2 + 1; // Индекс начала содержимого stream.
    offset2 = start.offset2 + 3 + length;

    // Попробуем сразу найти конец потока
    const end = Parser.isWord(buffer, offset2, syntax.CharWords.endstream);
    if (end.ok) {
      offset2 = end.offset1 - 1; // Индекс конца содержимого stream.
    } else {
      // Если конец не найден, вернем offset2 к началу потока и начнем поиск
      offset2 = offset1;
      while (true) {
        // Проверяем на конец файла.
        Parser.isEndFile(buffer, offset2);

        const end = Parser.isWord(buffer, offset2, syntax.CharWords.endstream);
        if (end.ok) {
          offset2 = end.offset1 - 1; // Индекс конца содержимого stream.
          break;
        }

        offset2++;
      }

      const eol = Parser.isType(buffer, offset2, syntax.CharWords.eol, true);
      if (eol.ok) {
        offset2 = eol.offset1;
      }
    }

    return { ok: true, offset1, offset2 };
  }

  /**
   *  Проверяет указывает ли данный индекс на начало объекта.
   * @param index Индекс начала объекта.
   * @returns Если результат положительный то ответ содержит номер объекта.
   */
  private static isObject(buffer: PdfBuffer, index: number): IResultIsPairsNumbers {
    return Parser.isPairNumbers(buffer, index, syntax.CharWords.obj);
  }

  /**
   * Проверяет указывает ли данный индекс на начало ссылки объекта.
   * @param index Индекс начала ссылки.
   * @returns Если результат положительный то ответ содержит номер ссылки.
   */
  private static isRef(buffer: PdfBuffer, index: number): IResultIsPairsNumbers {
    return Parser.isPairNumbers(buffer, index, syntax.CharCodes.r);
  }

  /**
   * Проверяет указывает ли данный индекс на начало записи типа 0123 0123 EndWord.
   * @param index Индекс начала записи.
   * @returns Если результат положительный то ответ содержит номер ссылки.
   */
  private static isPairNumbers(buffer: PdfBuffer, index: number, endWord?: Uint8Array): IResultIsPairsNumbers {
    const offset1: number = index;
    let offset2: number = index;

    const obj: IResultIsPairsNumbers = {
      pair: {
        num1: 0,
        num2: 0,
      },
      offset1,
      offset2,
      ok: false,
    };

    // Проверяем пробелы
    // Добавлено из-за случаев когда офсет указывает на пробел перед символом.
    offset2 = Parser.skipWhiteSpaces(buffer, offset2);

    // Первое число.
    const first = Parser.isType(buffer, offset2, syntax.CharTypes.integer);
    if (!first.ok) {
      return obj;
    }
    offset2 = first.offset2 + 1;

    // Пробел.
    const space = Parser.isType(buffer, offset2, syntax.CharTypes.whiteSpaces);
    if (!space.ok) {
      return obj;
    }
    offset2 = space.offset2 + 1;

    // Второе число.
    const second = Parser.isType(buffer, offset2, syntax.CharTypes.numbers);
    if (!first.ok) {
      return obj;
    }
    offset2 = second.offset2 + 1;

    // Пробел.
    const space2 = Parser.isType(buffer, offset2, syntax.CharTypes.whiteSpaces);
    if (!space2.ok) {
      return obj;
    }
    offset2 = space2.offset2 + 1;

    // Конечное слово.
    if (endWord) {
      const tr = Parser.isWord(buffer, offset2, endWord);
      if (!tr.ok) {
        return obj;
      }
      offset2 = tr.offset2;
    }

    return {
      pair: {
        num1: Parser.getNumberByOffset(buffer, first.offset1, first.offset2),
        num2: Parser.getNumberByOffset(buffer, second.offset1, second.offset2),
      },
      offset1,
      offset2,
      ok: true,
    };
  }

  /**
   * Проверяет первый символ или слово и ищет замыкающий символ или слово.
   * @param index Индекс первого символа.
   * @param start Открывающий символ или слово.
   * @param end Закрывающий символ или слово.
   * @returns Если true то возвращает индексы значения между start и end.
   */
  private static isBetween(buffer: PdfBuffer, index: number, start: Uint8Array, end: Uint8Array, endIsType = false, toEnd = false): IResultIs {
    const slash = Parser.isWord(buffer, index, start);
    let offset2 = index;
    if (!slash.ok) {
      return {
        ok: false,
        offset1: index,
        offset2: index,
      };
    }

    if (endIsType) {
      const value = this.findType(buffer, slash.offset2 + 1, end, toEnd);
      if (!value.ok) {
        return {
          ok: false,
          offset1: index,
          offset2: index,
        };
      }
      offset2 = value.offset1 - 1;
    } else {
      const value = Parser.findWord(buffer, slash.offset2 + 1, end, toEnd);
      if (!value.ok) {
        return {
          ok: false,
          offset1: index,
          offset2: index,
        };
      }
      offset2 = value.offset1 - 1;
    }


    return {
      ok: true,
      offset1: slash.offset2 + 1,
      offset2,
    };
  }

  /**
   * Проверяет является ли текущий символ проверяемого типа.
   * Если этот символ относится к данному типу то метод перебирает последующие символы,
   * до тех пор пока не закончится данный тип значения.
   * @param index Текущий индекс символа
   * @param reverse Если true то перебор индексов идет в обратном направлении. По умолчанию false.
   * @returns Если результат положительный то в offset2 лежит индекс последнего символа значения.
   */
  private static isType(buffer: PdfBuffer, index: number, typeChar: Uint8Array, reverse = false): IResultIs {
    let length = 0;

    if (reverse) {
      for (let e = index; e > 0; e--) {
        if (!Parser.isChar(buffer, e, typeChar)) {
          break;
        }
        length++;
      }
      if (length > 0) {
        return { offset1: index - length + 1, offset2: index, ok: true };
      }
    } else {
      for (let e = index; e < buffer.length; e++) {
        if (!Parser.isChar(buffer, e, typeChar)) {
          break;
        }
        length++;
      }
      if (length > 0) {
        return { offset1: index, offset2: index + length - 1, ok: true };
      }
    }


    return { offset1: index, offset2: index, ok: false };
  }

  /**
   * Проверяет входит ли текущий символ в целевой массив.
   * @param index Индекс текущего символа.
   * @param array Массив со значениями которого сравнивается текущий символ.
   * @returns
   */
  private static isChar(buffer: PdfBuffer, index: number, array: Uint8Array): boolean {
    return array.includes(buffer.subarray(index, index + 1).getRaw()[0]);
  }

  /**
   * Проверяет является ли следующий набор символов, начиная с индекса, проверяемым словом.
   * @param index Индекс начала слова.
   * @param word Проверяемое слово.
   * @param reverse Если true то перебор индексов идет в обратном направлении. По умолчанию false.
   * @returns Если результат положительный то в offset2 лежит индекс последнего символа слова.
   */
  public static isWord(buffer: PdfBuffer, index: number, word: Uint8Array, reverse = false): IResultIs {
    let i = index;
    if (reverse) {
      for (let e = word.length - 1; e >= 0; e--) {
        const char = word[e];
        if (char !== buffer.raw[i--]) {
          return { offset1: index, offset2: index, ok: false };
        }
      }

      return { offset1: i + 1, offset2: index, ok: true };
    }

    for (let e = 0; e < word.length; e++) {
      const char = word[e];
      if (buffer.raw[i++] !== char) {
        return { offset1: index, offset2: index, ok: false };
      }
    }

    return { offset1: index, offset2: i - 1, ok: true };
  }

  /**
   * Перебирает символы до тех пор пока не встретит искомое слово.
   * @param index Индекс начала поиска.
   * @param word Искомое слово.
   * @returns Если результат положительный то в offset1 и offset2 лежат индексы начала и конца слова.
   */
  private static findWord(buffer: PdfBuffer, index: number, word: Uint8Array, toEnd = false): IResultIs {
    let off2 = index;
    while (true) {
      const w = Parser.isWord(buffer, off2++, word);
      if (w.ok) {
        off2 = w.offset2;

        return {
          ok: true,
          offset1: w.offset1,
          offset2: w.offset2,
        };
      }

      if (off2 === buffer.length) {
        if (toEnd) {
          return {
            ok: true,
            offset1: w.offset1,
            offset2: w.offset2,
          };
        }

        return {
          ok: false,
          offset1: index,
          offset2: index,
        };
      }
    }
  }

  private static findType(buffer: PdfBuffer, index: number, type: Uint8Array, toEnd = false): IResultIs {
    let off2 = index;
    while (true) {
      const w = Parser.isType(buffer, off2++, type);
      if (w.ok) {
        off2 = w.offset2;

        return {
          ok: true,
          offset1: w.offset1,
          offset2: w.offset2,
        };
      }

      if (off2 === buffer.length) {
        if (toEnd) {
          return {
            ok: true,
            offset1: w.offset1,
            offset2: w.offset2,
          };
        }

        return {
          ok: false,
          offset1: index,
          offset2: index,
        };
      }
    }
  }
  //#endregion

  private static getNumberByOffset(buffer: PdfBuffer, offset1: number, offset2: number): number {
    return Number(buffer.subarray(offset1, offset2 + 1).toString());
  }

  private getByte(offset: number): number {
    return this.#doc.buffer.raw[offset];
  }

  /**
   * Проверяет, является ли данный символ допустимой буквой оператора.
   * Буквы оператора включают A-Z, a-z, *, ', и ".
   *
   * @param char - Проверяемый символ.
   * @returns `true`, если символ является допустимой буквой оператора, `false` в противном случае.
   */
  private static isOperatorLetter(char: number): boolean {
    return (char >= 65 && char <= 90) // A-Z
      || (char >= 97 && char <= 122) // a-z
      || char === 42 || char === 39 || char === 34; // * ' "
  }

  private static readOperatorTag(buffer: PdfBuffer, index: number): IResultRead<syntax.PdfOperator> {
    // Находим индекс первого символа, который не является буквой оператора
    let offset2 = index;
    while (offset2 < buffer.length && Parser.isOperatorLetter(buffer.raw[offset2])) {
      offset2++;
    }

    // Получаем тег оператора одним вызовом
    const tag = String.fromCharCode(...buffer.raw.subarray(index, offset2));
    const operator = new syntax.PdfOperator({ tag });
    operator.raw = buffer.subarray(index, offset2); // Не нужен +1, так как subarray не включает последний индекс

    return {
      ok: true,
      offset1: index,
      offset2: offset2 - 1,
      value: operator,
    };
  }

  private static readOperatorOrObject(buffer: PdfBuffer, xref: syntax.XRef, index: number): IResultRead<syntax.RawData> {
    // Оптимизированный доступ к первому символу
    if (index >= buffer.length) {
      return { ok: false };
    }
    const char = buffer.raw[index];
    if (Parser.isOperatorLetter(char)) {
      return Parser.readOperatorTag(buffer, index);
    }

    return Parser.read(buffer, xref, index);
  }

  public static readOperator(buffer: PdfBuffer, xref: syntax.XRef, index: number): IResultRead<syntax.PdfOperator> {
    const args: syntax.PdfObjectType[] = [];
    let offset = index;

    while (offset < buffer.length) {
      offset = Parser.skipWhiteSpaces(buffer, offset);
      const res = Parser.readOperatorOrObject(buffer, xref, offset);
      if (!res.ok) {
        break;
      }
      if (res.ok && res.value instanceof syntax.PdfOperator) {
        res.value.params = args;
        res.value.raw = buffer.subarray(index, res.offset2 + 1);

        return {
          ok: res.ok,
          offset1: index,
          offset2: res.offset2 + 1,
          value: res.value,
        };
      }
      args.push(res.value as syntax.PdfObjectType);
      offset = res.offset2 + 1;
    }

    return { ok: false };
  }
}
