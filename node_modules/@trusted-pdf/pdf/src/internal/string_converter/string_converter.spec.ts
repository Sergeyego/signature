import * as assert from "node:assert";
import { StringConverter } from "./string_converter";
import {
  Encoding,
  ensure1ByteHex,
  unescapeSpecialSymbols,
  fromBinary,
  hasMoreThan1ByteChars,
  hasUtf16BeBOM,
  hasUtf8BOM,
  hexToBinary,
  hexTo2ByteHex,
  decodeString,
  toBinary,
  escapeSpecialSymbols,
  toUtf16Be,
} from "./utils";

describe("StringConverter", function () {
  describe("readHex()", function () {
    const vectors: {
      title: string,
      hexStr: string,
      expected: string,
    }[] = [
        {
          title: "empty",
          hexStr: "",
          expected: "",
        },
        {
          title: "valid hex",
          hexStr: "68656c6c6f",
          expected: "hello",
        },
        {
          title: "utf-8 hex",
          hexStr: "efbbbf68656c6c6f",
          expected: "hello",
        },
        {
          title: "utf-16be cyrillic",
          hexStr: "feff0430043104320451",
          expected: "абвё",
        },
        {
          title: "with whitespaces",
          hexStr: " 4E6\x00F7620 73686\tD6F7A\n206B6\f 120 \r706F702E\n ",
          expected: "Nov shmoz ka pop.",
        },
        {
          title: "append zero if length is an odd number",
          hexStr: "2",
          expected: " ",
        },
        {
          title: "binary data",
          hexStr: "ae0d6d5ff476d42ea81f8900bb57ebd5b5b1bd1a",
          expected: "\xae\x0d\x6d\x5f\xf4\x76\xd4\x2e\xa8\x1f\x89\x00\xbb\x57\xeb\xd5\xb5\xb1\xbd\x1a",
        },
      ];

    vectors.forEach(vector => {
      it(vector.title, function () {
        const hexBuf = new Uint8Array(Buffer.from(vector.hexStr));

        const result = StringConverter.readHex(hexBuf);

        assert.equal(result, vector.expected);
      });
    });
  });

  describe("writeHex()", function () {
    const vectors: {
      title: string,
      asciiStr: string,
      expected: string,
    }[] = [
        {
          title: "empty",
          asciiStr: "",
          expected: "",
        },
        {
          title: "valid hex",
          asciiStr: "hello",
          expected: "68656c6c6f",
        },
        {
          title: "with whitespaces",
          asciiStr: "\nNov shmoz\tka pop\f\r.\x00",
          expected: "0a4e6f762073686d6f7a096b6120706f700c0d2e00",
        },
        {
          title: "cyrillic",
          asciiStr: "абвё",
          expected: "feff0430043104320451",
        },
      ];

    vectors.forEach(vector => {
      it(vector.title, function () {
        const expectedHexBuf = new Uint8Array(Buffer.from(vector.expected));

        const result = StringConverter.writeHex(vector.asciiStr);

        assert.deepStrictEqual(result, expectedHexBuf);
      });
    });
  });

  describe("readLiteral()", function () {
    const vectors: {
      title: string,
      literalStr: string,
      expected: string,
    }[] = [
        {
          title: "empty",
          literalStr: "",
          expected: "",
        },
        {
          title: "utf-16be cyrillic",
          literalStr: "\xfe\xff\x04\x1f\x04\x40\x04\x38\x04\x32\x04\x35\x04\x42",
          expected: "Привет",
        },
        {
          title: "utf-16be + special symbols",
          literalStr: "\xfe\xff\x04\x30\x04\x31\x04\x32\x04\x51\x00\x5c\x74\x00\x5c\x28\x00\x5c\x29",
          expected: "абвё\t()",
        },
        {
          title: "utf-8",
          literalStr: "\xef\xbb\xbfThis string contains \xc2\xa5two special characters\xc3\x87.",
          expected: "This string contains ¥two special charactersÇ.",
        },
        {
          title: "ascii (binary)",
          literalStr: "Hello",
          expected: "Hello",
        },
        {
          title: "binary + octal codes",
          literalStr: "Hello\\245 \\307",
          expected: "Hello¥ Ç",
        },
      ];

    vectors.forEach(vector => {
      it(vector.title, function () {
        const literalBuf = new Uint8Array(Buffer.from(vector.literalStr, "binary"));

        const result = StringConverter.readLiteral(literalBuf);

        assert.equal(result, vector.expected);
      });
    });
  });

  describe("writeLiteral()", function () {
    const vectors: {
      title: string,
      str: string,
      expected: string,
    }[] = [
        {
          title: "empty",
          str: "",
          expected: "",
        },
        {
          title: "utf-16 cyrillic",
          str: "Привет",
          expected: "\xfe\xff\x04\x1f\x04\x40\x04\x38\x04\x32\x04\x35\x04\x42",
        },
        {
          title: "ascii (binary)",
          str: "Hello",
          expected: "Hello",
        },
        {
          title: "binary + escape reverse solidus",
          str: "\x43\xaf\xc9\x7f\xef\xff\xe6\xa8\xcb\x5c\xaf\xd0",
          expected: "C¯Éïÿæ¨Ë\\\\¯Ð",
        },
        {
          title: "binary + escape symbols",
          str: "\n(this) \t string has\\ \r\nspecial\f symbols\b",
          expected: "\\n\\(this\\) \\t string has\\\\ \\r\\nspecial\\f symbols\\b",
        },
        {
          title: "utf-16 + escape tab and parentheses",
          str: "абвё\t()",
          expected: "\xfe\xff\x04\x30\x04\x31\x04\x32\x04\x51\x00\x5c\x74\x00\x5c\x28\x00\x5c\x29",
        },
        {
          title: "utf-16 + escape special symbols",
          str: "ё\\\f\b",
          expected: "\xfe\xff\x04\x51\x00\x5c\x5c\x00\x5c\x66\x00\x5c\x62",
        },
        {
          title: "utf-16 + escape line breaks",
          str: "ё\n\r\n",
          expected: "\xfe\xff\x04\x51\x00\x5c\x6e\x00\x5c\x72\x00\x5c\x6e",
        },
        {
          title: "cyrillic",
          str: "ОБЩЕСТВО",
          expected: "\xfe\xff\x04\x1e\x04\x11\x04\x5c\x29\x04\x15\x04\x21\x04\x22\x04\x12\x04\x1e",
        },
      ];

    vectors.forEach(vector => {
      it(vector.title, function () {
        const expected = new Uint8Array(Buffer.from(vector.expected, "binary"));

        const result = StringConverter.writeLiteral(vector.str);

        assert.deepStrictEqual(result, expected);
      });
    });
  });

  describe("readName()", function () {
    const vectors: {
      title: string,
      str: string,
      expected: string,
    }[] = [
        {
          title: "empty",
          str: "",
          expected: "",
        },
        {
          title: "Name1",
          str: "Name1",
          expected: "Name1",
        },
        {
          title: "A;Name_With-Various***Characters?",
          str: "A;Name_With-Various***Characters?",
          expected: "A;Name_With-Various***Characters?",
        },
        {
          title: "1.2",
          str: "1.2",
          expected: "1.2",
        },
        {
          title: "$$",
          str: "$$",
          expected: "$$",
        },
        {
          title: "@pattern",
          str: "@pattern",
          expected: "@pattern",
        },
        {
          title: ".notdef",
          str: ".notdef",
          expected: ".notdef",
        },
        {
          title: "Lime#20Green",
          str: "Lime#20Green",
          expected: "Lime Green",
        },
        {
          title: "paired#28#29parentheses",
          str: "paired#28#29parentheses",
          expected: "paired()parentheses",
        },
        {
          title: "with #",
          str: "The_Key_of_F#23_Minor",
          expected: "The_Key_of_F#_Minor",
        },
        {
          title: "A#42",
          str: "A#42",
          expected: "AB",
        },
      ];

    vectors.forEach((vector) => {
      it(vector.title, function () {
        const nameBuf = new Uint8Array(Buffer.from(vector.str));

        const result = StringConverter.readName(nameBuf);

        assert.equal(result, vector.expected);
      });
    });
  });

  describe("writeName()", function () {
    const vectors: {
      title: string,
      str: string,
      expected: string,
    }[] = [
        {
          title: "empty",
          str: "",
          expected: "",
        },
        {
          title: "Name1",
          str: "Name1",
          expected: "Name1",
        },
        {
          title: "A;Name_With-Various***Characters?",
          str: "A;Name_With-Various***Characters?",
          expected: "A;Name_With-Various***Characters?",
        },
        {
          title: "1.2",
          str: "1.2",
          expected: "1.2",
        },
        {
          title: "$$",
          str: "$$",
          expected: "$$",
        },
        {
          title: "@pattern",
          str: "@pattern",
          expected: "@pattern",
        },
        {
          title: ".notdef",
          str: ".notdef",
          expected: ".notdef",
        },
        {
          title: "Lime#20Green",
          str: "Lime Green",
          expected: "Lime#20Green",
        },
        {
          title: "paired#28#29parentheses",
          str: "paired()parentheses",
          expected: "paired#28#29parentheses",
        },
        {
          title: "with #",
          str: "The_Key_of_F#_Minor#",
          expected: "The_Key_of_F#23_Minor#23",
        },
      ];

    vectors.forEach((vector) => {
      it(vector.title, function () {
        const expected = new Uint8Array(Buffer.from(vector.expected));

        const result = StringConverter.writeName(vector.str);

        assert.deepStrictEqual(result, expected);
      });
    });
  });

  describe("utils", function () {
    describe("hasUtf16BeBOM()", function () {
      const vectors: {
        title: string,
        str: Uint8Array,
        expected: boolean,
      }[] = [
          {
            title: "empty",
            str: new Uint8Array(Buffer.from("")),
            expected: false,
          },
          {
            title: "no bom",
            str: new Uint8Array(Buffer.from("this string doesn't contain a bom")),
            expected: false,
          },
          {
            title: "has bom",
            str: new Uint8Array(Buffer.from("\ufeffthis string contains a bom тут есть бом", "utf16le").swap16()),
            expected: true,
          },
          {
            title: "has bom hex",
            str: hexToBinary("feff0430043104320451"),
            expected: true,
          },
        ];

      vectors.forEach((vector) => {
        it(vector.title, function () {
          const result = hasUtf16BeBOM(vector.str);

          assert.equal(result, vector.expected);
        });
      });
    });

    describe("hasUtf8BOM()", function () {
      const vectors: {
        title: string,
        str: Uint8Array,
        expected: boolean,
      }[] = [
          {
            title: "empty",
            str: new Uint8Array(Buffer.from("")),
            expected: false,
          },
          {
            title: "no bom",
            str: new Uint8Array(Buffer.from("this string doesn't contain a bom", "binary")),
            expected: false,
          },
          {
            title: "has bom",
            str: new Uint8Array(Buffer.from("\xef\xbb\xbfthis string contains a bom", "binary")),
            expected: true,
          },
        ];

      vectors.forEach((vector) => {
        it(vector.title, function () {
          const result = hasUtf8BOM(vector.str);

          assert.equal(result, vector.expected);
        });
      });
    });

    describe("ensure1ByteHex()", function () {
      const vectors: {
        title: string,
        str: string,
        expected: string,
      }[] = [
          {
            title: "empty",
            str: "",
            expected: "00",
          },
          {
            title: "0",
            str: "0",
            expected: "00",
          },
          {
            title: "1",
            str: "1",
            expected: "01",
          },
          {
            title: "fe",
            str: "fe",
            expected: "fe",
          },
        ];

      vectors.forEach((vector) => {
        it(vector.title, function () {
          const result = ensure1ByteHex(vector.str);

          assert.equal(result, vector.expected);
        });
      });
    });

    describe("hexTo2ByteHex()", function () {
      const vectors: {
        title: string,
        str: string,
        expected: string,
      }[] = [
          {
            title: "empty",
            str: "",
            expected: "0000",
          },
          {
            title: "0",
            str: "0",
            expected: "0000",
          },
          {
            title: "1",
            str: "1",
            expected: "0001",
          },
          {
            title: "fe",
            str: "fe",
            expected: "00fe",
          },
          {
            title: "9999",
            str: "9999",
            expected: "9999",
          },
        ];

      vectors.forEach((vector) => {
        it(vector.title, function () {
          const result = hexTo2ByteHex(vector.str);

          assert.equal(result, vector.expected);
        });
      });
    });

    describe("hasMoreThan1ByteChars()", function () {
      const vectors: {
        title: string,
        str: string,
        expected: boolean,
      }[] = [
          {
            title: "empty",
            str: "",
            expected: false,
          },
          {
            title: "has",
            str: "Привет",
            expected: true,
          },
          {
            title: "doesn't have",
            str: "Hello",
            expected: false,
          },
          {
            title: "0xfe char",
            str: String.fromCharCode(0xfe),
            expected: false,
          },
          {
            title: "0xff char",
            str: String.fromCharCode(0xff),
            expected: false,
          },
          {
            title: "0x100 char",
            str: String.fromCharCode(0x100),
            expected: true,
          },
        ];

      vectors.forEach((vector) => {
        it(vector.title, function () {
          const result = hasMoreThan1ByteChars(vector.str);

          assert.equal(result, vector.expected);
        });
      });
    });

    describe("fromBinary()", function () {
      const vectors: {
        title: string,
        binaryStr: Uint8Array,
        expected: string,
      }[] = [
          {
            title: "empty",
            binaryStr: new Uint8Array([]),
            expected: "",
          },
          {
            title: "cyrillic",
            binaryStr: new Uint8Array([0xd0, 0x9f, 0xd1, 0x80, 0xd0, 0xb8, 0xd0, 0xb2, 0xd0, 0xb5, 0xd1, 0x82]),
            expected: "ÐÑÐ¸Ð²ÐµÑ",
          },
        ];

      vectors.forEach((vector) => {
        it(vector.title, function () {
          const result = fromBinary(vector.binaryStr);

          assert.equal(result, vector.expected);
        });
      });
    });

    describe("toBinary()", function () {
      const vectors: {
        title: string,
        str: string,
        expected: Uint8Array,
      }[] = [
          {
            title: "empty",
            str: "",
            expected: new Uint8Array([]),
          },
          {
            title: "cyrillic",
            str: "ÐÑÐ¸Ð²ÐµÑ",
            expected: new Uint8Array([0xd0, 0x9f, 0xd1, 0x80, 0xd0, 0xb8, 0xd0, 0xb2, 0xd0, 0xb5, 0xd1, 0x82]),
          },
        ];

      vectors.forEach((vector) => {
        it(vector.title, function () {
          const result = toBinary(vector.str);

          assert.deepStrictEqual(result, vector.expected);
        });
      });
    });

    describe("hexToBinary()", function () {
      const vectors: {
        title: string,
        hexStr: string,
        expected: Uint8Array,
      }[] = [
          {
            title: "empty",
            hexStr: "",
            expected: Uint8Array.from([]),
          },
          {
            title: "valid hex",
            hexStr: "68656c6c6f",
            expected: Uint8Array.from([0x68, 0x65, 0x6c, 0x6c, 0x6f]),
          },
        ];

      vectors.forEach((vector) => {
        it(vector.title, function () {
          const result = hexToBinary(vector.hexStr);

          assert.deepStrictEqual(result, vector.expected);
        });
      });
    });

    describe("toUtf16Be()", function () {
      const vectors: {
        title: string,
        str: string,
        expected: Uint8Array,
      }[] = [
          {
            title: "empty",
            str: "",
            expected: new Uint8Array([]),
          },
          {
            title: "cyrillic",
            str: "Привет",
            expected: new Uint8Array([0x04, 0x1f, 0x04, 0x40, 0x04, 0x38, 0x04, 0x32, 0x04, 0x35, 0x04, 0x42]),
          },
          {
            title: "latin",
            str: "Hello",
            expected: new Uint8Array([0x00, 0x48, 0x00, 0x65, 0x00, 0x6c, 0x00, 0x6c, 0x00, 0x6f]),
          },
        ];

      vectors.forEach((vector) => {
        it(vector.title, function () {
          const result = toUtf16Be(vector.str);

          assert.deepStrictEqual(result, vector.expected);
        });
      });
    });

    describe("unescapeSpecialSymbols()", function () {
      const vectors: {
        title: string,
        str: string | Uint8Array,
        expected: string,
      }[] = [
          {
            title: "special symbols",
            str: "\r\\(this\\) \\t string\r\n has\\\\ \\ \\r\\nspecial\\f symbols\\b",
            expected: "\n(this) \t string\n has\\  \r\nspecial\f symbols\b",
          },
          {
            title: "reverse solidi",
            str: "\\\\ \\ \\(this string has special symbols",
            expected: "\\  (this string has special symbols",
          },
          {
            title: "octal symbols",
            str: "This string\\0403 contains \\245several \\053 octal \\53 characters\\307.",
            expected: "This string 3 contains ¥several + octal + charactersÇ.",
          },
          {
            title: "line breaks",
            str: "These \\\ntwo\\\r strings \\\r\nare the same.",
            expected: "These two strings are the same.",
          },
          {
            title: "cyrillic",
            str: "\xfe\xff\x1e\x11\x5c\x29\x15\x21\x22\x12\x1e",
            expected: "\xfe\xffОБЩЕСТВО",
          },
        ];

      vectors.forEach((vector) => {
        it(vector.title, function () {
          const buf = typeof vector.str === "string" ? new Uint8Array(Buffer.from(vector.str, "binary")) : vector.str;
          const expected = new Uint8Array(Buffer.from(vector.expected, "binary"));

          const result = unescapeSpecialSymbols(buf);

          assert.deepStrictEqual(result, expected);
        });
      });
    });

    describe("escapeSpecialSymbols()", function () {
      const vectors: {
        title: string,
        str: string,
        expected: string,
      }[] = [
          {
            title: "binary special symbols",
            str: "\n(this) \t string has\\ \r\nspecial\f symbols\b",
            expected: "\\n\\(this\\) \\t string has\\\\ \\r\\nspecial\\f symbols\\b",
          },
          {
            title: "binary reverse solidus and parentheses",
            str: "\\ (this) string has special symbols",
            expected: "\\\\ \\(this\\) string has special symbols",
          },
        ];
      vectors.forEach((vector) => {
        it(vector.title, function () {
          const isUtf16Be = hasMoreThan1ByteChars(vector.str);
          const encodedText = isUtf16Be ? fromBinary(toUtf16Be(vector.str)) : vector.str;
          const result = escapeSpecialSymbols(encodedText);

          assert.deepStrictEqual(result, vector.expected);
        });
      });
    });

    describe("decodeString", function () {
      const vectors: {
        title: string,
        str: Uint8Array,
        encoding: Encoding,
        expected: string,
      }[] = [
          {
            title: "empty",
            str: Uint8Array.from([]),
            encoding: Encoding.Utf8,
            expected: "",
          },
          {
            title: "utf-8",
            str: Uint8Array.from(Buffer.from("Hello", "utf8")),
            encoding: Encoding.Utf8,
            expected: "Hello",
          },
          {
            title: "utf-16be",
            str: Uint8Array.from(Buffer.from("Привет", "utf16le").swap16()),
            encoding: Encoding.Utf16Be,
            expected: "Привет",
          },
        ];

      vectors.forEach((vector) => {
        it(vector.title, function () {
          const result = decodeString(vector.str, vector.encoding);

          assert.equal(result, vector.expected);
        });
      });
    });
  });
});
