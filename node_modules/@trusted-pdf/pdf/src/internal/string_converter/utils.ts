export enum Encoding {
  Utf8 = "utf-8",
  Utf16Be = "utf-16be",
  Binary = "binary",
}

/**
 * Генерация уникального hex ID.
 * @param length Размер ID.
 * @returns
 */
export function generateUniqueID(length = 16): Uint8Array {
  const randomBytes = new Uint8Array(length);

  for (let i = 0; i < length; i++) {
    randomBytes[i] = Math.floor(Math.random() * 256);
  }

  return randomBytes;
}

/**
 * Генерация UUID v4.
 * @returns
 */
export function generateUUID(): string {
  const randomBytes = generateUniqueID();

  // Форматируем в виде UUID
  const formattedUuid = Array.from(randomBytes).map(byte => {
    const hex = byte.toString(16).padStart(2, "0");

    return hex;
  });

  // Устанавливаем версию и вариант для UUID v4
  formattedUuid[6] = "4" + formattedUuid[6][1];  // Устанавливаем версию 4
  const variants = ["8", "9", "a", "b"];
  const variant = parseInt(formattedUuid[8][0], 16) % 4;
  formattedUuid[8] = variants[variant] + formattedUuid[8][1];

  // Вставляем дефисы
  formattedUuid[3] += "-";
  formattedUuid[5] += "-";
  formattedUuid[7] += "-";
  formattedUuid[9] += "-";

  return formattedUuid.join("");
}

/**
 * Преобразует Uint8Array в строку Base64 без использования atob и btoa.
 * @param {Uint8Array} uint8Array - Исходный Uint8Array.
 * @returns {string} Строка Base64.
 */
export function toBase64(uint8Array: Uint8Array): string {
  const base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  let result = "";
  let padding = 0;
  const paddingChar = "=";

  for (let i = 0; i < uint8Array.length; i += 3) {
    const a = uint8Array[i];
    const b = uint8Array[i + 1];
    const c = uint8Array[i + 2];

    const index1 = a >> 2;
    const index2 = ((a & 3) << 4) | (b >> 4);
    const index3 = ((b & 15) << 2) | (c >> 6);
    const index4 = c & 63;

    result += base64Chars.charAt(index1) + base64Chars.charAt(index2) +
      base64Chars.charAt(index3) + base64Chars.charAt(index4);
  }

  if (uint8Array.length % 3 === 1) {
    padding = 2;
  } else if (uint8Array.length % 3 === 2) {
    padding = 1;
  }

  if (padding > 0) {
    result = result.slice(0, padding * -1) + paddingChar.repeat(padding);
  }

  return result;
}

/**
 * Преобразует строку Base64 в Uint8Array без использования atob и btoa.
 * @param {string} base64String - Строка Base64.
 * @returns {Uint8Array} Результирующий Uint8Array.
 */
export function fromBase64(base64String: string): Uint8Array {
  const base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  let padding = 0;

  if (base64String.endsWith("==")) {
    padding = 2;
  } else if (base64String.endsWith("=")) {
    padding = 1;
  }

  const byteLength = (base64String.length / 4) * 3 - padding;
  const uint8Array = new Uint8Array(byteLength);

  let index = 0;

  for (let i = 0; i < base64String.length; i += 4) {
    const index1 = base64Chars.indexOf(base64String[i]);
    const index2 = base64Chars.indexOf(base64String[i + 1]);
    const index3 = base64Chars.indexOf(base64String[i + 2]);
    const index4 = base64Chars.indexOf(base64String[i + 3]);

    const value1 = (index1 << 2) | (index2 >> 4);
    const value2 = ((index2 & 15) << 4) | (index3 >> 2);
    const value3 = ((index3 & 3) << 6) | index4;

    uint8Array[index++] = value1;
    if (index < byteLength) uint8Array[index++] = value2;
    if (index < byteLength) uint8Array[index++] = value3;
  }

  return uint8Array;
}


/**
 * Проверяет, содержит ли строка маркер последовательности байтов UTF-16BE.
 * @param str Строка, которую необходимо проверить.
 * @returns Результат проверки.
 */
export function hasUtf16BeBOM(str: Uint8Array): boolean {
  return str[0] === 0xfe && str[1] === 0xff;
}

/**
 * Проверяет, содержит ли строка маркер последовательности байтов UTF-8.
 * @param str Строка, которую необходимо проверить.
 * @returns Результат проверки.
 */
export function hasUtf8BOM(str: Uint8Array): boolean {
  return str[0] === 0xef && str[1] === 0xbb && str[2] === 0xbf;
}

/**
 * Переводит строку hex значений в binary данные.
 * @param hexString Hex строка, которую необходимо преобразовать.
 * @returns Полученные binary данные.
 */
export function hexToBinary(hexString: string): Uint8Array {
  const hexArr = hexString.match(/.{1,2}/g) || [];

  return Uint8Array.from(hexArr.map((byte) => parseInt(byte, 16)));
}

/**
 * Кодирует строку в UTF-16BE.
 * @param str Строка, которую необходимо закодировать.
 * @returns Закодированная строка.
 */
export function toUtf16Be(str: string): Uint8Array {
  const byteArray = new Uint8Array(str.length * 2);
  for (let i = 0; i < str.length; i++) {
    byteArray[i * 2] = str.charCodeAt(i) >> 8;
    byteArray[i * 2 + 1] = str.charCodeAt(i);
  }

  return byteArray;
}

/**
 * Приводит hex значение в строке в 2-байтный формат.
 * @param hex Hex строка, которую необходимо преобразовать.
 * @returns Преобразованная строка.
 */
export function hexTo2ByteHex(hex: string): string {
  return hex.padStart(4, "0");
}

/**
 * Приводит hex значение в строке в 1-байтный формат.
 * @param hex Hex строка, которую необходимо преобразовать.
 * @returns Преобразованная строка.
 */
export function ensure1ByteHex(hex: string): string {
  return hex.padStart(2, "0");
}

/**
 * Форматирует строку hex значений соответственно указанному количеству байт (1 или 2).
 * @param hex Строка hex значений.
 * @param as2Byte Сколько байт должно занимать hex значение. true - 2 байта, false - 1 байт.
 * @returns Преобразованная строка.
 */
export function formatHex(hex: string, as2Byte: boolean): string {
  return as2Byte ? hexTo2ByteHex(hex) : ensure1ByteHex(hex);
}

/**
 * Проверяет, есть ли в строке символы, занимающие больше 1 байта.
 * @param text Строка, которую необходимо проверить.
 * @returns Результат проверки.
 */
export function hasMoreThan1ByteChars(text: string): boolean {
  let result = false;

  for (let i = 0; i < text.length; i++) {
    const curCharCode = text.charCodeAt(i);

    if (curCharCode > 0xFF) {
      result = true;
      break;
    }
  }

  return result;
}

/**
 * Раскодирует binary кодировку.
 * @param str Строка, которую необходимо раскодировать.
 * @returns Раскодированная строка символов.
 */
export function fromBinary(str: Uint8Array): string {
  let result = "";
  str.forEach((charCode) => result += String.fromCharCode(charCode));

  return result;
}

/**
 * Кодирует binary кодировкой.
 * @param str Строка, которую необходимо кодировать.
 * @returns Закодированная строка
 */
export function toBinary(str: string): Uint8Array {
  const unescapedRaw = new Uint8Array(str.length);

  for (let i = 0; i < str.length; i++) {
    unescapedRaw[i] = str.charCodeAt(i);
  }

  return unescapedRaw;
}

// Переносы строки
const lineFeeds: {
  sequence: string,
  meaning: string,
}[] = [
    {
      sequence: "\r\n",
      meaning: "\n"
    },
    {
      sequence: "\r",
      meaning: "\n"
    },
  ];

// Символы продолжения строки на следующей
const noBreakLine: {
  sequence: string,
  meaning: string,
}[] = [
    {
      sequence: "\r\n",
      meaning: ""
    },
    {
      sequence: "\n",
      meaning: ""
    },
    {
      sequence: "\r",
      meaning: ""
    },
  ];

// Специальные символы
const specialSymbols: {
  sequence: string,
  meaning: string,
}[] = [
    // LINE FEED (0Ah) (LF)
    {
      sequence: "n",
      meaning: "\n"
    },
    // CARRIAGE RETURN (0Dh) (CR)
    {
      sequence: "r",
      meaning: "\r"
    },
    // HORIZONTAL TAB (09h) (HT)
    {
      sequence: "t",
      meaning: "\t"
    },
    // BACKSPACE (08h) (BS)
    {
      sequence: "b",
      meaning: "\b"
    },
    // FORM FEED (0Ch) (FF)
    {
      sequence: "f",
      meaning: "\f"
    },
    // LEFT PARENTHESIS (28h)
    {
      sequence: "\\(",
      meaning: "("
    },
    // RIGHT PARENTHESIS (29h)
    {
      sequence: "\\)",
      meaning: ")"
    },
  ];

// Все символы для экранирования
const allEscapeSymbols: {
  sequence: string,
  meaning: string,
}[] = [...noBreakLine, ...specialSymbols];

/**
 * Обрабатывает экранированные специальные символы.
 * @param raw Строка, которую необходимо обработать.
 * @returns Обработанная строка.
 */
export function unescapeSpecialSymbols(raw: Uint8Array): Uint8Array {
  let unescapedStr = fromBinary(raw);

  // Обрабатываем символы, представленные восьмеричными кодами
  unescapedStr = unescapedStr.replace(/\\[0-7]{1,3}/g, (match) => {
    const octalCode = match.substring(1, match.length);

    return String.fromCharCode(parseInt(octalCode, 8));
  });

  // Обрабатываем табличные символы
  allEscapeSymbols.forEach((symbol) => {
    const symbolRegExp = new RegExp(`\\\\${symbol.sequence}`, "g");
    unescapedStr = unescapedStr.replace(symbolRegExp, symbol.meaning);
  });

  // Обрабатываем символы переноса строки
  lineFeeds.forEach((symbol) => {
    unescapedStr = unescapedStr.replace(symbol.sequence, symbol.meaning);
  });

  // Обрабатываем оставшиеся обратные слэши - парные экранируем в одинарные, одинарные игнорируем
  const singleSlashRegExp = /\\+/g;
  unescapedStr = unescapedStr.replace(singleSlashRegExp, (match) => {
    const solidusPairs = Math.floor(match.length / 2);

    return "\\".repeat(solidusPairs);
  });

  return toBinary(unescapedStr);
}

const REPLACEMENTS = new Map<string, string>([
  ["\n", "\\n"],
  ["\r", "\\r"],
  ["\t", "\\t"],
  ["\b", "\\b"],
  ["\f", "\\f"],
  ["(", "\\("],
  [")", "\\)"],
  ["\\", "\\\\"],
]);

/**
 * Экранирует специальные символы.
 * @param str Строка, которую необходимо экранировать.
 * @returns Экранированная строка.
 */
export function escapeSpecialSymbols(text: string): string {
  // eslint-disable-next-line no-control-regex
  return text.replace(/[\n\r\t\f\x08\\()]/gm, char => REPLACEMENTS.get(char) || char);
}

/**
 * Раскодирует строку с указанной кодировкой.
 * @param str Закодированная строка.
 * @param encoding Кодировка строки.
 * @returns Раскодированная строка символов.
 */
export function decodeString(str: Uint8Array, encoding: Encoding): string {
  let decodedStr = "";

  if (encoding !== Encoding.Binary) {
    const decoder = new TextDecoder(encoding);
    decodedStr = decoder.decode(str);
  } else {
    decodedStr = fromBinary(str);
  }

  return decodedStr;
}

export function isEqualRaw(array1: Uint8Array, array2: Uint8Array): boolean {
  if (array1 === array2) {
    return true;
  }

  if (array1.length !== array2.length) {
    return false;
  }

  for (let i = 0; i < array1.length; i++) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }

  return true;
}
