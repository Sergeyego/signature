/*!
 *                                  Apache License
 *                            Version 2.0, January 2004
 *                         http://www.apache.org/licenses/
 * 
 *    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 * 
 *    1. Definitions.
 * 
 *       "License" shall mean the terms and conditions for use, reproduction,
 *       and distribution as defined by Sections 1 through 9 of this document.
 * 
 *       "Licensor" shall mean the copyright owner or entity authorized by
 *       the copyright owner that is granting the License.
 * 
 *       "Legal Entity" shall mean the union of the acting entity and all
 *       other entities that control, are controlled by, or are under common
 *       control with that entity. For the purposes of this definition,
 *       "control" means (i) the power, direct or indirect, to cause the
 *       direction or management of such entity, whether by contract or
 *       otherwise, or (ii) ownership of fifty percent (50%) or more of the
 *       outstanding shares, or (iii) beneficial ownership of such entity.
 * 
 *       "You" (or "Your") shall mean an individual or Legal Entity
 *       exercising permissions granted by this License.
 * 
 *       "Source" form shall mean the preferred form for making modifications,
 *       including but not limited to software source code, documentation
 *       source, and configuration files.
 * 
 *       "Object" form shall mean any form resulting from mechanical
 *       transformation or translation of a Source form, including but
 *       not limited to compiled object code, generated documentation,
 *       and conversions to other media types.
 * 
 *       "Work" shall mean the work of authorship, whether in Source or
 *       Object form, made available under the License, as indicated by a
 *       copyright notice that is included in or attached to the work
 *       (an example is provided in the Appendix below).
 * 
 *       "Derivative Works" shall mean any work, whether in Source or Object
 *       form, that is based on (or derived from) the Work and for which the
 *       editorial revisions, annotations, elaborations, or other modifications
 *       represent, as a whole, an original work of authorship. For the purposes
 *       of this License, Derivative Works shall not include works that remain
 *       separable from, or merely link (or bind by name) to the interfaces of,
 *       the Work and Derivative Works thereof.
 * 
 *       "Contribution" shall mean any work of authorship, including
 *       the original version of the Work and any modifications or additions
 *       to that Work or Derivative Works thereof, that is intentionally
 *       submitted to Licensor for inclusion in the Work by the copyright owner
 *       or by an individual or Legal Entity authorized to submit on behalf of
 *       the copyright owner. For the purposes of this definition, "submitted"
 *       means any form of electronic, verbal, or written communication sent
 *       to the Licensor or its representatives, including but not limited to
 *       communication on electronic mailing lists, source code control systems,
 *       and issue tracking systems that are managed by, or on behalf of, the
 *       Licensor for the purpose of discussing and improving the Work, but
 *       excluding communication that is conspicuously marked or otherwise
 *       designated in writing by the copyright owner as "Not a Contribution."
 * 
 *       "Contributor" shall mean Licensor and any individual or Legal Entity
 *       on behalf of whom a Contribution has been received by Licensor and
 *       subsequently incorporated within the Work.
 * 
 *    2. Grant of Copyright License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       copyright license to reproduce, prepare Derivative Works of,
 *       publicly display, publicly perform, sublicense, and distribute the
 *       Work and such Derivative Works in Source or Object form.
 * 
 *    3. Grant of Patent License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       (except as stated in this section) patent license to make, have made,
 *       use, offer to sell, sell, import, and otherwise transfer the Work,
 *       where such license applies only to those patent claims licensable
 *       by such Contributor that are necessarily infringed by their
 *       Contribution(s) alone or by combination of their Contribution(s)
 *       with the Work to which such Contribution(s) was submitted. If You
 *       institute patent litigation against any entity (including a
 *       cross-claim or counterclaim in a lawsuit) alleging that the Work
 *       or a Contribution incorporated within the Work constitutes direct
 *       or contributory patent infringement, then any patent licenses
 *       granted to You under this License for that Work shall terminate
 *       as of the date such litigation is filed.
 * 
 *    4. Redistribution. You may reproduce and distribute copies of the
 *       Work or Derivative Works thereof in any medium, with or without
 *       modifications, and in Source or Object form, provided that You
 *       meet the following conditions:
 * 
 *       (a) You must give any other recipients of the Work or
 *           Derivative Works a copy of this License; and
 * 
 *       (b) You must cause any modified files to carry prominent notices
 *           stating that You changed the files; and
 * 
 *       (c) You must retain, in the Source form of any Derivative Works
 *           that You distribute, all copyright, patent, trademark, and
 *           attribution notices from the Source form of the Work,
 *           excluding those notices that do not pertain to any part of
 *           the Derivative Works; and
 * 
 *       (d) If the Work includes a "NOTICE" text file as part of its
 *           distribution, then any Derivative Works that You distribute must
 *           include a readable copy of the attribution notices contained
 *           within such NOTICE file, excluding those notices that do not
 *           pertain to any part of the Derivative Works, in at least one
 *           of the following places: within a NOTICE text file distributed
 *           as part of the Derivative Works; within the Source form or
 *           documentation, if provided along with the Derivative Works; or,
 *           within a display generated by the Derivative Works, if and
 *           wherever such third-party notices normally appear. The contents
 *           of the NOTICE file are for informational purposes only and
 *           do not modify the License. You may add Your own attribution
 *           notices within Derivative Works that You distribute, alongside
 *           or as an addendum to the NOTICE text from the Work, provided
 *           that such additional attribution notices cannot be construed
 *           as modifying the License.
 * 
 *       You may add Your own copyright statement to Your modifications and
 *       may provide additional or different license terms and conditions
 *       for use, reproduction, or distribution of Your modifications, or
 *       for any such Derivative Works as a whole, provided Your use,
 *       reproduction, and distribution of the Work otherwise complies with
 *       the conditions stated in this License.
 * 
 *    5. Submission of Contributions. Unless You explicitly state otherwise,
 *       any Contribution intentionally submitted for inclusion in the Work
 *       by You to the Licensor shall be under the terms and conditions of
 *       this License, without any additional terms or conditions.
 *       Notwithstanding the above, nothing herein shall supersede or modify
 *       the terms of any separate license agreement you may have executed
 *       with Licensor regarding such Contributions.
 * 
 *    6. Trademarks. This License does not grant permission to use the trade
 *       names, trademarks, service marks, or product names of the Licensor,
 *       except as required for reasonable and customary use in describing the
 *       origin of the Work and reproducing the content of the NOTICE file.
 * 
 *    7. Disclaimer of Warranty. Unless required by applicable law or
 *       agreed to in writing, Licensor provides the Work (and each
 *       Contributor provides its Contributions) on an "AS IS" BASIS,
 *       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 *       implied, including, without limitation, any warranties or conditions
 *       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
 *       PARTICULAR PURPOSE. You are solely responsible for determining the
 *       appropriateness of using or redistributing the Work and assume any
 *       risks associated with Your exercise of permissions under this License.
 * 
 *    8. Limitation of Liability. In no event and under no legal theory,
 *       whether in tort (including negligence), contract, or otherwise,
 *       unless required by applicable law (such as deliberate and grossly
 *       negligent acts) or agreed to in writing, shall any Contributor be
 *       liable to You for damages, including any direct, indirect, special,
 *       incidental, or consequential damages of any character arising as a
 *       result of this License or out of the use or inability to use the
 *       Work (including but not limited to damages for loss of goodwill,
 *       work stoppage, computer failure or malfunction, or any and all
 *       other commercial damages or losses), even if such Contributor
 *       has been advised of the possibility of such damages.
 * 
 *    9. Accepting Warranty or Additional Liability. While redistributing
 *       the Work or Derivative Works thereof, You may choose to offer,
 *       and charge a fee for, acceptance of support, warranty, indemnity,
 *       or other liability obligations and/or rights consistent with this
 *       License. However, in accepting such obligations, You may act only
 *       on Your own behalf and on Your sole responsibility, not on behalf
 *       of any other Contributor, and only if You agree to indemnify,
 *       defend, and hold each Contributor harmless for any liability
 *       incurred by, or claims asserted against, such Contributor by reason
 *       of your accepting any such warranty or additional liability.
 * 
 *    END OF TERMS AND CONDITIONS
 * 
 *    APPENDIX: How to apply the Apache License to your work.
 * 
 *       To apply the Apache License to your work, attach the following
 *       boilerplate notice, with the fields enclosed by brackets "[]"
 *       replaced with your own identifying information. (Don't include
 *       the brackets!)  The text should be enclosed in the appropriate
 *       comment syntax for the file format. We also recommend that a
 *       file or class name and description of purpose be included on the
 *       same "printed page" as the copyright notice for easier
 *       identification within third-party archives.
 * 
 *    Copyright 2024 DIGITAL TECHNOLOGY LLC
 * 
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 * 
 *        http://www.apache.org/licenses/LICENSE-2.0
 * 
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 * 
 */
import { __classPrivateFieldGet, __classPrivateFieldSet } from 'tslib';
import * as pako from 'pako';
import pngLib from '@pdf-lib/upng';
import * as fontkit from '@pdf-lib/fontkit';

var RegistryTypes;
(function (RegistryTypes) {
    RegistryTypes[RegistryTypes["PdfView"] = 0] = "PdfView";
    RegistryTypes[RegistryTypes["ObjectStream"] = 1] = "ObjectStream";
    RegistryTypes[RegistryTypes["Writer"] = 2] = "Writer";
    RegistryTypes[RegistryTypes["PdfIndirectObject"] = 3] = "PdfIndirectObject";
    RegistryTypes[RegistryTypes["Parser"] = 4] = "Parser";
    RegistryTypes[RegistryTypes["Copier"] = 5] = "Copier";
    RegistryTypes[RegistryTypes["PdfDictionary"] = 6] = "PdfDictionary";
    RegistryTypes[RegistryTypes["PdfArray"] = 7] = "PdfArray";
})(RegistryTypes || (RegistryTypes = {}));
class Registry {
    static get(key) {
        return this.items[key];
    }
    static set(key, value) {
        this.items[key] = value;
    }
}
Registry.items = {};

var _PdfBuffer_stream, _PdfBuffer_lines, _PdfBuffer_streamLength;
class PdfBuffer {
    get length() {
        return this.raw.length + __classPrivateFieldGet(this, _PdfBuffer_streamLength, "f");
    }
    constructor(raw = new Uint8Array()) {
        this.raw = raw;
        _PdfBuffer_stream.set(this, false);
        _PdfBuffer_lines.set(this, []);
        _PdfBuffer_streamLength.set(this, 0);
    }
    begin() {
        __classPrivateFieldSet(this, _PdfBuffer_stream, true, "f");
        return this;
    }
    end(endLine) {
        __classPrivateFieldSet(this, _PdfBuffer_stream, false, "f");
        __classPrivateFieldSet(this, _PdfBuffer_streamLength, 0, "f");
        if (!__classPrivateFieldGet(this, _PdfBuffer_lines, "f").length) {
            return this;
        }
        if (endLine) {
            this.append(__classPrivateFieldGet(this, _PdfBuffer_lines, "f"), endLine);
        }
        else {
            this.append(__classPrivateFieldGet(this, _PdfBuffer_lines, "f"));
        }
        __classPrivateFieldSet(this, _PdfBuffer_lines, [], "f");
        return this;
    }
    append(raw, endLine) {
        const objs = [];
        if (!Array.isArray(raw)) {
            if (raw instanceof PdfBuffer) {
                objs.push(raw.raw);
            }
            else {
                objs.push(raw);
            }
        }
        else {
            for (const r of raw) {
                if (r instanceof PdfBuffer) {
                    objs.push(r.raw);
                }
                else {
                    objs.push(r);
                }
            }
        }
        if (!objs.length) {
            return this;
        }
        if (__classPrivateFieldGet(this, _PdfBuffer_stream, "f")) {
            for (let index = 0; index < objs.length; index++) {
                const obj = objs[index];
                __classPrivateFieldSet(this, _PdfBuffer_streamLength, __classPrivateFieldGet(this, _PdfBuffer_streamLength, "f") + obj.length, "f");
                __classPrivateFieldGet(this, _PdfBuffer_lines, "f").push(obj);
                if (index !== objs.length - 1 && endLine) {
                    __classPrivateFieldSet(this, _PdfBuffer_streamLength, __classPrivateFieldGet(this, _PdfBuffer_streamLength, "f") + endLine.length, "f");
                    __classPrivateFieldGet(this, _PdfBuffer_lines, "f").push(endLine);
                }
            }
            return this;
        }
        this.raw = this.addData(objs, endLine);
        return this;
    }
    addData(objs, endLine) {
        let size = this.length;
        const endLineLength = endLine ? endLine.length : 0;
        for (let index = 0; index < objs.length; index++) {
            size += objs[index].length;
            if (index !== objs.length - 1 && endLine) {
                size += endLineLength;
            }
        }
        const res = new Uint8Array(size);
        res.set(this.raw);
        let offset = this.length;
        for (let index = 0; index < objs.length; index++) {
            const obj = objs[index];
            res.set(obj, offset);
            offset += obj.length;
            if (index !== objs.length - 1 && endLine) {
                res.set(endLine, offset);
                offset += endLineLength;
            }
        }
        return res;
    }
    subarray(begin = 0, end) {
        const view = Registry.get(RegistryTypes.PdfView);
        return new view(this, begin, end);
    }
    static numberToTextRaw(value, length = 0) {
        return this.stringToRaw(value.toString().padStart(length, "0"));
    }
    static stringToRaw(text) {
        const s = unescape(encodeURIComponent(text));
        const uintArray = new Uint8Array(s.length);
        for (let i = 0; i < s.length; i++) {
            uintArray[i] = s.charCodeAt(i);
        }
        return uintArray;
    }
    static numberToRaw(num, length) {
        if (length === undefined) {
            length = Math.max(1, Math.ceil(Math.log2(num + 1) / 8));
        }
        const bytes = new Uint8Array(length);
        for (let i = length - 1; i >= 0; i--) {
            bytes[i] = num & 0xff;
            num >>= 8;
        }
        return bytes;
    }
}
_PdfBuffer_stream = new WeakMap(), _PdfBuffer_lines = new WeakMap(), _PdfBuffer_streamLength = new WeakMap();

class PdfView {
    constructor(buffer = new PdfBuffer(), offset = 0, offsetEnd) {
        this.buffer = buffer;
        this.offset = offset;
        const view = this.buffer.raw.subarray(this.offset, offsetEnd);
        this.length = view.length;
        if (!view.length && offsetEnd && this.offset !== offsetEnd) {
            this.length = offsetEnd - this.offset;
        }
    }
    getRaw() {
        return this.buffer.raw.subarray(this.offset, this.offset + this.length);
    }
    toString() {
        const buf = this.getRaw();
        let res = "";
        for (let i = 0; i < buf.length; i++) {
            res += String.fromCharCode(buf[i]);
        }
        return res;
    }
}

class RawData {
    constructor() {
        this.raw = RawData.EMPTY_VIEW;
    }
    isEmptyRaw() {
        return !this.raw.length;
    }
}
RawData.EMPTY_VIEW = new PdfView();

var _PdfObject_xref;
class PdfObject extends RawData {
    constructor(param = {}) {
        var _a;
        super();
        _PdfObject_xref.set(this, void 0);
        this.padding = (_a = param.padding) !== null && _a !== void 0 ? _a : 0;
    }
    get doc() {
        return this.xref.doc;
    }
    get xref() {
        if (!__classPrivateFieldGet(this, _PdfObject_xref, "f")) {
            throw new Error("XRef пустой");
        }
        return __classPrivateFieldGet(this, _PdfObject_xref, "f");
    }
    set xref(v) {
        __classPrivateFieldSet(this, _PdfObject_xref, v, "f");
    }
    ref(type) {
        if (!this.parent) {
            this.parent = this.xref.doc.createIndirectObject(this, type);
        }
        return this;
    }
    change() {
        this.onChange();
        let parent = this.parent;
        while (parent && !(parent instanceof Registry.get(RegistryTypes.PdfIndirectObject))) {
            parent = parent.parent;
        }
        if (!parent || this === parent) {
            return;
        }
        parent.change();
    }
    onChange() {
    }
    static create(xref) {
        const obj = new this();
        obj.xref = xref;
        obj.onCreate();
        return obj;
    }
    onCreate() {
    }
    reWriteRaw(v) {
        if (!this.raw.length) {
            throw new Error("Нет RAW");
        }
        const WriterClass = Registry.get(RegistryTypes.Writer);
        const writer = new WriterClass(this.doc);
        const newRaw = writer.write(this.doc.buffer, v, true, false);
        if (newRaw.length > this.raw.length) {
            throw new Error(`reWriteRaw(): Указанная длинна '${this.raw.length}' меньше чем длинна значения '${newRaw.length}'`);
        }
        this.onSetValue(v);
        this.raw.getRaw().set(newRaw);
    }
    onSetValue(_v) {
        throw new Error("метод не реализован");
    }
    convert(type) {
        if (this.constructor === type || this instanceof type) {
            return this;
        }
        const res = new type();
        if (!(res instanceof this.constructor)) {
            throw new Error(`Ошибка преобразования '${this.constructor.name}' в '${type.name}'.`);
        }
        res.raw = this.raw;
        res.parent = this.parent;
        res.xref = this.xref;
        this.onConvert(res);
        return res;
    }
    onConvert(_obj) {
    }
}
_PdfObject_xref = new WeakMap();

var _PdfComment_value;
class PdfComment extends PdfObject {
    constructor(param = {}) {
        super(param);
        _PdfComment_value.set(this, "");
        if (param.value) {
            this.value = param.value;
        }
    }
    get value() {
        return __classPrivateFieldGet(this, _PdfComment_value, "f");
    }
    set value(v) {
        if (v !== this.value) {
            this.change();
            __classPrivateFieldSet(this, _PdfComment_value, v, "f");
        }
    }
}
_PdfComment_value = new WeakMap();

var _PdfBoolean_value;
class PdfBoolean extends PdfObject {
    constructor(param = {}) {
        var _a;
        super(param);
        _PdfBoolean_value.set(this, void 0);
        __classPrivateFieldSet(this, _PdfBoolean_value, (_a = param.value) !== null && _a !== void 0 ? _a : false, "f");
    }
    get value() {
        return __classPrivateFieldGet(this, _PdfBoolean_value, "f");
    }
    set value(v) {
        if (v !== __classPrivateFieldGet(this, _PdfBoolean_value, "f")) {
            this.change();
            __classPrivateFieldSet(this, _PdfBoolean_value, v, "f");
        }
    }
}
_PdfBoolean_value = new WeakMap();

var _PdfName_value;
class PdfName extends PdfObject {
    constructor(param = {}) {
        var _a;
        super(param);
        _PdfName_value.set(this, void 0);
        __classPrivateFieldSet(this, _PdfName_value, (_a = param.value) !== null && _a !== void 0 ? _a : "", "f");
    }
    get value() {
        return __classPrivateFieldGet(this, _PdfName_value, "f");
    }
    set value(v) {
        if (v !== __classPrivateFieldGet(this, _PdfName_value, "f")) {
            this.change();
            __classPrivateFieldSet(this, _PdfName_value, v, "f");
        }
    }
}
_PdfName_value = new WeakMap();

var _PdfNumber_value;
class PdfNumber extends PdfObject {
    constructor(param = {}) {
        var _a;
        super(param);
        _PdfNumber_value.set(this, void 0);
        __classPrivateFieldSet(this, _PdfNumber_value, (_a = param.value) !== null && _a !== void 0 ? _a : 0, "f");
    }
    get value() {
        return __classPrivateFieldGet(this, _PdfNumber_value, "f");
    }
    set value(v) {
        if (v !== __classPrivateFieldGet(this, _PdfNumber_value, "f")) {
            this.change();
            __classPrivateFieldSet(this, _PdfNumber_value, v, "f");
        }
    }
    onConvert(obj) {
        if (!(obj instanceof PdfNumber)) {
            throw new Error(`Ошибка преобразования PdfNumber в '${obj.constructor.name}'.`);
        }
        obj.value = this.value;
    }
    onSetValue(v) {
        __classPrivateFieldSet(this, _PdfNumber_value, __classPrivateFieldGet(v, _PdfNumber_value, "f"), "f");
    }
    reWriteValue(v) {
        this.reWriteRaw(this.doc.createNumber(v));
    }
}
_PdfNumber_value = new WeakMap();

class PdfNull extends PdfObject {
    constructor(param = {}) {
        super(param);
    }
    get value() {
        return null;
    }
}

var _PdfString_value;
class PdfString extends PdfObject {
    constructor(param = {}) {
        var _a;
        super(param);
        _PdfString_value.set(this, void 0);
        __classPrivateFieldSet(this, _PdfString_value, (_a = param.value) !== null && _a !== void 0 ? _a : "", "f");
    }
    get value() {
        return __classPrivateFieldGet(this, _PdfString_value, "f");
    }
    set value(v) {
        if (v !== __classPrivateFieldGet(this, _PdfString_value, "f")) {
            this.change();
            __classPrivateFieldSet(this, _PdfString_value, v, "f");
        }
    }
    onSetValue(v) {
        __classPrivateFieldSet(this, _PdfString_value, __classPrivateFieldGet(v, _PdfString_value, "f"), "f");
    }
    toBinary() {
        return Buffer.from(this.value, "binary");
    }
}
_PdfString_value = new WeakMap();

class PdfHexString extends PdfString {
    reWriteValue(v) {
        this.reWriteRaw(this.doc.createHexString(v));
    }
}

class PdfLiteralString extends PdfString {
    reWriteValue(v) {
        this.reWriteRaw(this.doc.createLiteral(v));
    }
}

var Names;
(function (Names) {
    Names["AP"] = "AP";
    Names["ASCII85Decode"] = "ASCII85Decode";
    Names["ASCIIHexDecode"] = "ASCIIHexDecode";
    Names["AcroForm"] = "AcroForm";
    Names["AdbePkcs7Detached"] = "adbe.pkcs7.detached";
    Names["Adobe"] = "Adobe";
    Names["AdobePPKLite"] = "Adobe.PPKLite";
    Names["Annot"] = "Annot";
    Names["Annots"] = "Annots";
    Names["BaseFont"] = "BaseFont";
    Names["BBox"] = "BBox";
    Names["BitsPerComponent"] = "BitsPerComponent";
    Names["ByteRange"] = "ByteRange";
    Names["Catalog"] = "Catalog";
    Names["CIDFontType0"] = "CIDFontType0";
    Names["CIDFontType2"] = "CIDFontType2";
    Names["ColorSpace"] = "ColorSpace";
    Names["Contents"] = "Contents";
    Names["Count"] = "Count";
    Names["DCTDecode"] = "DCTDecode";
    Names["DecodeParms"] = "DecodeParms";
    Names["DeviceGray"] = "DeviceGray";
    Names["Encrypt"] = "Encrypt";
    Names["EtsiCadesDetached"] = "ETSI.CAdES.detached";
    Names["F"] = "F";
    Names["FT"] = "FT";
    Names["Fields"] = "Fields";
    Names["Filter"] = "Filter";
    Names["First"] = "First";
    Names["FlateDecode"] = "FlateDecode";
    Names["FontDescriptor"] = "FontDescriptor";
    Names["Font"] = "Font";
    Names["Form"] = "Form";
    Names["FormType"] = "FormType";
    Names["FontFile2"] = "FontFile2";
    Names["FontFile3"] = "FontFile3";
    Names["Height"] = "Height";
    Names["ID"] = "ID";
    Names["Identity"] = "Identity";
    Names["IdentityH"] = "Identity-H";
    Names["Image"] = "Image";
    Names["Info"] = "Info";
    Names["Kids"] = "Kids";
    Names["LZWDecode"] = "LZWDecode";
    Names["Length"] = "Length";
    Names["Metadata"] = "Metadata";
    Names["N"] = "N";
    Names["ObjStm"] = "ObjStm";
    Names["OutputIntents"] = "OutputIntents";
    Names["P"] = "P";
    Names["Page"] = "Page";
    Names["Pages"] = "Pages";
    Names["Perms"] = "Perms";
    Names["Prev"] = "Prev";
    Names["Rect"] = "Rect";
    Names["Resources"] = "Resources";
    Names["Root"] = "Root";
    Names["RunLengthDecode"] = "RunLengthDecode";
    Names["Sig"] = "Sig";
    Names["SigFlags"] = "SigFlags";
    Names["Size"] = "Size";
    Names["SubFilter"] = "SubFilter";
    Names["Subtype"] = "Subtype";
    Names["T"] = "T";
    Names["TrueType"] = "TrueType";
    Names["TrustedParams"] = "TrustedParams";
    Names["Type"] = "Type";
    Names["Type0"] = "Type0";
    Names["Type1"] = "Type1";
    Names["V"] = "V";
    Names["W"] = "W";
    Names["Widget"] = "Widget";
    Names["Width"] = "Width";
    Names["XObject"] = "XObject";
    Names["XRef"] = "XRef";
    Names["Encoding"] = "Encoding";
    Names["DescendantFonts"] = "DescendantFonts";
    Names["ToUnicode"] = "ToUnicode";
    Names["CIDToGIDMap"] = "CIDToGIDMap";
    Names["CIDSystemInfo"] = "CIDSystemInfo";
    Names["FontName"] = "FontName";
    Names["Flags"] = "Flags";
    Names["FontBBox"] = "FontBBox";
    Names["ItalicAngle"] = "ItalicAngle";
    Names["Ascent"] = "Ascent";
    Names["StemV"] = "StemV";
    Names["Descent"] = "Descent";
    Names["XHeight"] = "XHeight";
    Names["CapHeight"] = "CapHeight";
    Names["Square"] = "Square";
    Names["OCProperties"] = "OCProperties";
    Names["D"] = "D";
    Names["Configs"] = "Configs";
    Names["Name"] = "Name";
    Names["CIDSet"] = "CIDSet";
    Names["FontFile"] = "FontFile";
    Names["Parent"] = "Parent";
    Names["Link"] = "Link";
    Names["Interpolate"] = "Interpolate";
    Names["ExtGState"] = "ExtGState";
    Names["TR2"] = "TR2";
    Names["TR"] = "TR";
    Names["A"] = "A";
    Names["AA"] = "AA";
    Names["DeviceRGB"] = "DeviceRGB";
    Names["DeviceCMYK"] = "DeviceCMYK";
    Names["DestOutputProfile"] = "DestOutputProfile";
    Names["NeedAppearances"] = "NeedAppearances";
    Names["AS"] = "AS";
    Names["Order"] = "Order";
    Names["OCGs"] = "OCGs";
    Names["Names"] = "Names";
    Names["Type3"] = "Type3";
    Names["Widths"] = "Widths";
    Names["Normal"] = "Normal";
    Names["WinAnsiEncoding"] = "WinAnsiEncoding";
    Names["MacRomanEncoding"] = "MacRomanEncoding";
    Names["MissingWidth"] = "MissingWidth";
    Names["FirstChar"] = "FirstChar";
    Names["Differences"] = "Differences";
    Names["Outlines"] = "Outlines";
})(Names || (Names = {}));

class Predictor {
    static decode(data, params) {
        var _a, _b, _c, _d, _e;
        let res = data;
        const predictor = ((_a = params.find("Predictor", PdfNumber)) === null || _a === void 0 ? void 0 : _a.value) || 1;
        if (predictor <= 1) {
            return res;
        }
        if (predictor !== 2 && (predictor < 10 || predictor > 15)) {
            throw new Error(`Неподдерживаемый Predictor: ${predictor}`);
        }
        const colors = ((_b = params.find("Colors", PdfNumber)) === null || _b === void 0 ? void 0 : _b.value) || 1;
        const bits = ((_c = params.find("BPC", PdfNumber)) === null || _c === void 0 ? void 0 : _c.value) || ((_d = params.find(Names.BitsPerComponent, PdfNumber)) === null || _d === void 0 ? void 0 : _d.value) || 8;
        const columns = ((_e = params.find("Columns", PdfNumber)) === null || _e === void 0 ? void 0 : _e.value) || 1;
        const pixBytes = (colors * bits + 7) >> 3;
        const rowBytes = (columns * colors * bits + 7) >> 3;
        if (predictor === 2) {
            res = this.decodeTiff(data, pixBytes, rowBytes);
        }
        else {
            res = this.decodePNG(data, pixBytes, rowBytes);
        }
        return res;
    }
    static decodeTiff(data, pixBytes, rowBytes) {
        const streamLength = data.length;
        const result = new Uint8Array(streamLength);
        let resultIndex = 0;
        let dataIndex = 0;
        while (dataIndex < streamLength) {
            for (let i = 0; i < pixBytes; i++) {
                result[resultIndex] = data[dataIndex];
                resultIndex++;
                dataIndex++;
            }
            for (let i = pixBytes; i < rowBytes; i++) {
                result[resultIndex] = (data[dataIndex] + result[resultIndex - pixBytes]) & 0xFF;
                resultIndex++;
                dataIndex++;
            }
            dataIndex += Math.max(0, rowBytes - pixBytes);
        }
        return result;
    }
    static decodePNG(data, pixBytes, rowBytes) {
        const streamLength = data.length;
        const result = new Uint8Array(streamLength);
        const row = new Uint8Array(rowBytes);
        let resultIndex = 0;
        let dataIndex = 0;
        while (dataIndex < streamLength) {
            const type = data[dataIndex++];
            row.set(data.subarray(dataIndex, dataIndex + rowBytes));
            dataIndex += rowBytes;
            switch (type) {
                case 0:
                    result.set(row, resultIndex);
                    resultIndex += rowBytes;
                    break;
                case 1:
                    for (let i = 0; i < pixBytes; i++) {
                        result[resultIndex++] = row[i];
                    }
                    for (let i = pixBytes; i < rowBytes; i++) {
                        result[resultIndex] = (row[i] + result[resultIndex - pixBytes]) & 0xFF;
                        resultIndex++;
                    }
                    break;
                case 2:
                    for (let i = 0; i < rowBytes; i++) {
                        result[resultIndex] = (row[i] + (result[resultIndex - rowBytes] || 0)) & 0xFF;
                        resultIndex++;
                    }
                    break;
                case 3:
                    for (let i = 0; i < pixBytes; ++i) {
                        result[resultIndex++] = ((result[resultIndex - rowBytes] || 0) >> 1) + row[i];
                    }
                    for (let i = pixBytes; i < rowBytes; ++i) {
                        result[resultIndex] = (((result[resultIndex - rowBytes] || 0) + (result[resultIndex - pixBytes] || 0) >> 1) + row[i]) & 0xFF;
                        resultIndex++;
                    }
                    break;
                case 4:
                    for (let i = 0; i < pixBytes; ++i) {
                        result[resultIndex++] = ((result[resultIndex - rowBytes] || 0) + row[i]) & 0xFF;
                    }
                    for (let i = pixBytes; i < rowBytes; ++i) {
                        const a = (result[resultIndex - pixBytes] || 0);
                        const b = (result[resultIndex - rowBytes] || 0);
                        const c = (result[resultIndex - rowBytes - pixBytes] || 0);
                        const p = a + b - c;
                        let pa = p - a;
                        if (pa < 0)
                            pa = -pa;
                        let pb = p - b;
                        if (pb < 0)
                            pb = -pb;
                        let pc = p - c;
                        if (pc < 0)
                            pc = -pc;
                        if (pa <= pb && pa <= pc) {
                            result[resultIndex] = (a + row[i]) & 0xFF;
                        }
                        else if (pb <= pc) {
                            result[resultIndex] = (b + row[i]) & 0xFF;
                        }
                        else {
                            result[resultIndex] = (c + row[i]) & 0xFF;
                        }
                    }
                    break;
                default:
                    throw new Error(`Неподдерживаемый тип predictor: ${type}`);
            }
        }
        return result;
    }
    static encode(data, params) {
        var _a, _b, _c, _d, _e;
        const predictor = ((_a = params.find("Predictor", PdfNumber)) === null || _a === void 0 ? void 0 : _a.value) || 1;
        if (predictor <= 1) {
            return data;
        }
        const colors = ((_b = params.find("Colors", PdfNumber)) === null || _b === void 0 ? void 0 : _b.value) || 1;
        const bits = ((_c = params.find("BPC", PdfNumber)) === null || _c === void 0 ? void 0 : _c.value) || ((_d = params.find(Names.BitsPerComponent, PdfNumber)) === null || _d === void 0 ? void 0 : _d.value) || 8;
        const columns = ((_e = params.find("Columns", PdfNumber)) === null || _e === void 0 ? void 0 : _e.value) || 1;
        const pixBytes = (colors * bits + 7) >> 3;
        const rowBytes = (columns * colors * bits + 7) >> 3;
        let encodedData;
        if (predictor === 2) {
            encodedData = this.encodeTiff(data, pixBytes, rowBytes);
        }
        else {
            throw new Error("метод encodePNG не реализован");
        }
        return encodedData;
    }
    static encodeTiff(data, pixBytes, rowBytes) {
        const streamLength = data.length;
        const result = new Uint8Array(streamLength);
        let resultIndex = 0;
        let dataIndex = 0;
        while (dataIndex < streamLength) {
            for (let i = 0; i < pixBytes; i++) {
                result[resultIndex] = data[dataIndex];
                resultIndex++;
                dataIndex++;
            }
            for (let i = pixBytes; i < rowBytes; i++) {
                result[resultIndex] = (data[dataIndex] - data[dataIndex - pixBytes]) & 0xFF;
                resultIndex++;
                dataIndex++;
            }
            dataIndex += Math.max(0, rowBytes - pixBytes);
        }
        return result;
    }
}

class FlateDecode {
    constructor() {
        this.name = Names.FlateDecode;
    }
    encode(data, params = null) {
        let deflatedData;
        try {
            deflatedData = pako.deflate(data);
        }
        catch (e) {
            throw new Error("FlateDecode.encode(): ошибка pako.deflate()");
        }
        if (params) {
            deflatedData = Predictor.encode(deflatedData, params);
        }
        return deflatedData;
    }
    decode(data, params = null) {
        let inflatedData;
        try {
            inflatedData = pako.inflate(data);
        }
        catch (e) {
            throw new Error("FlateDecode.decode(): ошибка pako.inflate(), вероятно некорректный набор байт");
        }
        if (params) {
            inflatedData = Predictor.decode(inflatedData, params);
        }
        return inflatedData;
    }
}

const base = 85;
const groupedZeroesChar = "z";
const ascii85CodesStart = 33;
class ASCII85Decode {
    constructor() {
        this.name = Names.ASCII85Decode;
    }
    encode(data) {
        const pows = [base ** 4, base ** 3, base ** 2, base ** 1, base ** 0];
        let result = "";
        let buffer = 0;
        for (let i = 0; i < data.length; i++) {
            buffer = (buffer << 8 >>> 0) + data[i];
            if ((i + 1) % 4 === 0) {
                if (buffer === 0) {
                    result += groupedZeroesChar;
                }
                else {
                    for (let j = 0; j <= pows.length - 1; j++) {
                        const code = Math.floor(buffer / pows[j]) % base + ascii85CodesStart;
                        result += String.fromCharCode(code);
                    }
                }
                buffer = 0;
            }
        }
        const remainingBytes = data.length % 4;
        if (remainingBytes !== 0) {
            const pow = 4 - (data.length % 4);
            buffer = buffer << (8 * pow) >>> 0;
            for (let j = 0; j <= pows.length - 1; j++) {
                const code = Math.floor(buffer / pows[j]) % base + ascii85CodesStart;
                result += String.fromCharCode(code);
            }
            result = result.slice(0, result.length - pow);
        }
        result += "~>";
        return PdfBuffer.stringToRaw(result);
    }
    decode(data) {
        const output = [];
        const decoder = new TextDecoder();
        let input = decoder.decode(data);
        const endMarkPosition = input.search("~>");
        if (endMarkPosition !== -1) {
            input = input.slice(0, endMarkPosition);
        }
        let symbolsCount = 0;
        let buffer = 0;
        for (let i = 0, len = input.length; i < len; i++) {
            const c = input.charCodeAt(i);
            if (c === groupedZeroesChar.charCodeAt(0)) {
                output.push(0, 0, 0, 0);
                continue;
            }
            if (c === 32 || (c >= 9 && c <= 13)) {
                continue;
            }
            if (c < ascii85CodesStart || c > 117) {
                throw new Error("Недопустимый в ASCII85 символ.");
            }
            buffer *= base;
            buffer += c - ascii85CodesStart;
            symbolsCount++;
            if (symbolsCount % 5) {
                continue;
            }
            output.push((buffer >>> 24) & 0xff, (buffer >>> 16) & 0xff, (buffer >>> 8) & 0xff, buffer & 0xff);
            buffer = 0;
            symbolsCount = 0;
        }
        if (symbolsCount) {
            const padding = 5 - symbolsCount;
            input = input + "u".repeat(padding);
            for (let i = 0; i < padding; i++) {
                buffer *= base;
                buffer += base - 1;
            }
            for (let i = 3, len = padding - 1; i > len; i--) {
                output.push((buffer >>> (i * 8)) & 0xFF);
            }
        }
        return new Uint8Array(output);
    }
}

class ASCIIHexDecode {
    constructor() {
        this.name = Names.ASCIIHexDecode;
    }
    encode(data) {
        let result = "";
        for (let i = 0; i < data.length; i++) {
            const byte = data[i];
            const hex = byte.toString(16).toUpperCase();
            result += hex.length === 1 ? `0${hex}` : hex;
        }
        result += ">";
        return PdfBuffer.stringToRaw(result);
    }
    decode(data) {
        const output = [];
        const decoder = new TextDecoder();
        const hexString = decoder.decode(data);
        for (let i = 0; i < hexString.length; i += 2) {
            const hexByte = hexString.substring(i, i + 2);
            const byte = parseInt(hexByte, 16);
            output.push(byte);
        }
        return new Uint8Array(output);
    }
}

class FilterCodec {
    static encode(data, ...filters) {
        let res = data;
        for (let i = filters.length - 1; i >= 0; i--) {
            const filter = filters[i];
            const filterClass = this.items[filter.name];
            if (filterClass) {
                res = filterClass.encode(res, filter.params || null);
            }
        }
        return res;
    }
    static decode(data, ...filters) {
        let res = data;
        for (let i = 0; i <= filters.length - 1; i++) {
            const filter = filters[i];
            const filterClass = this.items[filter.name];
            if (filterClass) {
                res = filterClass.decode(res, filter.params || null);
            }
        }
        return res;
    }
}
FilterCodec.items = {
    FlateDecode: new FlateDecode,
    ASCII85Decode: new ASCII85Decode,
    ASCIIHexDecode: new ASCIIHexDecode,
};

var Encoding;
(function (Encoding) {
    Encoding["Utf8"] = "utf-8";
    Encoding["Utf16Be"] = "utf-16be";
    Encoding["Binary"] = "binary";
})(Encoding || (Encoding = {}));
function generateUniqueID(length = 16) {
    const randomBytes = new Uint8Array(length);
    for (let i = 0; i < length; i++) {
        randomBytes[i] = Math.floor(Math.random() * 256);
    }
    return randomBytes;
}
function generateUUID() {
    const randomBytes = generateUniqueID();
    const formattedUuid = Array.from(randomBytes).map(byte => {
        const hex = byte.toString(16).padStart(2, "0");
        return hex;
    });
    formattedUuid[6] = "4" + formattedUuid[6][1];
    const variants = ["8", "9", "a", "b"];
    const variant = parseInt(formattedUuid[8][0], 16) % 4;
    formattedUuid[8] = variants[variant] + formattedUuid[8][1];
    formattedUuid[3] += "-";
    formattedUuid[5] += "-";
    formattedUuid[7] += "-";
    formattedUuid[9] += "-";
    return formattedUuid.join("");
}
function toBase64(uint8Array) {
    const base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    let result = "";
    let padding = 0;
    const paddingChar = "=";
    for (let i = 0; i < uint8Array.length; i += 3) {
        const a = uint8Array[i];
        const b = uint8Array[i + 1];
        const c = uint8Array[i + 2];
        const index1 = a >> 2;
        const index2 = ((a & 3) << 4) | (b >> 4);
        const index3 = ((b & 15) << 2) | (c >> 6);
        const index4 = c & 63;
        result += base64Chars.charAt(index1) + base64Chars.charAt(index2) +
            base64Chars.charAt(index3) + base64Chars.charAt(index4);
    }
    if (uint8Array.length % 3 === 1) {
        padding = 2;
    }
    else if (uint8Array.length % 3 === 2) {
        padding = 1;
    }
    if (padding > 0) {
        result = result.slice(0, padding * -1) + paddingChar.repeat(padding);
    }
    return result;
}
function fromBase64(base64String) {
    const base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    let padding = 0;
    if (base64String.endsWith("==")) {
        padding = 2;
    }
    else if (base64String.endsWith("=")) {
        padding = 1;
    }
    const byteLength = (base64String.length / 4) * 3 - padding;
    const uint8Array = new Uint8Array(byteLength);
    let index = 0;
    for (let i = 0; i < base64String.length; i += 4) {
        const index1 = base64Chars.indexOf(base64String[i]);
        const index2 = base64Chars.indexOf(base64String[i + 1]);
        const index3 = base64Chars.indexOf(base64String[i + 2]);
        const index4 = base64Chars.indexOf(base64String[i + 3]);
        const value1 = (index1 << 2) | (index2 >> 4);
        const value2 = ((index2 & 15) << 4) | (index3 >> 2);
        const value3 = ((index3 & 3) << 6) | index4;
        uint8Array[index++] = value1;
        if (index < byteLength)
            uint8Array[index++] = value2;
        if (index < byteLength)
            uint8Array[index++] = value3;
    }
    return uint8Array;
}
function hasUtf16BeBOM(str) {
    return str[0] === 0xfe && str[1] === 0xff;
}
function hasUtf8BOM(str) {
    return str[0] === 0xef && str[1] === 0xbb && str[2] === 0xbf;
}
function hexToBinary(hexString) {
    const hexArr = hexString.match(/.{1,2}/g) || [];
    return Uint8Array.from(hexArr.map((byte) => parseInt(byte, 16)));
}
function toUtf16Be(str) {
    const byteArray = new Uint8Array(str.length * 2);
    for (let i = 0; i < str.length; i++) {
        byteArray[i * 2] = str.charCodeAt(i) >> 8;
        byteArray[i * 2 + 1] = str.charCodeAt(i);
    }
    return byteArray;
}
function hexTo2ByteHex(hex) {
    return hex.padStart(4, "0");
}
function ensure1ByteHex(hex) {
    return hex.padStart(2, "0");
}
function formatHex(hex, as2Byte) {
    return as2Byte ? hexTo2ByteHex(hex) : ensure1ByteHex(hex);
}
function hasMoreThan1ByteChars(text) {
    let result = false;
    for (let i = 0; i < text.length; i++) {
        const curCharCode = text.charCodeAt(i);
        if (curCharCode > 0xFF) {
            result = true;
            break;
        }
    }
    return result;
}
function fromBinary(str) {
    let result = "";
    str.forEach((charCode) => result += String.fromCharCode(charCode));
    return result;
}
function toBinary(str) {
    const unescapedRaw = new Uint8Array(str.length);
    for (let i = 0; i < str.length; i++) {
        unescapedRaw[i] = str.charCodeAt(i);
    }
    return unescapedRaw;
}
const lineFeeds = [
    {
        sequence: "\r\n",
        meaning: "\n"
    },
    {
        sequence: "\r",
        meaning: "\n"
    },
];
const noBreakLine = [
    {
        sequence: "\r\n",
        meaning: ""
    },
    {
        sequence: "\n",
        meaning: ""
    },
    {
        sequence: "\r",
        meaning: ""
    },
];
const specialSymbols = [
    {
        sequence: "n",
        meaning: "\n"
    },
    {
        sequence: "r",
        meaning: "\r"
    },
    {
        sequence: "t",
        meaning: "\t"
    },
    {
        sequence: "b",
        meaning: "\b"
    },
    {
        sequence: "f",
        meaning: "\f"
    },
    {
        sequence: "\\(",
        meaning: "("
    },
    {
        sequence: "\\)",
        meaning: ")"
    },
];
const allEscapeSymbols = [...noBreakLine, ...specialSymbols];
function unescapeSpecialSymbols(raw) {
    let unescapedStr = fromBinary(raw);
    unescapedStr = unescapedStr.replace(/\\[0-7]{1,3}/g, (match) => {
        const octalCode = match.substring(1, match.length);
        return String.fromCharCode(parseInt(octalCode, 8));
    });
    allEscapeSymbols.forEach((symbol) => {
        const symbolRegExp = new RegExp(`\\\\${symbol.sequence}`, "g");
        unescapedStr = unescapedStr.replace(symbolRegExp, symbol.meaning);
    });
    lineFeeds.forEach((symbol) => {
        unescapedStr = unescapedStr.replace(symbol.sequence, symbol.meaning);
    });
    const singleSlashRegExp = /\\+/g;
    unescapedStr = unescapedStr.replace(singleSlashRegExp, (match) => {
        const solidusPairs = Math.floor(match.length / 2);
        return "\\".repeat(solidusPairs);
    });
    return toBinary(unescapedStr);
}
const REPLACEMENTS = new Map([
    ["\n", "\\n"],
    ["\r", "\\r"],
    ["\t", "\\t"],
    ["\b", "\\b"],
    ["\f", "\\f"],
    ["(", "\\("],
    [")", "\\)"],
    ["\\", "\\\\"],
]);
function escapeSpecialSymbols(text) {
    return text.replace(/[\n\r\t\f\x08\\()]/gm, char => REPLACEMENTS.get(char) || char);
}
function decodeString(str, encoding) {
    let decodedStr = "";
    if (encoding !== Encoding.Binary) {
        const decoder = new TextDecoder(encoding);
        decodedStr = decoder.decode(str);
    }
    else {
        decodedStr = fromBinary(str);
    }
    return decodedStr;
}
function isEqualRaw(array1, array2) {
    if (array1 === array2) {
        return true;
    }
    if (array1.length !== array2.length) {
        return false;
    }
    for (let i = 0; i < array1.length; i++) {
        if (array1[i] !== array2[i]) {
            return false;
        }
    }
    return true;
}

class CharTypes {
}
CharTypes.integer = new Uint8Array([0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39]);
CharTypes.numbers = new Uint8Array([0x2d, 0x2b, 0x2e, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39]);
CharTypes.flags = new Uint8Array([0x6e, 0x66]);
CharTypes.whiteSpaces = new Uint8Array([0x20, 0x0d, 0x0c, 0x0a, 0x09, 0x00]);
CharTypes.endNameString = new Uint8Array([0x20, 0x0d, 0x0c, 0x0a, 0x09, 0x00, 0x2f, 0x28, 0x29, 0x5b, 0x5d, 0x3c, 0x3e, 0x7b, 0x7d, 0x25]);

class CharCodes {
}
CharCodes.rightAngleBracket = new Uint8Array([0x3e]);
CharCodes.leftAngleBracket = new Uint8Array([0x3c]);
CharCodes.rightParenthesis = new Uint8Array([0x29]);
CharCodes.leftParenthesis = new Uint8Array([0x28]);
CharCodes.rightSquareBracket = new Uint8Array([0x5d]);
CharCodes.leftSquareBracket = new Uint8Array([0x5b]);
CharCodes.forwardSlash = new Uint8Array([0x2f]);
CharCodes.slash = new Uint8Array([0x5c]);
CharCodes.space = new Uint8Array([0x20]);
CharCodes.n = new Uint8Array([0x6e]);
CharCodes.f = new Uint8Array([0x66]);
CharCodes.r = new Uint8Array([0x52]);
CharCodes.zero = new Uint8Array([0x30]);
CharCodes.endLine = new Uint8Array([0x0a]);
CharCodes.carriageReturn = new Uint8Array([0x0d]);
CharCodes.percent = new Uint8Array([0x25]);

class CharWords {
}
CharWords.startDictionary = new Uint8Array([0x3c, 0x3c]);
CharWords.endDictionary = new Uint8Array([0x3e, 0x3e]);
CharWords.false = new Uint8Array([0x66, 0x61, 0x6c, 0x73, 0x65]);
CharWords.true = new Uint8Array([0x74, 0x72, 0x75, 0x65]);
CharWords.obj = new Uint8Array([0x6f, 0x62, 0x6a]);
CharWords.endobj = new Uint8Array([0x65, 0x6e, 0x64, 0x6f, 0x62, 0x6a]);
CharWords.stream = new Uint8Array([0x73, 0x74, 0x72, 0x65, 0x61, 0x6d]);
CharWords.endstream = new Uint8Array([0x65, 0x6e, 0x64, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d]);
CharWords.xref = new Uint8Array([0x78, 0x72, 0x65, 0x66]);
CharWords.startxref = new Uint8Array([0x73, 0x74, 0x61, 0x72, 0x74, 0x78, 0x72, 0x65, 0x66]);
CharWords.eof = new Uint8Array([0x25, 0x25, 0x45, 0x4f, 0x46]);
CharWords.trailer = new Uint8Array([0x74, 0x72, 0x61, 0x69, 0x6c, 0x65, 0x72]);
CharWords.endHeader = new Uint8Array([0x25, 0xff, 0xff, 0xff, 0xff]);
CharWords.eol = new Uint8Array([0x0d, 0x0a]);
CharWords.pdf = new Uint8Array([0x25, 0x50, 0x44, 0x46, 0x2d]);
CharWords.null = new Uint8Array([0x6e, 0x75, 0x6c, 0x6c]);

class CharOperators {
}
CharOperators.q = new Uint8Array([0x71]);
CharOperators.Q = new Uint8Array([0x51]);
CharOperators.qQ = new Uint8Array([0x71, 0x51]);
CharOperators.ID = new Uint8Array([0x49, 0x44]);
CharOperators.EI = new Uint8Array([0x45, 0x49]);

class StringConverter {
    static readHex(raw) {
        const rawNoWhiteSpaces = raw.filter(char => !CharTypes.whiteSpaces.includes(char));
        let hexStr = new TextDecoder().decode(rawNoWhiteSpaces);
        hexStr = hexStr + (hexStr.length % 2 == 1 ? "0" : "");
        const hexStrAsArr = hexToBinary(hexStr);
        let encoding;
        if (hasUtf16BeBOM(hexStrAsArr)) {
            encoding = Encoding.Utf16Be;
        }
        else if (hasUtf8BOM(hexStrAsArr)) {
            encoding = Encoding.Utf8;
        }
        else {
            encoding = Encoding.Binary;
        }
        const decodedStr = decodeString(hexStrAsArr, encoding);
        return decodedStr;
    }
    static writeHex(text, string) {
        let result = "";
        let asUtf16Be;
        if (hasMoreThan1ByteChars(text)) {
            asUtf16Be = true;
            result = "feff";
        }
        else {
            asUtf16Be = false;
        }
        for (let i = 0; i < text.length; i++) {
            const curCharCode = text.charCodeAt(i);
            const hex = curCharCode.toString(16);
            result += formatHex(hex, asUtf16Be);
        }
        return string ? result : PdfBuffer.stringToRaw(result);
    }
    static readLiteral(raw) {
        let decodedStr = "";
        const unescapedRaw = unescapeSpecialSymbols(raw);
        if (hasUtf8BOM(unescapedRaw)) {
            decodedStr = decodeString(unescapedRaw, Encoding.Utf8);
        }
        else if (hasUtf16BeBOM(unescapedRaw)) {
            decodedStr = decodeString(unescapedRaw, Encoding.Utf16Be);
        }
        else {
            decodedStr = decodeString(unescapedRaw, Encoding.Binary);
        }
        return decodedStr;
    }
    static writeLiteral(text) {
        const isUtf16Be = hasMoreThan1ByteChars(text);
        let encodedText = isUtf16Be ? fromBinary(toUtf16Be(text)) : text;
        encodedText = escapeSpecialSymbols(encodedText);
        if (isUtf16Be) {
            encodedText = `\xFE\xFF${encodedText}`;
        }
        return toBinary(encodedText);
    }
    static readName(raw) {
        const nameStr = new TextDecoder().decode(raw);
        const decodedStr = nameStr.replace(/#[0-9A-Fa-f]{2}/g, (match) => {
            const symbolCode = match.slice(-2);
            const symbol = String.fromCharCode(parseInt(symbolCode, 16));
            return symbol;
        });
        return decodedStr;
    }
    static writeName(text) {
        const result = text.replace(/[^!-~]|[[\]<>(){}#%/]/g, (substring) => `#${substring.charCodeAt(0).toString(16).padStart(2, "0")}`);
        return PdfBuffer.stringToRaw(result);
    }
}

const MARKERS = [
    0xffc0, 0xffc1, 0xffc2, 0xffc3,
    0xffc5, 0xffc6, 0xffc7, 0xffc8, 0xffc9,
    0xffca, 0xffcb, 0xffcc, 0xffcd, 0xffce, 0xffcf,
];
class JpegInfo {
    static getInfo(jpeg) {
        const view = new DataView(jpeg.buffer, jpeg.byteOffset, jpeg.byteLength);
        let offset = 0;
        const tag = view.getUint16(offset);
        if (tag !== 0xffd8) {
            throw new Error("Тэг JPEG не найден в JPEG.");
        }
        offset += 2;
        let find = false;
        while (offset < view.byteLength) {
            const marker = view.getUint16(offset);
            offset += 2;
            if (MARKERS.includes(marker)) {
                find = true;
                break;
            }
            offset += view.getUint16(offset);
        }
        if (!find) {
            throw new Error("Поврежденный JPEG.");
        }
        offset += 2;
        const bitsPerComponent = view.getUint8(offset++);
        const height = view.getUint16(offset);
        offset += 2;
        const width = view.getUint16(offset);
        offset += 2;
        const colorSpace = ColorNames[view.getUint8(offset++)];
        if (!colorSpace) {
            throw new Error("Неизвестный ColorSpace.");
        }
        return {
            type: ImageTypes.JPEG,
            buf: jpeg,
            info: {
                bitsPerComponent,
                width,
                height,
                colorSpace,
            }
        };
    }
}

class PngInfo {
    static getInfo(image) {
        const upng = pngLib.decode(image);
        const frames = pngLib.toRGBA8(upng);
        if (frames.length > 1) {
            throw new Error("Изображение содержит несколько фреймов");
        }
        const frame = new Uint8Array(frames[0]);
        const { rgbChannel, alphaChannel } = this.splitAlphaChannel(frame);
        const hasAlphaValues = alphaChannel.some((a) => a < 255);
        return {
            type: ImageTypes.PNG,
            buf: rgbChannel,
            info: {
                alphaChannel: hasAlphaValues ? alphaChannel : undefined,
                bitsPerComponent: 8,
                colorSpace: "DeviceRGB",
                height: upng.height,
                width: upng.width,
            }
        };
    }
    static splitAlphaChannel(rgbaChannel) {
        const pixelCount = Math.floor(rgbaChannel.length / 4);
        const rgbChannel = new Uint8Array(pixelCount * 3);
        const alphaChannel = new Uint8Array(pixelCount * 1);
        let rgbaOffset = 0;
        let rgbOffset = 0;
        let alphaOffset = 0;
        while (rgbaOffset < rgbaChannel.length) {
            rgbChannel[rgbOffset++] = rgbaChannel[rgbaOffset++];
            rgbChannel[rgbOffset++] = rgbaChannel[rgbaOffset++];
            rgbChannel[rgbOffset++] = rgbaChannel[rgbaOffset++];
            alphaChannel[alphaOffset++] = rgbaChannel[rgbaOffset++];
        }
        return { rgbChannel, alphaChannel };
    }
}

var ColorNames;
(function (ColorNames) {
    ColorNames[ColorNames["DeviceGray"] = 1] = "DeviceGray";
    ColorNames[ColorNames["DeviceRGB"] = 3] = "DeviceRGB";
    ColorNames[ColorNames["DeviceCMYK"] = 4] = "DeviceCMYK";
})(ColorNames || (ColorNames = {}));
var ImageTypes;
(function (ImageTypes) {
    ImageTypes[ImageTypes["PNG"] = 0] = "PNG";
    ImageTypes[ImageTypes["JPEG"] = 1] = "JPEG";
})(ImageTypes || (ImageTypes = {}));
class ImageAnalyzer {
    static getImageInfo(buf) {
        try {
            return JpegInfo.getInfo(buf);
        }
        catch (errorJPEG) {
            try {
                return PngInfo.getInfo(buf);
            }
            catch (errorPNG) {
                throw new Error(`Невозможно получить данные изображения: ${errorJPEG}; ${errorPNG}`);
            }
        }
    }
}

class PdfFlags extends PdfNumber {
    constructor(type, options) {
        super(options);
        this.type = type;
        if (options && options.flags) {
            this.set(...options.flags);
        }
    }
    has(v) {
        const f = this.type[v];
        return (this.value & f) === f;
    }
    set(...v) {
        for (const i of v) {
            this.value |= this.type[i];
        }
    }
    get() {
        const res = [];
        for (const key in this.type) {
            if (typeof key === "string" && this.has(key)) {
                res.push(key);
            }
        }
        return res;
    }
    unset(...v) {
        for (const i of v) {
            this.value &= ~this.type[i];
        }
    }
}

class PdfFontFlags extends PdfFlags {
    constructor(options) {
        super(FontFlags, options);
    }
}
var FontFlags;
(function (FontFlags) {
    FontFlags[FontFlags["FixedPitch"] = 1] = "FixedPitch";
    FontFlags[FontFlags["Serif"] = 2] = "Serif";
    FontFlags[FontFlags["Symbolic"] = 4] = "Symbolic";
    FontFlags[FontFlags["Script"] = 8] = "Script";
    FontFlags[FontFlags["Nonsymbolic"] = 32] = "Nonsymbolic";
    FontFlags[FontFlags["Italic"] = 64] = "Italic";
    FontFlags[FontFlags["AllCap"] = 65536] = "AllCap";
    FontFlags[FontFlags["SmallCap"] = 131072] = "SmallCap";
    FontFlags[FontFlags["ForceBold"] = 262144] = "ForceBold";
})(FontFlags || (FontFlags = {}));

class CustomFont {
    constructor(params) {
        this.fontData = params.fontData;
        const fontkitInstance = fontkit.default ? fontkit.default : fontkit;
        this.font = fontkitInstance.create(this.fontData);
    }
    get scale() {
        return 1000 / this.font.unitsPerEm;
    }
    get fontBBox() {
        return [
            Math.round(this.font.bbox.minX * this.scale),
            Math.round(this.font.bbox.minY * this.scale),
            Math.round(this.font.bbox.maxX * this.scale),
            Math.round(this.font.bbox.maxY * this.scale),
        ];
    }
    get ascent() {
        return Math.round(this.font.ascent * this.scale);
    }
    get descent() {
        return Math.round(this.font.descent * this.scale);
    }
    get capHeight() {
        return Math.round((this.font.capHeight || this.ascent) * this.scale);
    }
    get xHeight() {
        return Math.round((this.font.xHeight || 0) * this.scale);
    }
    get italicAngle() {
        return Math.round(this.font.italicAngle);
    }
    get flags() {
        const flags = new PdfFontFlags();
        const familyClass = this.font["OS/2"] ? this.font["OS/2"].sFamilyClass : 0;
        if (1 <= familyClass && familyClass <= 7) {
            flags.set("Serif");
        }
        if (this.font.post.isFixedPitch) {
            flags.set("FixedPitch");
        }
        flags.set("Symbolic");
        if (familyClass === 10) {
            flags.set("Script");
        }
        if (this.font.head.macStyle.italic) {
            flags.set("Italic");
        }
        return flags;
    }
    get subtype() {
        return this.font.cff ? Names.CIDFontType0 : Names.CIDFontType2;
    }
    get cidToGIDMap() { return Names.Identity; }
    get widths() {
        const scale = this.scale;
        const widths = [];
        const metrics = this.font.hmtx.metrics.toArray();
        for (let index = 0; index < metrics.length; index++) {
            const metric = metrics[index];
            widths.push(metric.advance * scale);
        }
        return widths;
    }
    glyphs() {
        const glyphs = new Array(this.font.characterSet.length);
        for (let idx = 0, len = glyphs.length; idx < len; idx++) {
            const codePoint = this.font.characterSet[idx];
            glyphs[idx] = this.font.glyphForCodePoint(codePoint);
        }
        return this.sortedUniq(glyphs.sort((a, b) => a.id - b.id));
    }
    sortedUniq(glyphs) {
        const uniq = [];
        for (let idx = 0, len = glyphs.length; idx < len; idx++) {
            const curr = glyphs[idx];
            const prev = glyphs[idx - 1];
            if (idx === 0 || curr.id !== prev.id) {
                uniq.push(curr);
            }
        }
        return uniq;
    }
    glyphId(glyph) {
        return glyph ? glyph.id : -1;
    }
    supportedLanguages() {
        const glyphs = this.font.characterSet;
        const scriptRanges = {
            "latin": [0x0000, 0x007F],
            "cyrillic": [0x0400, 0x04FF],
            "greek": [0x0370, 0x03FF],
            "hebrew": [0x0590, 0x05FF],
            "arabic": [0x0600, 0x06FF],
        };
        const supportedScripts = [];
        for (const script in scriptRanges) {
            const [start, end] = scriptRanges[script];
            for (let idx = start; idx <= end; idx++) {
                if (glyphs.includes(idx)) {
                    supportedScripts.push(script);
                    break;
                }
            }
        }
        return supportedScripts;
    }
}

class Fonts {
    static getCustom(fontData) {
        return new CustomFont({ fontData });
    }
}

class PdfDictionary extends PdfObject {
    constructor(param = {}) {
        var _a;
        super(param);
        this.values = (_a = param.values) !== null && _a !== void 0 ? _a : new Map();
    }
    get id() {
        if (!this.parent) {
            throw new Error("Объект не имеет родителя");
        }
        if (this.parent instanceof PdfDictionary
            || this.parent instanceof PdfIndirectObject
            || this.parent instanceof Registry.get(RegistryTypes.PdfArray)) {
            return this.parent.id;
        }
        throw new Error("Родитель должен быть PdfIndirectObject, PdfDictionary или PdfArray");
    }
    get items() {
        return this.values;
    }
    onConvert(obj) {
        if (!(obj instanceof PdfDictionary)) {
            throw new Error(`Ошибка преобразования PdfDictionary в '${obj.constructor.name}'.`);
        }
        obj.values = this.values;
    }
    has(key) {
        const name = key instanceof PdfName ? key.value : key;
        return this.values.has(name);
    }
    find(key, type) {
        const name = key instanceof PdfName ? key.value : key;
        let res = this.values.get(name);
        if (res instanceof Registry.get(RegistryTypes.PdfIndirectObject)) {
            res = res.value;
        }
        if (!res) {
            return null;
        }
        if (!type) {
            return res;
        }
        try {
            return res.convert(type);
        }
        catch {
            return null;
        }
    }
    get(key, type) {
        const res = this.find(key);
        if (!res) {
            throw new Error(`PdfDictionary: Элемент не найден '${key}'`);
        }
        if (!type) {
            return res;
        }
        return res.convert(type);
    }
    set(key, obj) {
        this.change();
        const name = key instanceof PdfName ? key.value : key;
        this.values.set(name, obj);
        if (!(obj instanceof Registry.get(RegistryTypes.PdfIndirectObject)) && !obj.parent) {
            obj.parent = this;
        }
        obj.xref = this.xref;
    }
    findOrSet(key, type, ref) {
        let field = this.find(key, type);
        if (!field) {
            switch (true) {
                case type === Registry.get(RegistryTypes.PdfArray):
                    field = this.doc.createArray();
                    break;
                case type === PdfDictionary:
                    field = this.doc.createDictionary();
                    break;
                default:
                    throw new Error("findOrSet(): Неподдерживаемый тип");
            }
            if (ref) {
                this.set(key, field.ref());
            }
            else {
                this.set(key, field);
            }
        }
        return field;
    }
    remove(key) {
        this.change();
        const name = key instanceof PdfName ? key.value : key;
        return this.values.delete(name);
    }
    findInherited(key, type) {
        let res = this.find(key);
        if (!res) {
            const parent = this.find(Names.Parent, PdfDictionary);
            if (!parent) {
                return null;
            }
            res = parent.findInherited(key);
            if (!res) {
                return null;
            }
        }
        if (!type) {
            return res;
        }
        return res.convert(type);
    }
    getInherited(key, type) {
        const res = this.findInherited(key);
        if (!res) {
            throw new Error(`PdfDictionary: Элемент через родителей не найден '${key}'`);
        }
        if (!type) {
            return res;
        }
        return res.convert(type);
    }
}

class PdfArray extends PdfObject {
    constructor(param = {}) {
        var _a;
        super(param);
        this.value = (_a = param.value) !== null && _a !== void 0 ? _a : [];
    }
    get id() {
        if (!this.parent) {
            throw new Error("Объект не имеет родителя");
        }
        if (this.parent instanceof Registry.get(RegistryTypes.PdfDictionary)
            || this.parent instanceof PdfIndirectObject
            || this.parent instanceof PdfArray) {
            return this.parent.id;
        }
        throw new Error("Родитель должен быть PdfIndirectObject, PdfDictionary или PdfArray");
    }
    [Symbol.iterator]() {
        let pointer = 0;
        const that = this;
        return {
            next() {
                if (pointer < that.value.length) {
                    return {
                        done: false,
                        value: that.value[pointer++]
                    };
                }
                else {
                    return {
                        done: true,
                        value: null
                    };
                }
            }
        };
    }
    get length() {
        return this.value.length;
    }
    find(index, type) {
        var _a;
        let res = (_a = this.value[index]) !== null && _a !== void 0 ? _a : null;
        if (res instanceof Registry.get(RegistryTypes.PdfIndirectObject)) {
            res = res.value;
        }
        if (!res) {
            return null;
        }
        if (!type) {
            return res;
        }
        try {
            return res.convert(type);
        }
        catch {
            return null;
        }
    }
    get(index, type) {
        const res = this.find(index);
        if (!res) {
            throw new Error("Элемент не найден");
        }
        if (!type) {
            return res;
        }
        return res.convert(type);
    }
    push(...obj) {
        this.change();
        for (const o of obj) {
            if (!(o instanceof Registry.get(RegistryTypes.PdfIndirectObject)) && !o.parent) {
                o.parent = this;
            }
        }
        this.value.push(...obj);
    }
}

class FilterList {
    constructor(params) {
        this.filters = [];
        this.pdfStream = params.pdfStream;
        this.filters = this.getPdfStreamFilters();
    }
    encode(value) {
        return FilterCodec.encode(value, ...this.list());
    }
    decode(value) {
        return FilterCodec.decode(value, ...this.list());
    }
    list() {
        return this.getPdfStreamFilters();
    }
    getPdfStreamFilters() {
        const names = this.findFilters();
        const params = this.findDecodeParms();
        const newFilters = names.map((name, index) => {
            var _a;
            return ({
                name,
                params: (_a = params[index]) !== null && _a !== void 0 ? _a : undefined,
            });
        });
        return newFilters;
    }
    setNewFilters(...filters) {
        if (!filters.length) {
            return;
        }
        if (filters.length === 1) {
            const { name, params } = filters[0];
            this.pdfStream.set(Names.Filter, this.pdfStream.doc.createName(name));
            if (params) {
                this.pdfStream.set(Names.DecodeParms, params);
            }
            return;
        }
        const names = this.pdfStream.doc.createArray();
        const decodeParms = this.pdfStream.doc.createArray();
        let writeDecodeParms = false;
        for (const filter of filters) {
            names.push(this.pdfStream.doc.createName(filter.name));
            let params;
            if (filter.params) {
                writeDecodeParms = true;
                params = filter.params;
            }
            else {
                params = this.pdfStream.doc.createNull();
            }
            decodeParms.push(params);
        }
        this.pdfStream.set(Names.Filter, names);
        if (writeDecodeParms) {
            this.pdfStream.set(Names.DecodeParms, decodeParms);
        }
    }
    findFilters() {
        const objFilters = this.pdfStream.find(Names.Filter);
        if (!objFilters) {
            return [];
        }
        const names = [];
        if (objFilters instanceof PdfName) {
            names.push(objFilters.value);
        }
        else if (objFilters instanceof PdfArray) {
            for (let index = 0; index < objFilters.length; index++) {
                names.push(objFilters.get(index, PdfName).value);
            }
        }
        else {
            throw new Error(`Некорректный тип фильтров в ${typeof objFilters}`);
        }
        return names;
    }
    findDecodeParms() {
        const decodeParms = [];
        const dp = this.pdfStream.find(Names.DecodeParms);
        if (dp) {
            if (dp instanceof PdfDictionary) {
                decodeParms.push(dp);
            }
            else if (dp instanceof PdfArray) {
                for (const params of dp) {
                    if (params instanceof PdfDictionary) {
                        decodeParms.push(params);
                    }
                    else {
                        decodeParms.push(null);
                    }
                }
            }
            else {
                throw new Error("Неподдерживаемый формат DecodeParms");
            }
        }
        return decodeParms;
    }
    copy(target) {
        const list = new FilterList({ pdfStream: target });
        list.filters = this.filters;
        return list;
    }
}

var _PdfStream_rawValue, _PdfStream_value;
class PdfStream extends PdfDictionary {
    constructor(param = {}) {
        super(param);
        _PdfStream_rawValue.set(this, void 0);
        _PdfStream_value.set(this, void 0);
        this.stream = RawData.EMPTY_VIEW;
        this.filters = new FilterList({ pdfStream: this });
    }
    get Length() {
        return this.get(Names.Length, PdfNumber).value;
    }
    set Length(value) {
        const length = this.find(Names.Length, PdfNumber);
        if (!length) {
            this.set(Names.Length, this.doc.createNumber(value));
        }
        else {
            length.value = value;
        }
    }
    set rawValue(raw) {
        __classPrivateFieldSet(this, _PdfStream_rawValue, raw, "f");
        __classPrivateFieldSet(this, _PdfStream_value, undefined, "f");
        this.Length = __classPrivateFieldGet(this, _PdfStream_rawValue, "f").byteLength;
    }
    get rawValue() {
        let rawValue = __classPrivateFieldGet(this, _PdfStream_rawValue, "f");
        if (rawValue && rawValue.length) {
            return rawValue;
        }
        const value = __classPrivateFieldGet(this, _PdfStream_value, "f");
        if (value && value.length) {
            rawValue = this.filters.encode(value);
            this.rawValue = rawValue;
            return rawValue;
        }
        rawValue = this.stream.getRaw();
        this.rawValue = rawValue;
        return rawValue;
    }
    get value() {
        let value = __classPrivateFieldGet(this, _PdfStream_value, "f");
        if (value) {
            return value;
        }
        const rawValue = this.rawValue;
        if (!rawValue) {
            throw new Error("Stream: содержимое не найдено");
        }
        value = this.filters.decode(rawValue);
        if (!value) {
            throw new Error("Stream: содержимое не декодировано");
        }
        __classPrivateFieldSet(this, _PdfStream_value, value, "f");
        return value;
    }
    set value(v) {
        let value = __classPrivateFieldGet(this, _PdfStream_value, "f");
        if (value && isEqualRaw(value, v)) {
            return;
        }
        value = v;
        __classPrivateFieldSet(this, _PdfStream_rawValue, undefined, "f");
        this.Length = -1;
        __classPrivateFieldSet(this, _PdfStream_value, value, "f");
        this.change();
    }
    onCreate() {
        __classPrivateFieldSet(this, _PdfStream_value, new Uint8Array(), "f");
        this.Length = 0;
    }
    onConvert(obj) {
        if (!(obj instanceof PdfStream)) {
            throw new Error(`Ошибка преобразования PdfStream в '${obj.constructor.name}'.`);
        }
        super.onConvert(obj);
        obj.filters = this.filters.copy(obj);
        obj.stream = this.stream;
    }
}
_PdfStream_rawValue = new WeakMap(), _PdfStream_value = new WeakMap();

var IndirectObjectType;
(function (IndirectObjectType) {
    IndirectObjectType["inUse"] = "n";
    IndirectObjectType["free"] = "f";
    IndirectObjectType["compressed"] = "c";
})(IndirectObjectType || (IndirectObjectType = {}));
class PdfIndirectObject extends PdfObject {
    constructor(param) {
        var _a, _b, _c, _d, _e;
        super(param);
        this.id = param.id;
        this.generation = (_a = param.generation) !== null && _a !== void 0 ? _a : 0;
        this.type = (_b = param.type) !== null && _b !== void 0 ? _b : IndirectObjectType.inUse;
        this.offset = (_c = param.offset) !== null && _c !== void 0 ? _c : 0;
        this.index = (_d = param.index) !== null && _d !== void 0 ? _d : 0;
        this.objStream = (_e = param.objStream) !== null && _e !== void 0 ? _e : 0;
        if (param.xref) {
            this.xref = param.xref;
        }
    }
    getValue(xref) {
        const ParserClass = Registry.get(RegistryTypes.Parser);
        if (this.id === 0) {
            return new PdfNull();
        }
        let privateValue;
        switch (this.type) {
            case IndirectObjectType.free:
                privateValue = new PdfNull();
                break;
            case IndirectObjectType.inUse: {
                if (xref) {
                    const reader = new ParserClass(xref.doc);
                    privateValue = reader.readIndirectObject(this.offset, xref);
                    privateValue.parent = this;
                }
                else {
                    const reader = new ParserClass(this.xref.doc);
                    privateValue = reader.readIndirectObject(this.offset);
                    privateValue.parent = this;
                }
                break;
            }
            case IndirectObjectType.compressed: {
                const objIo = this.xref.getIndirectObject(this.objStream);
                if (!(objIo.value instanceof PdfStream)) {
                    throw new Error("objStream");
                }
                const objStream = objIo.value.convert(Registry.get(RegistryTypes.ObjectStream));
                privateValue = objStream.getObject(this.index);
                privateValue.parent = this;
                break;
            }
            default:
                throw new Error("Неподдерживаемый формат IndirectObject");
        }
        return privateValue;
    }
    get value() {
        if (this.privateValue) {
            return this.privateValue;
        }
        this.privateValue = this.getValue();
        return this.privateValue;
    }
    set value(v) {
        if (this.privateValue) {
            throw new Error("Indirect object уже имеет значение");
        }
        this.privateValue = v;
    }
    getHistory() {
        throw new Error("метод не реализован");
    }
    onChange() {
        if (this.type === IndirectObjectType.free) {
            throw new Error(`${this.id} объект имеет статус free`);
        }
        this.doc.createUpdate();
        if (!this.doc.xref.objects.has(this.id)) {
            this.doc.xref.push(this);
        }
    }
}

class PdfAnnotFlags extends PdfFlags {
    constructor(options) {
        super(AnnotFlags, options);
    }
}
var AnnotFlags;
(function (AnnotFlags) {
    AnnotFlags[AnnotFlags["Invisible"] = 1] = "Invisible";
    AnnotFlags[AnnotFlags["Hidden"] = 2] = "Hidden";
    AnnotFlags[AnnotFlags["Print"] = 4] = "Print";
    AnnotFlags[AnnotFlags["NoZoom"] = 8] = "NoZoom";
    AnnotFlags[AnnotFlags["NoRotate"] = 16] = "NoRotate";
    AnnotFlags[AnnotFlags["NoView"] = 32] = "NoView";
    AnnotFlags[AnnotFlags["ReadOnly"] = 64] = "ReadOnly";
    AnnotFlags[AnnotFlags["Locked"] = 128] = "Locked";
    AnnotFlags[AnnotFlags["ToggleNoView"] = 256] = "ToggleNoView";
    AnnotFlags[AnnotFlags["LockedContents"] = 512] = "LockedContents";
})(AnnotFlags || (AnnotFlags = {}));
var AnnotFlagsName;
(function (AnnotFlagsName) {
    AnnotFlagsName["Invisible"] = "Invisible";
    AnnotFlagsName["Hidden"] = "Hidden";
    AnnotFlagsName["Print"] = "Print";
    AnnotFlagsName["NoZoom"] = "NoZoom";
    AnnotFlagsName["NoRotate"] = "NoRotate";
    AnnotFlagsName["NoView"] = "NoView";
    AnnotFlagsName["ReadOnly"] = "ReadOnly";
    AnnotFlagsName["Locked"] = "Locked";
    AnnotFlagsName["ToggleNoView"] = "ToggleNoView";
    AnnotFlagsName["LockedContents"] = "LockedContents";
})(AnnotFlagsName || (AnnotFlagsName = {}));

class PdfOperator extends RawData {
    constructor(param) {
        super();
        this.tag = param.tag;
        this.params = param.arguments || [];
    }
}

class Header extends RawData {
    constructor() {
        super(...arguments);
        this.version = 1.7;
    }
}

var XRefType;
(function (XRefType) {
    XRefType[XRefType["XRefTable"] = 0] = "XRefTable";
    XRefType[XRefType["XRefStream"] = 1] = "XRefStream";
})(XRefType || (XRefType = {}));

class Pages extends PdfDictionary {
    get kids() {
        return this.get(Names.Kids, PdfArray);
    }
    set kids(value) {
        this.set(Names.Kids, value);
    }
    get count() {
        return this.get(Names.Count, PdfNumber).value;
    }
    set count(value) {
        this.get(Names.Count, PdfNumber).value = value;
    }
    onCreate() {
        this.set(Names.Type, this.doc.createName(Names.Pages));
        this.set(Names.Kids, this.doc.createArray());
        this.set(Names.Count, this.doc.createNumber(0));
    }
}

class Catalog extends PdfDictionary {
    get pages() {
        return this.get(Names.Pages, Pages);
    }
    set pages(value) {
        this.set(Names.Pages, value);
    }
    onCreate() {
        this.set(Names.Type, this.doc.createName(Names.Catalog));
        this.set(Names.Pages, Pages.create(this.xref).ref());
    }
}

class Trailer extends PdfDictionary {
    get Size() {
        return this.get(Names.Size, PdfNumber).value;
    }
    set Size(value) {
        this.get(Names.Size, PdfNumber).value = value;
    }
    get Prev() {
        var _a, _b;
        return (_b = (_a = this.find(Names.Prev, PdfNumber)) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : null;
    }
    set Prev(value) {
        if (value) {
            this.set(Names.Prev, new PdfNumber({ value }));
        }
    }
    get Root() {
        return this.get(Names.Root, Catalog);
    }
    set Root(value) {
        this.set(Names.Root, value);
    }
    get ID() {
        return this.find(Names.ID, PdfArray);
    }
    set ID(value) {
        if (value) {
            this.set(Names.ID, value);
        }
    }
    get Info() {
        return this.find(Names.Info, PdfDictionary);
    }
    set Info(value) {
        if (value) {
            this.set(Names.Info, value);
        }
    }
    get Encrypt() {
        return this.find(Names.Encrypt, PdfDictionary);
    }
    set Encrypt(value) {
        if (value) {
            this.set(Names.Encrypt, value);
        }
    }
    onCreate() {
        this.set(Names.Size, this.doc.createNumber(1));
    }
}

var _XRefTable_trailer, _XRefTable_doc;
class XRefTable {
    constructor() {
        _XRefTable_trailer.set(this, void 0);
        _XRefTable_doc.set(this, void 0);
        this.objects = new Map();
        this.raw = RawData.EMPTY_VIEW;
    }
    get Size() {
        return this.trailer.Size;
    }
    set Size(v) {
        this.trailer.Size = v;
    }
    get trailer() {
        if (__classPrivateFieldGet(this, _XRefTable_trailer, "f")) {
            return __classPrivateFieldGet(this, _XRefTable_trailer, "f");
        }
        throw new Error("XRefTable не содержит trailer");
    }
    set trailer(v) {
        __classPrivateFieldSet(this, _XRefTable_trailer, v, "f");
    }
    get doc() {
        if (__classPrivateFieldGet(this, _XRefTable_doc, "f")) {
            return __classPrivateFieldGet(this, _XRefTable_doc, "f");
        }
        throw new Error("XRefTable не содержит document");
    }
    set doc(v) {
        __classPrivateFieldSet(this, _XRefTable_doc, v, "f");
    }
    isEmptyRaw() {
        throw new Error("Метод не реализован.");
    }
    push(...object) {
        for (const obj of object) {
            obj.xref = this;
            this.objects.set(obj.id, obj);
        }
    }
    findIndirectObject(id) {
        var _a;
        let res = (_a = this.objects.get(id)) !== null && _a !== void 0 ? _a : null;
        if (!res && this.prev) {
            res = this.prev.findIndirectObject(id);
        }
        return res;
    }
    getIndirectObject(id) {
        const obj = this.findIndirectObject(id);
        if (!obj) {
            throw new Error("Элемент не найден");
        }
        return obj;
    }
    static createByParams(params) {
        const xref = new XRefTable();
        if ("doc" in params) {
            xref.doc = params.doc;
            try {
                params.doc.xref;
            }
            catch (error) {
                params.doc.xref = xref;
            }
            xref.trailer = params.trailer || Trailer.create(xref);
        }
        else if ("xref" in params) {
            xref.trailer = params.xref.trailer;
            xref.doc = params.xref.doc;
        }
        else {
            throw new Error("XRefTable: Неизвестные параметры");
        }
        return xref;
    }
}
_XRefTable_trailer = new WeakMap(), _XRefTable_doc = new WeakMap();

var _XRefStream_trailer, _XRefStream_doc;
class XRefStream extends PdfStream {
    constructor() {
        super(...arguments);
        _XRefStream_trailer.set(this, void 0);
        _XRefStream_doc.set(this, void 0);
        this.objects = new Map();
    }
    get W() {
        return this.get(Names.W, PdfArray);
    }
    set W(v) {
        this.set(Names.W, v);
    }
    get Index() {
        let index = this.find("Index", PdfArray);
        if (!index) {
            index = new PdfArray({
                value: [
                    new PdfNumber(),
                    new PdfNumber({ value: this.Size }),
                ]
            });
        }
        return index;
    }
    set Index(v) {
        this.set("Index", v);
    }
    get Size() {
        return this.trailer.Size;
    }
    set Size(v) {
        this.trailer.Size = v;
    }
    get trailer() {
        if (!__classPrivateFieldGet(this, _XRefStream_trailer, "f")) {
            const tr = new Trailer();
            tr.xref = this;
            tr.raw = this.raw;
            tr.parent = this.parent;
            tr.values = this.values;
            if (!this.find(Names.Size)) {
                tr.set(Names.Size, this.doc.createNumber(1));
            }
            __classPrivateFieldSet(this, _XRefStream_trailer, tr, "f");
        }
        return __classPrivateFieldGet(this, _XRefStream_trailer, "f");
    }
    set trailer(v) {
        __classPrivateFieldSet(this, _XRefStream_trailer, v, "f");
    }
    get doc() {
        if (__classPrivateFieldGet(this, _XRefStream_doc, "f")) {
            return __classPrivateFieldGet(this, _XRefStream_doc, "f");
        }
        throw new Error("XRefTable не содержит document");
    }
    set doc(v) {
        __classPrivateFieldSet(this, _XRefStream_doc, v, "f");
    }
    push(...object) {
        for (const obj of object) {
            obj.xref = this;
            this.objects.set(obj.id, obj);
        }
    }
    findIndirectObject(id) {
        var _a;
        let res = (_a = this.objects.get(id)) !== null && _a !== void 0 ? _a : null;
        if (!res && this.prev) {
            res = this.prev.findIndirectObject(id);
        }
        return res;
    }
    getIndirectObject(id) {
        const obj = this.findIndirectObject(id);
        if (!obj) {
            throw new Error(`IndirectObject не найден ${id}`);
        }
        return obj;
    }
    static createByParams(params) {
        const xref = new XRefStream();
        if ("doc" in params) {
            xref.doc = params.doc;
            try {
                params.doc.xref;
            }
            catch (error) {
                params.doc.xref = xref;
            }
            xref.trailer = params.trailer || xref.trailer;
        }
        else if ("xref" in params) {
            xref.trailer = params.xref.trailer;
            xref.doc = params.xref.doc;
        }
        else {
            throw new Error("XRefTable: Неизвестные параметры");
        }
        xref.xref = xref;
        xref.set(Names.Type, xref.doc.createName(Names.XRef));
        return xref;
    }
}
_XRefStream_trailer = new WeakMap(), _XRefStream_doc = new WeakMap();

class ObjectStream extends PdfStream {
    constructor(param = {}) {
        super(param);
        this.n = 0;
        this.first = 0;
        this.extends = null;
        this.objects = new Map();
        if (param.objects) {
            for (let i = 0; i < param.objects.length; i++) {
                this.objects.set(i, param.objects[i]);
            }
        }
    }
    get N() {
        if (!this.n) {
            this.n = this.get(Names.N, PdfNumber).value;
        }
        return this.n;
    }
    set N(v) {
        if (!this.n || this.n !== v) {
            this.n = this.get(Names.N, PdfNumber).value = v;
        }
    }
    get First() {
        if (!this.first) {
            this.first = this.get(Names.First, PdfNumber).value;
        }
        return this.first;
    }
    set First(v) {
        if (!this.first || this.first !== v) {
            this.first = this.get(Names.First, PdfNumber).value = v;
        }
    }
    get Extends() {
        return this.extends;
    }
    getObject(index) {
        const buffer = new PdfBuffer(this.value);
        const count = this.N;
        const res = this.objects.get(index);
        if (res) {
            return res;
        }
        const ParserClass = Registry.get(RegistryTypes.Parser);
        if (!this.pairsNumbers) {
            this.pairsNumbers = ParserClass.readHeaderObjectStream(buffer);
            if (this.pairsNumbers.length !== count) {
                throw new Error("readObjectStream(): параметр N или количество записей в stream некорректно.");
            }
        }
        if (index > count) {
            throw new Error(`Object Stream содержит меньшее число элементов чем ${index}`);
        }
        let offset = this.pairsNumbers[index].num2;
        offset = ParserClass.skipWhiteSpaces(buffer, offset + this.First);
        const resDict = ParserClass.read(buffer, this.xref, offset);
        if (!resDict.ok) {
            throw new Error(`readDictionary(): не удалось прочитать Dictionary по офсету: ${offset}`);
        }
        if (resDict.value instanceof PdfStream) {
            throw new Error(`readDictionary(): некорректный формат Dictionary ${offset}`);
        }
        this.objects.set(index, resDict.value);
        return resDict.value;
    }
    onCreate() {
        this.set(Names.Type, this.doc.createName(Names.ObjStm));
        this.set(Names.N, this.doc.createNumber(0));
        this.set(Names.First, this.doc.createNumber(0));
    }
}

class Image extends PdfStream {
    get width() {
        return this.get(Names.Width, PdfNumber).value;
    }
    set width(value) {
        this.get(Names.Width, PdfNumber).value = value;
    }
    get height() {
        return this.get(Names.Height, PdfNumber).value;
    }
    set height(value) {
        this.get(Names.Height, PdfNumber).value = value;
    }
    onCreate() {
        this.set(Names.Type, this.doc.createName(Names.XObject));
        this.set(Names.Subtype, this.doc.createName(Names.Image));
        this.set(Names.Width, this.doc.createNumber(0));
        this.set(Names.Height, this.doc.createNumber(0));
    }
}

class Logger {
    constructor() {
        this.records = {};
    }
    size() {
        return Object.values(this.records).reduce((total, values) => total + values.length, 0);
    }
    clear() {
        this.records = {};
    }
    addValue(key, value) {
        if (this.records[key]) {
            this.records[key].push(value);
        }
        else {
            this.records[key] = [value];
        }
    }
}

class Copier {
    constructor(params) {
        this.rules = {};
        this.mapIO = new Map();
        this.logRules = new Logger();
        this.doc = params.doc;
    }
    get data() {
        return this.doc.save();
    }
    async copy(inputFile, rules) {
        this.mapIO.clear();
        this.logRules.clear();
        if (rules) {
            this.rules = rules;
        }
        await this.copyTrailer(inputFile.xref.trailer);
        return this.doc;
    }
    async copyTrailer(obj) {
        await this.copyCatalog(obj.Root);
        if (obj.ID) {
            this.doc.xref.trailer.ID = obj.ID;
        }
    }
    async copyCatalog(obj) {
        const root = this.doc.xref.trailer.Root;
        const pages = obj.get(Names.Pages, PdfDictionary);
        if (!(pages.parent && pages.parent instanceof PdfIndirectObject)) {
            throw new Error("Pages должен быть Indirect Object");
        }
        await this.copyPages(pages.parent);
        for (const [key, element] of obj.values) {
            if (key === Names.Pages) {
                continue;
            }
            const newElement = await this.copyIndirectObjectType(element);
            if (newElement) {
                root.set(key, newElement);
            }
        }
    }
    async copyPages(obj) {
        const pages = this.doc.xref.trailer.Root.pages;
        if (!pages.parent || !(pages.parent instanceof PdfIndirectObject)) {
            throw new Error("Ошибочное получение Pages.ID");
        }
        await this.pageExclusionRules(obj.doc);
        this.mapIO.set(obj.id, pages.parent);
        for (const [key, element] of obj.value.values) {
            const newElement = await this.copyIndirectObjectType(element);
            if (newElement) {
                pages.set(key, newElement);
            }
        }
    }
    copyPrimitiveObjectType(copingObj) {
        if (copingObj instanceof PdfBoolean) {
            return this.doc.createBoolean(copingObj.value);
        }
        else if (copingObj instanceof PdfNumber) {
            return this.doc.createNumber(copingObj.value);
        }
        else if (copingObj instanceof PdfLiteralString) {
            return this.doc.createLiteral(copingObj.value);
        }
        else if (copingObj instanceof PdfHexString) {
            return this.doc.createHexString(copingObj.value);
        }
        else if (copingObj instanceof PdfName) {
            return this.doc.createName(copingObj.value);
        }
        else if (copingObj instanceof PdfNull) {
            return this.doc.createNull();
        }
        else {
            throw new Error(`Ошибка: неподдерживаемый тип ${copingObj.constructor.name}`);
        }
    }
    async copyObjectType(copingObj, targetObj) {
        if (copingObj instanceof PdfStream && targetObj instanceof PdfStream) {
            return this.copyPdfStream(copingObj, targetObj);
        }
        else if (copingObj instanceof PdfDictionary && targetObj instanceof PdfDictionary) {
            return this.copyPdfDictionary(copingObj, targetObj);
        }
        else if (copingObj instanceof PdfArray && targetObj instanceof PdfArray) {
            return this.copyPdfArray(copingObj, targetObj);
        }
        else {
            throw new Error(`Ошибка копирования: ${copingObj.constructor.name}`);
        }
    }
    async copyPdfArray(obj, newObj) {
        for (const element of obj) {
            const newElement = await this.copyIndirectObjectType(element);
            if (newElement) {
                newObj.push(newElement);
            }
        }
        if (!newObj.length) {
            return null;
        }
        return newObj;
    }
    async copyPdfStream(obj, newObj) {
        await this.copyPdfDictionary(obj, newObj);
        newObj.rawValue = obj.rawValue;
        return newObj;
    }
    async copyPdfDictionary(obj, newObj) {
        await this.copyRules(this.doc, obj);
        for (const [key, element] of obj.values) {
            const newElement = await this.copyIndirectObjectType(element);
            if (newElement) {
                newObj.set(key, newElement);
            }
        }
        if (!newObj.values.size) {
            return null;
        }
        return newObj;
    }
    async copyIndirectObjectType(obj) {
        let value;
        if (obj.parent instanceof PdfIndirectObject) {
            obj = obj.parent;
        }
        if (obj instanceof PdfIndirectObject) {
            if (this.mapIO.has(obj.id)) {
                const newIO = this.mapIO.get(obj.id);
                if (newIO === undefined) {
                    throw new Error("Ошибочная запись в mapIO");
                }
                return newIO;
            }
            value = obj.value;
            this.mapIO.set(obj.id, null);
        }
        else {
            value = obj;
        }
        if (await this.deletionRules(value)) {
            return null;
        }
        let newObj;
        if (value instanceof PdfStream) {
            newObj = this.doc.createStream();
        }
        else if (value instanceof PdfDictionary) {
            newObj = this.doc.createDictionary();
        }
        else if (value instanceof PdfArray) {
            newObj = this.doc.createArray();
        }
        else {
            newObj = this.copyPrimitiveObjectType(value);
        }
        if (obj instanceof PdfIndirectObject) {
            const newIO = this.doc.createIndirectObject(newObj);
            this.mapIO.set(obj.id, newIO);
        }
        if (value instanceof PdfStream || value instanceof PdfDictionary || value instanceof PdfArray) {
            await this.copyObjectType(value, newObj);
        }
        return newObj;
    }
    async pageExclusionRules(doc) {
        if (!this.rules.exclusion) {
            return;
        }
        const list = doc.getPagesList();
        const keysBadPages = [];
        for (const [keyPage, value] of list) {
            for (const rule of this.rules.exclusion.rules) {
                if (rule.disabled) {
                    continue;
                }
                const record = await rule.detect(value);
                if (record) {
                    keysBadPages.push(keyPage);
                    record[Names.Page] = keyPage;
                    this.logRules.addValue(rule.title, record);
                    break;
                }
            }
        }
        const images = await this.rules.exclusion.convert(doc, keysBadPages);
        for (const keyPage of keysBadPages) {
            const pageInfo = images.get(keyPage);
            if (!pageInfo) {
                throw new Error("Информация о странице не найдена");
            }
            const page = list.get(keyPage);
            if (!page) {
                throw new Error("Страница не найдена в списке");
            }
            const image = doc.createImage(pageInfo.data);
            const uuid = "img-1";
            page.set(Names.Contents, doc.createArray(doc.createStream({
                stream: PdfBuffer.stringToRaw(doc.createImageTransformationMatrix(pageInfo, uuid))
            }).ref()));
            page.set(Names.Resources, doc.createDictionary({
                XObject: doc.createDictionary({ [uuid]: image.ref() })
            }));
        }
    }
    async deletionRules(obj) {
        if (!this.rules.delete) {
            return false;
        }
        let value;
        let id = 0;
        if (obj instanceof PdfIndirectObject) {
            value = obj.value;
            id = obj.id;
        }
        else {
            value = obj;
            if (obj.parent instanceof PdfIndirectObject) {
                id = obj.parent.id;
            }
        }
        for (const rule of this.rules.delete) {
            if (rule.disabled) {
                continue;
            }
            const record = await rule.detect(value);
            if (record) {
                record[Names.ID] = id;
                this.logRules.addValue(rule.title, record);
                return true;
            }
        }
        return false;
    }
    async copyRules(doc, obj) {
        if (!this.rules.copy) {
            return;
        }
        for (const rule of this.rules.copy) {
            if (rule.disabled) {
                continue;
            }
            const record = await rule.correction(doc, obj);
            if (record) {
                this.logRules.addValue(rule.title, record);
                if (rule.only) {
                    return;
                }
            }
        }
    }
}

var _Parser_doc;
class Parser {
    constructor(doc) {
        _Parser_doc.set(this, void 0);
        __classPrivateFieldSet(this, _Parser_doc, doc, "f");
    }
    readXRef() {
        let offset = this.getLastEOF();
        if (offset === 0) {
            throw new Error("EOF не найден");
        }
        offset = Parser.skipWhiteSpaces(__classPrivateFieldGet(this, _Parser_doc, "f").buffer, offset);
        const xrefHeader = Parser.isWord(__classPrivateFieldGet(this, _Parser_doc, "f").buffer, offset, CharWords.xref);
        if (xrefHeader.ok) {
            return this.readXRefTable(offset);
        }
        return this.readXRefStream(offset);
    }
    readObject(index, type, xref) {
        const currentXref = xref ? xref : __classPrivateFieldGet(this, _Parser_doc, "f").xref;
        const res = Parser.read(__classPrivateFieldGet(this, _Parser_doc, "f").buffer, currentXref, index);
        if (!res.ok) {
            throw new Error(`Невозможно прочитать объект по индексу ${index}`);
        }
        if (type && !(res.value instanceof type)) {
            throw new Error("Тип объекта не соответствует нужному");
        }
        return res.value;
    }
    static readComment(buffer, offset) {
        const comment = Parser.isWord(buffer, offset, CharCodes.percent);
        if (!comment.ok) {
            return { ok: false };
        }
        const comment2 = Parser.findWord(buffer, comment.offset2, CharCodes.endLine);
        if (!comment2.ok) {
            return { ok: false };
        }
        const textRaw = buffer.subarray(comment.offset2 + 1, comment2.offset1).getRaw();
        let text = "";
        try {
            const decoder = new TextDecoder("utf-8");
            text = decoder.decode(textRaw);
        }
        catch {
            text = Array.from(textRaw).map(byte => String.fromCharCode(byte)).join("");
        }
        const commentObject = new PdfComment();
        commentObject.value = text;
        commentObject.raw = buffer.subarray(comment.offset1, comment2.offset2);
        return {
            ok: true,
            offset1: comment.offset1,
            offset2: comment2.offset2,
            value: commentObject,
        };
    }
    readHeader() {
        const pdf = Parser.findWord(__classPrivateFieldGet(this, _Parser_doc, "f").buffer, 0, CharWords.pdf);
        if (!pdf.ok) {
            throw new Error("'%PDF-' не найден");
        }
        const version = Parser.readNumber(__classPrivateFieldGet(this, _Parser_doc, "f").buffer, pdf.offset2 + 1);
        if (!version.ok) {
            throw new Error("Не удалось прочитать версию");
        }
        const spaces = Parser.skipWhiteSpaces(__classPrivateFieldGet(this, _Parser_doc, "f").buffer, version.offset2 + 1);
        const comment = Parser.readComment(__classPrivateFieldGet(this, _Parser_doc, "f").buffer, spaces);
        const header = new Header();
        header.version = version.value.value;
        header.raw = __classPrivateFieldGet(this, _Parser_doc, "f").buffer.subarray(0, comment.ok ? comment.offset2 : version.offset2);
        header.comment = comment.ok ? comment.value : undefined;
        return header;
    }
    static read(buffer, xref, index) {
        const ref = Parser.isRef(buffer, index);
        if (ref.ok) {
            const ind = xref.findIndirectObject(ref.pair.num1);
            if (ind) {
                return {
                    ok: true,
                    offset1: ref.offset1,
                    offset2: ref.offset2,
                    value: ind
                };
            }
            return {
                ok: true,
                offset1: ref.offset1,
                offset2: ref.offset2,
                value: new PdfIndirectObject({
                    id: ref.pair.num1,
                    xref,
                })
            };
        }
        const dictionary = Parser.readDictionary(buffer, xref, index);
        if (dictionary.ok) {
            return dictionary;
        }
        const bool = Parser.readBoolean(buffer, index);
        if (bool.ok) {
            return bool;
        }
        const str = Parser.readString(buffer, index);
        if (str.ok) {
            return str;
        }
        const arr = Parser.readArray(buffer, xref, index);
        if (arr.ok) {
            return arr;
        }
        const num = Parser.readNumber(buffer, index);
        if (num.ok) {
            return num;
        }
        const nul = Parser.readNull(buffer, index);
        if (nul.ok) {
            return nul;
        }
        return { ok: false };
    }
    static readHeaderObjectStream(buffer) {
        const res = [];
        let offset = 0;
        while (true) {
            offset = Parser.skipWhiteSpaces(buffer, offset);
            const resPair = Parser.isPairNumbers(buffer, offset);
            if (!resPair.ok) {
                break;
            }
            offset = resPair.offset2;
            res.push(resPair.pair);
        }
        return res;
    }
    readIndirectObject(offset, xref) {
        const header = Parser.isObject(__classPrivateFieldGet(this, _Parser_doc, "f").buffer, offset);
        if (!header.ok) {
            return new PdfNull();
        }
        return this.readObject(Parser.skipWhiteSpacesAndComments(__classPrivateFieldGet(this, _Parser_doc, "f").buffer, header.offset2 + 1), PdfObject, xref);
    }
    static readDictionary(buffer, xref, index) {
        const start = Parser.isWord(buffer, index, CharWords.startDictionary);
        if (!start.ok) {
            return { ok: false };
        }
        let dictionary = new PdfDictionary();
        dictionary.xref = xref;
        let offset2 = start.offset2;
        while (true) {
            offset2++;
            Parser.isEndFile(buffer, offset2);
            offset2 = Parser.skipWhiteSpacesAndComments(buffer, offset2);
            const end = Parser.isWord(buffer, offset2, CharWords.endDictionary);
            if (end.ok) {
                const next = Parser.skipWhiteSpacesAndComments(buffer, end.offset2 + 1);
                const stream = Parser.isWord(buffer, next, CharWords.stream);
                if (stream.ok) {
                    const length = dictionary.get(Names.Length, PdfNumber).value;
                    const isValue = Parser.isStream(buffer, next, length);
                    if (!isValue.ok) {
                        throw new Error("Невозможно прочитать stream");
                    }
                    let startOffsetStream = isValue.offset1;
                    const isEndLine = Parser.isChar(buffer, startOffsetStream, CharCodes.endLine);
                    if (!isEndLine) {
                        const isEol = Parser.isWord(buffer, startOffsetStream, CharWords.eol);
                        if (!isEol.ok) {
                            throw new Error("Некорректный перенос строки в stream");
                        }
                        startOffsetStream = isEol.offset2 + 1;
                    }
                    else {
                        startOffsetStream++;
                    }
                    const value = buffer.subarray(startOffsetStream, isValue.offset2);
                    const dictionaryStm = dictionary.convert(PdfStream);
                    dictionaryStm.stream = value;
                    dictionary = dictionaryStm;
                    offset2 = isValue.offset2 + CharWords.endstream.length;
                }
                else {
                    offset2 += 1;
                }
                break;
            }
            const name = Parser.readNameString(buffer, offset2);
            if (!name.ok) {
                throw new Error("Dictionary: Плохое имя");
            }
            offset2 = name.offset2 + 1;
            const key = name.value.value;
            offset2 = Parser.skipWhiteSpaces(buffer, offset2);
            const obj = this.read(buffer, xref, offset2);
            if (!obj.ok) {
                throw new Error("Dictionary: Плохое значение");
            }
            offset2 = obj.offset2;
            const value = obj.value;
            value.xref = xref;
            if (!(value.parent instanceof PdfIndirectObject) && !(value instanceof PdfIndirectObject)) {
                value.parent = dictionary;
            }
            dictionary.values.set(key, value);
        }
        dictionary.raw = buffer.subarray(index, offset2 + 1);
        return {
            ok: true,
            offset1: index,
            offset2,
            value: dictionary,
        };
    }
    static readArray(buffer, xref, index) {
        const leftBracket = Parser.isChar(buffer, index, CharCodes.leftSquareBracket);
        if (!leftBracket) {
            return { ok: false };
        }
        const arr = new PdfArray();
        const objects = [];
        let offset2 = index;
        while (true) {
            offset2++;
            Parser.isEndFile(buffer, offset2);
            offset2 = Parser.skipWhiteSpaces(buffer, offset2);
            const rightBracket = Parser.isChar(buffer, offset2, CharCodes.rightSquareBracket);
            if (rightBracket) {
                break;
            }
            const obj = this.read(buffer, xref, offset2);
            if (obj.ok) {
                offset2 = obj.offset2;
                if (!(obj.value instanceof PdfIndirectObject)) {
                    obj.value.parent = arr;
                }
                objects.push(obj.value);
                continue;
            }
        }
        arr.value = objects;
        arr.raw = buffer.subarray(index, offset2);
        return {
            ok: true,
            offset1: index,
            offset2,
            value: arr,
        };
    }
    static skipWhiteSpaces(buffer, offset, reverse = false) {
        let index = offset;
        const space = Parser.isType(buffer, index, CharTypes.whiteSpaces, reverse);
        if (space.ok) {
            index = space.offset2 + 1;
        }
        return index;
    }
    static skipWhiteSpacesAndComments(buffer, offset) {
        let index = offset;
        while (true) {
            index = Parser.skipWhiteSpaces(buffer, index);
            const comment = Parser.readComment(buffer, index);
            if (comment.ok) {
                index = comment.offset2 + 1;
            }
            else {
                break;
            }
        }
        return index;
    }
    static readBoolean(buffer, index) {
        const first = Parser.isWord(buffer, index, CharWords.false);
        if (first.ok) {
            const value = new PdfBoolean({ value: false });
            value.raw = buffer.subarray(index, first.offset2 + 1);
            return {
                ok: true,
                offset1: first.offset1,
                offset2: first.offset2,
                value,
            };
        }
        const second = Parser.isWord(buffer, index, CharWords.true);
        if (second.ok) {
            const value = new PdfBoolean({ value: true });
            value.raw = buffer.subarray(index, second.offset2 + 1);
            return {
                ok: true,
                offset1: second.offset1,
                offset2: second.offset2,
                value,
            };
        }
        return { ok: false };
    }
    static readString(buffer, index) {
        const name = Parser.readNameString(buffer, index);
        if (name.ok) {
            return name;
        }
        const hex = Parser.readHexString(buffer, index);
        if (hex.ok) {
            return hex;
        }
        const literal = Parser.readLiteralString(buffer, index);
        if (literal.ok) {
            return literal;
        }
        return { ok: false };
    }
    static readHexString(buffer, index) {
        const str = Parser.isBetween(buffer, index, CharCodes.leftAngleBracket, CharCodes.rightAngleBracket);
        if (!str.ok) {
            return { ok: false };
        }
        const value = buffer.subarray(str.offset1, str.offset2 + 1);
        const hex = new PdfHexString({ value: StringConverter.readHex(value.getRaw()) });
        hex.raw = buffer.subarray(index, str.offset2 + 2);
        return {
            ok: true,
            offset1: index,
            offset2: str.offset2 + 1,
            value: hex,
        };
    }
    static readLiteralString(buffer, index) {
        const str = Parser.isLiteralString(buffer, index);
        if (!str.ok) {
            return { ok: false };
        }
        const value = buffer.subarray(str.offset1, str.offset2 + 1);
        const literal = new PdfLiteralString({ value: StringConverter.readLiteral(value.getRaw()) });
        literal.raw = buffer.subarray(index, str.offset2 + 2);
        return {
            ok: true,
            offset1: index,
            offset2: str.offset2 + 1,
            value: literal,
        };
    }
    static readNameString(buffer, index) {
        const str = Parser.isBetween(buffer, index, CharCodes.forwardSlash, CharTypes.endNameString, true, true);
        if (!str.ok) {
            return { ok: false };
        }
        const value = buffer.subarray(str.offset1, str.offset2 + 1);
        const name = new PdfName({ value: StringConverter.readName(value.getRaw()) });
        name.raw = buffer.subarray(index, str.offset2 + 1);
        return {
            ok: true,
            offset1: index,
            offset2: str.offset2,
            value: name,
        };
    }
    static readNumber(buffer, index) {
        const num = Parser.isType(buffer, index, CharTypes.numbers);
        if (!num.ok) {
            return { ok: false };
        }
        const value = Parser.getNumberByOffset(buffer, num.offset1, num.offset2);
        const obj = new PdfNumber({ value });
        obj.raw = buffer.subarray(index, num.offset2 + 1);
        return {
            ok: true,
            offset1: num.offset1,
            offset2: num.offset2,
            value: obj,
        };
    }
    static readNull(buffer, index) {
        const nullWord = Parser.isWord(buffer, index, CharWords.null);
        if (!nullWord.ok) {
            return { ok: false };
        }
        const obj = new PdfNull();
        obj.raw = buffer.subarray(index, nullWord.offset2 + 1);
        return {
            ok: true,
            offset1: index,
            offset2: nullWord.offset2,
            value: obj,
        };
    }
    static num(view, defaultValue = 0) {
        if (!view.length) {
            return defaultValue;
        }
        let value = 0;
        for (const byte of view) {
            value = (value << 8) | byte;
        }
        return value;
    }
    readXRefStream(offset1) {
        const headerObj = Parser.isObject(__classPrivateFieldGet(this, _Parser_doc, "f").buffer, offset1);
        if (!headerObj.ok) {
            throw new Error("XRefStream должен начинаться как IndirectObject");
        }
        const xRefStream = new XRefStream();
        xRefStream.doc = __classPrivateFieldGet(this, _Parser_doc, "f");
        try {
            __classPrivateFieldGet(this, _Parser_doc, "f").xref;
        }
        catch (error) {
            __classPrivateFieldGet(this, _Parser_doc, "f").xref = xRefStream;
        }
        xRefStream.parent = new PdfIndirectObject({ id: headerObj.pair.num1, offset: offset1, type: IndirectObjectType.inUse });
        const offset2 = Parser.skipWhiteSpaces(__classPrivateFieldGet(this, _Parser_doc, "f").buffer, headerObj.offset2 + 1);
        const stream = this.readObject(offset2, PdfStream);
        xRefStream.raw = stream.raw;
        xRefStream.values = stream.values;
        xRefStream.stream = stream.stream;
        const w = xRefStream.W;
        if (w.length !== 3) {
            throw new Error(`W имеет длину ${w.length}`);
        }
        const objectSets = [];
        for (let index = 0; index < xRefStream.Index.length; index++) {
            objectSets.push({
                num1: xRefStream.Index.get(index++, PdfNumber).value,
                num2: xRefStream.Index.get(index, PdfNumber).value,
            });
        }
        let offset = 0;
        const w1 = w.get(0, PdfNumber).value;
        const w2 = w.get(1, PdfNumber).value;
        const w3 = w.get(2, PdfNumber).value;
        const rawStream = new PdfBuffer(xRefStream.value);
        for (const set of objectSets) {
            for (let index = 0; index < set.num2; index++) {
                const objId = set.num1 + index;
                const field1 = Parser.num(rawStream.subarray(offset, offset + w1).getRaw());
                offset += w1;
                const field2 = Parser.num(rawStream.subarray(offset, offset + w2).getRaw());
                offset += w2;
                const field3 = Parser.num(rawStream.subarray(offset, offset + w3).getRaw());
                offset += w3;
                switch (field1) {
                    case 0:
                        break;
                    case 1:
                        xRefStream.push(new PdfIndirectObject({ id: objId, offset: field2, type: IndirectObjectType.inUse }));
                        break;
                    case 2:
                        xRefStream.push(new PdfIndirectObject({ id: objId, objStream: field2, index: field3, type: IndirectObjectType.compressed }));
                        break;
                    default:
                        throw new Error(`Неподдерживаемый тип W ${field1}`);
                }
            }
        }
        if (xRefStream.trailer.Prev) {
            xRefStream.prev = this.readXRefStream(xRefStream.trailer.Prev);
        }
        for (const [key, value] of xRefStream.trailer.items) {
            if (value instanceof PdfIndirectObject) {
                const a = xRefStream.findIndirectObject(value.id);
                if (a) {
                    xRefStream.trailer.values.set(key, a);
                }
            }
        }
        return xRefStream;
    }
    getLastEOF() {
        let offset1 = 0;
        let index = __classPrivateFieldGet(this, _Parser_doc, "f").buffer.length;
        while (index > 0) {
            const eof = Parser.isWord(__classPrivateFieldGet(this, _Parser_doc, "f").buffer, index--, CharWords.eof, true);
            if (eof.ok) {
                index = eof.offset1 - 1;
                break;
            }
        }
        while (index > 0) {
            const offsetXRef = Parser.isType(__classPrivateFieldGet(this, _Parser_doc, "f").buffer, index--, CharTypes.numbers, true);
            if (offsetXRef.ok) {
                offset1 = Parser.getNumberByOffset(__classPrivateFieldGet(this, _Parser_doc, "f").buffer, offsetXRef.offset1, offsetXRef.offset2);
                index = offsetXRef.offset1 - 1;
                break;
            }
        }
        return offset1;
    }
    readXRefTable(offset1) {
        const start = Parser.skipWhiteSpaces(__classPrivateFieldGet(this, _Parser_doc, "f").buffer, offset1);
        const xrefHeader = Parser.isWord(__classPrivateFieldGet(this, _Parser_doc, "f").buffer, start, CharWords.xref);
        if (!xrefHeader.ok) {
            throw new Error(`Заголовок 'xref' не найден ${offset1}`);
        }
        let offset2 = Parser.skipWhiteSpaces(__classPrivateFieldGet(this, _Parser_doc, "f").buffer, xrefHeader.offset2 + 1);
        const xRefTable = XRefTable.createByParams({ doc: __classPrivateFieldGet(this, _Parser_doc, "f") });
        while (true) {
            offset2 = Parser.skipWhiteSpaces(__classPrivateFieldGet(this, _Parser_doc, "f").buffer, offset2);
            const tr = Parser.isWord(__classPrivateFieldGet(this, _Parser_doc, "f").buffer, offset2, CharWords.trailer);
            if (tr.ok) {
                offset2 = tr.offset2 + 1;
                break;
            }
            offset2 = Parser.skipWhiteSpaces(__classPrivateFieldGet(this, _Parser_doc, "f").buffer, offset2);
            const idResult = Parser.isType(__classPrivateFieldGet(this, _Parser_doc, "f").buffer, offset2, CharTypes.numbers);
            if (!idResult.ok) {
                throw new Error(`Неправильный ID в заголовке таблицы XRefTable ${offset2}`);
            }
            offset2 = Parser.skipWhiteSpaces(__classPrivateFieldGet(this, _Parser_doc, "f").buffer, idResult.offset2 + 1);
            const countResult = Parser.isType(__classPrivateFieldGet(this, _Parser_doc, "f").buffer, offset2, CharTypes.numbers);
            if (!countResult.ok) {
                throw new Error(`Неправильный Count в заголовке таблицы XRefTable ${offset2}`);
            }
            offset2 = countResult.offset2 + 1;
            const count = Parser.getNumberByOffset(__classPrivateFieldGet(this, _Parser_doc, "f").buffer, countResult.offset1, countResult.offset2);
            const id = Parser.getNumberByOffset(__classPrivateFieldGet(this, _Parser_doc, "f").buffer, idResult.offset1, idResult.offset2);
            for (let index = 0; index < count; index++) {
                offset2 = Parser.skipWhiteSpaces(__classPrivateFieldGet(this, _Parser_doc, "f").buffer, offset2);
                const first = Parser.isType(__classPrivateFieldGet(this, _Parser_doc, "f").buffer, offset2, CharTypes.numbers);
                if (!first.ok) {
                    throw new Error(`Неправильный Offset в записи таблицы XRefTable ${offset2}`);
                }
                offset2 = Parser.skipWhiteSpaces(__classPrivateFieldGet(this, _Parser_doc, "f").buffer, first.offset2 + 1);
                const second = Parser.isType(__classPrivateFieldGet(this, _Parser_doc, "f").buffer, offset2, CharTypes.numbers);
                if (!first.ok) {
                    throw new Error(`Неправильный Generation в записи таблицы XRefTable ${offset2}`);
                }
                offset2 = Parser.skipWhiteSpaces(__classPrivateFieldGet(this, _Parser_doc, "f").buffer, second.offset2 + 1);
                const flag = Parser.isChar(__classPrivateFieldGet(this, _Parser_doc, "f").buffer, offset2, CharCodes.n);
                if (!flag) {
                    offset2 = offset2 + 2;
                    continue;
                }
                const objOffset = Parser.getNumberByOffset(__classPrivateFieldGet(this, _Parser_doc, "f").buffer, first.offset1, first.offset2);
                if (objOffset === 0) {
                    offset2 = offset2 + 2;
                    continue;
                }
                let objId = id + index;
                if (xRefTable.Size <= objId) {
                    xRefTable.Size = objId + 1;
                }
                const headerObject = Parser.isObject(__classPrivateFieldGet(this, _Parser_doc, "f").buffer, objOffset);
                if (!headerObject) {
                    throw new Error(`Индекс ${objOffset} из таблицы XRef указывает на несуществующий объект`);
                }
                if (objId !== headerObject.pair.num1) {
                    objId = headerObject.pair.num1;
                }
                const generation = Parser.getNumberByOffset(__classPrivateFieldGet(this, _Parser_doc, "f").buffer, second.offset1, second.offset2);
                xRefTable.push(new PdfIndirectObject({ id: objId, offset: objOffset, generation }));
                offset2 = offset2 + 2;
            }
        }
        offset2 = Parser.skipWhiteSpaces(__classPrivateFieldGet(this, _Parser_doc, "f").buffer, offset2);
        const tr = this.readObject(offset2, PdfDictionary);
        tr.xref = xRefTable;
        xRefTable.trailer = tr.convert(Trailer);
        if (xRefTable.trailer.Prev) {
            xRefTable.prev = this.readXRefTable(xRefTable.trailer.Prev);
        }
        offset2 += tr.raw.length + 1;
        for (const [key, value] of xRefTable.trailer.items) {
            if (value instanceof PdfIndirectObject) {
                const a = xRefTable.getIndirectObject(value.id);
                xRefTable.trailer.values.set(key, a);
            }
        }
        const eof = Parser.findWord(__classPrivateFieldGet(this, _Parser_doc, "f").buffer, offset2, CharWords.eof);
        if (!eof.ok) {
            throw new Error("Нет окончания EOF в XRefTable");
        }
        xRefTable.raw = __classPrivateFieldGet(this, _Parser_doc, "f").buffer.subarray(offset1, eof.offset2 + 1);
        return xRefTable;
    }
    static isLiteralString(buffer, offset1) {
        let offset2 = offset1;
        if (!Parser.isChar(buffer, offset2, CharCodes.leftParenthesis)) {
            return { ok: false, offset1, offset2 };
        }
        offset2++;
        for (; offset2 < buffer.raw.length; offset2++) {
            if (Parser.isChar(buffer, offset2, CharCodes.rightParenthesis)) {
                return {
                    ok: true,
                    offset1: offset1 + 1,
                    offset2: offset2 - 1
                };
            }
            if (Parser.isChar(buffer, offset2, CharCodes.slash)) {
                offset2++;
                continue;
            }
            const res = Parser.isLiteralString(buffer, offset2);
            if (res.ok) {
                offset2 = res.offset2 + 1;
            }
        }
        throw new Error(`Некорректный формат LiteralString по offset '${offset1}'`);
    }
    static isEndFile(buffer, offset2) {
        if (offset2 >= buffer.length) {
            throw new Error("Конец файла");
        }
    }
    static isStream(buffer, index, length) {
        let offset1 = index;
        let offset2 = index;
        const start = Parser.isWord(buffer, offset2, CharWords.stream);
        if (!start.ok) {
            return { ok: false, offset1, offset2 };
        }
        offset1 = start.offset2 + 1;
        offset2 = start.offset2 + 3 + length;
        const end = Parser.isWord(buffer, offset2, CharWords.endstream);
        if (end.ok) {
            offset2 = end.offset1 - 1;
        }
        else {
            offset2 = offset1;
            while (true) {
                Parser.isEndFile(buffer, offset2);
                const end = Parser.isWord(buffer, offset2, CharWords.endstream);
                if (end.ok) {
                    offset2 = end.offset1 - 1;
                    break;
                }
                offset2++;
            }
            const eol = Parser.isType(buffer, offset2, CharWords.eol, true);
            if (eol.ok) {
                offset2 = eol.offset1;
            }
        }
        return { ok: true, offset1, offset2 };
    }
    static isObject(buffer, index) {
        return Parser.isPairNumbers(buffer, index, CharWords.obj);
    }
    static isRef(buffer, index) {
        return Parser.isPairNumbers(buffer, index, CharCodes.r);
    }
    static isPairNumbers(buffer, index, endWord) {
        const offset1 = index;
        let offset2 = index;
        const obj = {
            pair: {
                num1: 0,
                num2: 0,
            },
            offset1,
            offset2,
            ok: false,
        };
        offset2 = Parser.skipWhiteSpaces(buffer, offset2);
        const first = Parser.isType(buffer, offset2, CharTypes.integer);
        if (!first.ok) {
            return obj;
        }
        offset2 = first.offset2 + 1;
        const space = Parser.isType(buffer, offset2, CharTypes.whiteSpaces);
        if (!space.ok) {
            return obj;
        }
        offset2 = space.offset2 + 1;
        const second = Parser.isType(buffer, offset2, CharTypes.numbers);
        if (!first.ok) {
            return obj;
        }
        offset2 = second.offset2 + 1;
        const space2 = Parser.isType(buffer, offset2, CharTypes.whiteSpaces);
        if (!space2.ok) {
            return obj;
        }
        offset2 = space2.offset2 + 1;
        if (endWord) {
            const tr = Parser.isWord(buffer, offset2, endWord);
            if (!tr.ok) {
                return obj;
            }
            offset2 = tr.offset2;
        }
        return {
            pair: {
                num1: Parser.getNumberByOffset(buffer, first.offset1, first.offset2),
                num2: Parser.getNumberByOffset(buffer, second.offset1, second.offset2),
            },
            offset1,
            offset2,
            ok: true,
        };
    }
    static isBetween(buffer, index, start, end, endIsType = false, toEnd = false) {
        const slash = Parser.isWord(buffer, index, start);
        let offset2 = index;
        if (!slash.ok) {
            return {
                ok: false,
                offset1: index,
                offset2: index,
            };
        }
        if (endIsType) {
            const value = this.findType(buffer, slash.offset2 + 1, end, toEnd);
            if (!value.ok) {
                return {
                    ok: false,
                    offset1: index,
                    offset2: index,
                };
            }
            offset2 = value.offset1 - 1;
        }
        else {
            const value = Parser.findWord(buffer, slash.offset2 + 1, end, toEnd);
            if (!value.ok) {
                return {
                    ok: false,
                    offset1: index,
                    offset2: index,
                };
            }
            offset2 = value.offset1 - 1;
        }
        return {
            ok: true,
            offset1: slash.offset2 + 1,
            offset2,
        };
    }
    static isType(buffer, index, typeChar, reverse = false) {
        let length = 0;
        if (reverse) {
            for (let e = index; e > 0; e--) {
                if (!Parser.isChar(buffer, e, typeChar)) {
                    break;
                }
                length++;
            }
            if (length > 0) {
                return { offset1: index - length + 1, offset2: index, ok: true };
            }
        }
        else {
            for (let e = index; e < buffer.length; e++) {
                if (!Parser.isChar(buffer, e, typeChar)) {
                    break;
                }
                length++;
            }
            if (length > 0) {
                return { offset1: index, offset2: index + length - 1, ok: true };
            }
        }
        return { offset1: index, offset2: index, ok: false };
    }
    static isChar(buffer, index, array) {
        return array.includes(buffer.subarray(index, index + 1).getRaw()[0]);
    }
    static isWord(buffer, index, word, reverse = false) {
        let i = index;
        if (reverse) {
            for (let e = word.length - 1; e >= 0; e--) {
                const char = word[e];
                if (char !== buffer.raw[i--]) {
                    return { offset1: index, offset2: index, ok: false };
                }
            }
            return { offset1: i + 1, offset2: index, ok: true };
        }
        for (let e = 0; e < word.length; e++) {
            const char = word[e];
            if (buffer.raw[i++] !== char) {
                return { offset1: index, offset2: index, ok: false };
            }
        }
        return { offset1: index, offset2: i - 1, ok: true };
    }
    static findWord(buffer, index, word, toEnd = false) {
        let off2 = index;
        while (true) {
            const w = Parser.isWord(buffer, off2++, word);
            if (w.ok) {
                off2 = w.offset2;
                return {
                    ok: true,
                    offset1: w.offset1,
                    offset2: w.offset2,
                };
            }
            if (off2 === buffer.length) {
                if (toEnd) {
                    return {
                        ok: true,
                        offset1: w.offset1,
                        offset2: w.offset2,
                    };
                }
                return {
                    ok: false,
                    offset1: index,
                    offset2: index,
                };
            }
        }
    }
    static findType(buffer, index, type, toEnd = false) {
        let off2 = index;
        while (true) {
            const w = Parser.isType(buffer, off2++, type);
            if (w.ok) {
                off2 = w.offset2;
                return {
                    ok: true,
                    offset1: w.offset1,
                    offset2: w.offset2,
                };
            }
            if (off2 === buffer.length) {
                if (toEnd) {
                    return {
                        ok: true,
                        offset1: w.offset1,
                        offset2: w.offset2,
                    };
                }
                return {
                    ok: false,
                    offset1: index,
                    offset2: index,
                };
            }
        }
    }
    static getNumberByOffset(buffer, offset1, offset2) {
        return Number(buffer.subarray(offset1, offset2 + 1).toString());
    }
    getByte(offset) {
        return __classPrivateFieldGet(this, _Parser_doc, "f").buffer.raw[offset];
    }
    static isOperatorLetter(char) {
        return (char >= 65 && char <= 90)
            || (char >= 97 && char <= 122)
            || char === 42 || char === 39 || char === 34;
    }
    static readOperatorTag(buffer, index) {
        let offset2 = index;
        while (offset2 < buffer.length && Parser.isOperatorLetter(buffer.raw[offset2])) {
            offset2++;
        }
        const tag = String.fromCharCode(...buffer.raw.subarray(index, offset2));
        const operator = new PdfOperator({ tag });
        operator.raw = buffer.subarray(index, offset2);
        return {
            ok: true,
            offset1: index,
            offset2: offset2 - 1,
            value: operator,
        };
    }
    static readOperatorOrObject(buffer, xref, index) {
        if (index >= buffer.length) {
            return { ok: false };
        }
        const char = buffer.raw[index];
        if (Parser.isOperatorLetter(char)) {
            return Parser.readOperatorTag(buffer, index);
        }
        return Parser.read(buffer, xref, index);
    }
    static readOperator(buffer, xref, index) {
        const args = [];
        let offset = index;
        while (offset < buffer.length) {
            offset = Parser.skipWhiteSpaces(buffer, offset);
            const res = Parser.readOperatorOrObject(buffer, xref, offset);
            if (!res.ok) {
                break;
            }
            if (res.ok && res.value instanceof PdfOperator) {
                res.value.params = args;
                res.value.raw = buffer.subarray(index, res.offset2 + 1);
                return {
                    ok: res.ok,
                    offset1: index,
                    offset2: res.offset2 + 1,
                    value: res.value,
                };
            }
            args.push(res.value);
            offset = res.offset2 + 1;
        }
        return { ok: false };
    }
}
_Parser_doc = new WeakMap();

var _Writer_doc;
const HEADER = new Uint8Array([0x25, 0x50, 0x44, 0x46, 0x2d, 0x31, 0x2e, 0x35, 0x0a, 0x25, 0xff, 0xff, 0xff, 0xff]);
const FIRST_NULL_ELEMENT = new Uint8Array([0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x20, 0x36, 0x35, 0x35, 0x33, 0x35, 0x20, 0x66]);
class Writer {
    constructor(doc) {
        _Writer_doc.set(this, void 0);
        __classPrivateFieldSet(this, _Writer_doc, doc, "f");
    }
    isCorrectXRefType(typeXRef, xref) {
        if (xref instanceof XRefTable && typeXRef !== XRefType.XRefTable) {
            return false;
        }
        else if (xref instanceof XRefStream && typeXRef !== XRefType.XRefStream) {
            return false;
        }
        if (xref.prev) {
            return this.isCorrectXRefType(typeXRef, xref.prev);
        }
        return true;
    }
    save() {
        if (__classPrivateFieldGet(this, _Writer_doc, "f").xref.raw.length) {
            return __classPrivateFieldGet(this, _Writer_doc, "f").buffer.raw;
        }
        const buf = __classPrivateFieldGet(this, _Writer_doc, "f").buffer;
        if (!buf.length) {
            this.wHeader(buf);
        }
        this.wXRef(buf);
        return buf.raw;
    }
    wHeader(buf) {
        buf.append(HEADER);
        __classPrivateFieldGet(this, _Writer_doc, "f").header.raw = buf.subarray();
        buf.append(CharCodes.endLine);
    }
    wXRef(buf) {
        const targetXRefType = __classPrivateFieldGet(this, _Writer_doc, "f").xref instanceof XRefTable
            ? XRefType.XRefTable
            : XRefType.XRefStream;
        if (!this.isCorrectXRefType(targetXRefType, __classPrivateFieldGet(this, _Writer_doc, "f").xref)) {
            throw new Error("Документ содержит несколько типов структур");
        }
        if (__classPrivateFieldGet(this, _Writer_doc, "f").xref instanceof XRefStream) {
            this.wXRefStream(buf, __classPrivateFieldGet(this, _Writer_doc, "f").xref);
        }
        else {
            this.wXRefTable(buf, __classPrivateFieldGet(this, _Writer_doc, "f").xref);
        }
    }
    getAllObjects(xref) {
        let objects;
        if (xref instanceof XRefTable) {
            objects = this.getXRefTableObjects(xref);
        }
        else if (xref instanceof XRefStream) {
            objects = this.getXRefStreamObjects(xref);
        }
        else {
            throw new Error("getAllObjects: Неподдерживаемый тип XRef");
        }
        return objects;
    }
    removeFreeObjects(objects) {
        return new Map([...objects.entries()].filter((value) => value[1].type !== IndirectObjectType.free));
    }
    getXRefTableObjects(xref) {
        let objects = this.removeFreeObjects(xref.objects);
        if (xref.prev) {
            objects = new Map([...objects, ...this.getAllObjects(xref.prev)]);
        }
        return objects;
    }
    getXRefStreamObjects(xref) {
        let objects = this.removeFreeObjects(xref.objects);
        if (xref.prev) {
            objects = new Map([...objects, ...this.getAllObjects(xref.prev)]);
        }
        return objects;
    }
    wObjectStream(buf, objStream, mapObjects) {
        const parent = objStream.ref().parent;
        if (!parent || !(parent instanceof PdfIndirectObject)) {
            throw new Error("Неудалось сформировать IndirectObject для ObjectStream");
        }
        parent.offset = buf.length;
        const objects = new Map([...mapObjects.entries()].sort((a, b) => a[0] - b[0]));
        const bufStream = new PdfBuffer().begin();
        const bufValues = new PdfBuffer().begin();
        let index = 0;
        for (const [key, obj] of objects) {
            obj.index = index++;
            obj.objStream = parent.id;
            if (obj.value instanceof PdfStream) {
                throw new Error("ObjectStream не может содержать Stream объекты");
            }
            objStream.objects.set(key, obj.value);
            bufStream.append([
                PdfBuffer.numberToTextRaw(key),
                CharCodes.space,
                PdfBuffer.numberToTextRaw(!bufValues.length ? 0 : bufValues.length),
                CharCodes.space,
            ]);
            this.write(bufValues, obj.value, true, true);
            bufValues.append(CharCodes.endLine);
        }
        objStream.First = bufStream.length;
        objStream.N = objects.size;
        bufStream.append([
            bufValues.end(),
        ]);
        bufStream.end();
        objStream.set(Names.Filter, parent.doc.createName(Names.FlateDecode));
        objStream.value = bufStream.raw;
        this.writeObject(buf, parent);
    }
    wXRefStreamValue(xref) {
        const buf = new PdfBuffer().begin();
        const w1 = 1;
        const w2 = PdfBuffer.numberToRaw(xref.doc.buffer.length).length;
        const w3Value = PdfBuffer.numberToRaw(xref.Size).length;
        const w3 = w3Value < 2 ? 2 : w3Value;
        xref.W = new PdfArray({
            value: [
                new PdfNumber({ value: w1 }),
                new PdfNumber({ value: w2 }),
                new PdfNumber({ value: w3 }),
            ]
        });
        const objects = new Map([...xref.objects.entries()].sort((a, b) => a[0] - b[0]));
        if (!xref.prev) {
            buf.append([
                PdfBuffer.numberToRaw(0, w1),
                PdfBuffer.numberToRaw(0, w2),
                new Uint8Array(w3).fill(0xFF),
            ]);
        }
        for (const [, obj] of objects) {
            switch (obj.type) {
                case IndirectObjectType.free:
                    buf.append([
                        PdfBuffer.numberToRaw(0, w1),
                        PdfBuffer.numberToRaw(0, w2),
                        PdfBuffer.numberToRaw(obj.generation + 1, w3),
                    ]);
                    break;
                case IndirectObjectType.inUse:
                    buf.append([
                        PdfBuffer.numberToRaw(1, w1),
                        PdfBuffer.numberToRaw(obj.offset, w2),
                        PdfBuffer.numberToRaw(obj.generation, w3),
                    ]);
                    break;
                case IndirectObjectType.compressed:
                    buf.append([
                        PdfBuffer.numberToRaw(2, w1),
                        PdfBuffer.numberToRaw(obj.objStream, w2),
                        PdfBuffer.numberToRaw(obj.index, w3),
                    ]);
                    break;
                default:
                    throw new Error(`Неподдерживаемый тип IndirectObject ${obj.type}`);
            }
        }
        return buf.end().raw;
    }
    wXRefStream(buf, xref) {
        const objects = new Map([...xref.objects.entries()].sort((a, b) => a[0] - b[0]));
        if (!objects.size) {
            throw new Error("Метод добавления XRefStream без элементов не реализован");
        }
        const keys = [];
        if (!xref.prev) {
            keys.push(0);
        }
        keys.push(...objects.keys());
        const indexArray = new PdfArray();
        let count = 1;
        let firstKey = keys[0];
        for (let index = 1; index < keys.length; index++) {
            const key = keys[index];
            if (key === firstKey + count) {
                count++;
            }
            else {
                indexArray.push(new PdfNumber({ value: firstKey }), new PdfNumber({ value: count }));
                firstKey = key;
                count = 1;
            }
        }
        indexArray.push(new PdfNumber({ value: firstKey }), new PdfNumber({ value: count }));
        xref.Index = indexArray;
        buf.begin();
        const compressObj = new Map([...objects.entries()].filter((value) => value[1].type === IndirectObjectType.compressed));
        if (compressObj.size) {
            this.wObjectStream(buf, ObjectStream.create(xref), compressObj);
            xref.Index.get(xref.Index.value.length - 1, PdfNumber).value++;
        }
        const inuseObj = new Map([...objects.entries()].filter((value) => value[1].type === IndirectObjectType.inUse));
        for (const [, obj] of inuseObj) {
            obj.offset = buf.length;
            this.writeObject(buf, obj);
        }
        const xrefOffset = buf.length;
        xref.value = this.wXRefStreamValue(xref);
        const parent = xref.ref().parent;
        if (!parent || !(parent instanceof PdfIndirectObject)) {
            throw new Error("Неудалось сформировать IndirectObject для XRefStream");
        }
        parent.offset = xrefOffset;
        this.writeObject(buf, parent);
        buf.append([
            CharWords.startxref,
            PdfBuffer.numberToTextRaw(xrefOffset),
            CharWords.eof
        ], CharCodes.endLine);
        buf.append(CharCodes.endLine);
        buf.end();
        __classPrivateFieldGet(this, _Writer_doc, "f").buffer = buf;
        xref.raw = buf.subarray(xrefOffset);
    }
    wXRefTable(buf, xref) {
        const objects = new Map([...xref.objects.entries()].sort((a, b) => a[0] - b[0]));
        let tableLines = [CharWords.xref];
        let groupLines = [];
        let count = 0;
        let begin = 0;
        if (!xref.prev) {
            groupLines.push(FIRST_NULL_ELEMENT);
            count++;
        }
        buf.begin();
        for (const object of objects) {
            const obj = object[1];
            if (!groupLines.length) {
                begin = obj.id;
                count = 0;
            }
            obj.offset = buf.length;
            this.writeObject(buf, obj);
            if (obj.id === begin + count) {
                const line = this.createLineTable(obj);
                groupLines.push(line);
                count++;
            }
            else {
                tableLines.push(PdfBuffer.stringToRaw(`${begin} ${count}`));
                tableLines = tableLines.concat(groupLines);
                groupLines = [];
                begin = obj.id;
                count = 1;
                const line = this.createLineTable(obj);
                groupLines.push(line);
            }
        }
        tableLines.push(PdfBuffer.stringToRaw(`${begin} ${count}`));
        tableLines = tableLines.concat(groupLines);
        const xrefOffset = buf.length;
        buf.append(tableLines, CharWords.eol);
        buf.append(CharWords.eol);
        buf.append([CharWords.trailer, CharCodes.endLine]);
        this.wDictionary(buf, xref.trailer);
        buf.append(CharCodes.endLine);
        buf.append([
            CharWords.startxref,
            PdfBuffer.numberToTextRaw(xrefOffset),
            CharWords.eof
        ], CharCodes.endLine);
        buf.append(CharCodes.endLine);
        buf.end();
        __classPrivateFieldGet(this, _Writer_doc, "f").buffer = buf;
        xref.raw = buf.subarray(xrefOffset);
    }
    createLineTable(obj) {
        const line = new PdfBuffer().begin();
        line.append([
            PdfBuffer.numberToTextRaw(obj.offset, 10),
            PdfBuffer.numberToTextRaw(obj.generation, 5),
            obj.type === IndirectObjectType.free ? CharCodes.f : CharCodes.n,
        ], CharCodes.space);
        return line.end().raw;
    }
    writeObject(buf, obj) {
        return this.wIndObj(buf, obj);
    }
    wIndObj(buf, obj) {
        buf.begin();
        const offset = buf.length;
        const header = PdfBuffer.stringToRaw(`${obj.id} ${obj.generation} obj`);
        buf.append([header, CharCodes.endLine]);
        this.write(buf, obj.value, true);
        buf.append(CharCodes.endLine);
        buf.append([CharWords.endobj, CharCodes.endLine]);
        return buf.subarray(offset).getRaw();
    }
    write(buf, obj, writeAsNotRef = false, writeToBuffer = true) {
        buf.begin();
        const objOffset = buf.length;
        let raw;
        let primitive = true;
        if (!writeAsNotRef && obj.parent && obj.parent instanceof PdfIndirectObject) {
            raw = this.wRefObj(obj.parent);
            if (writeToBuffer) {
                buf.append(raw);
            }
            return raw;
        }
        if (obj instanceof PdfNull) {
            raw = PdfBuffer.stringToRaw("null");
        }
        else if (obj instanceof PdfName) {
            raw = this.wName(obj);
        }
        else if (obj instanceof PdfString) {
            raw = this.wString(obj);
        }
        else if (obj instanceof PdfNumber) {
            raw = this.wNumber(obj);
        }
        else if (obj instanceof PdfBoolean) {
            raw = this.wBoolean(obj);
        }
        else if (obj instanceof PdfIndirectObject) {
            raw = this.wRefObj(obj);
            if (writeToBuffer) {
                buf.append(raw);
            }
            return raw;
        }
        else if (obj instanceof PdfArray) {
            raw = this.wArray(buf, obj, writeToBuffer);
            primitive = false;
        }
        else if (obj instanceof PdfStream) {
            raw = this.wStream(buf, obj, writeToBuffer);
            primitive = false;
        }
        else if (obj instanceof PdfDictionary) {
            raw = this.wDictionary(buf, obj, writeToBuffer);
            primitive = false;
        }
        if (!raw) {
            throw new Error("write(): Неподдерживаемый тип");
        }
        if (writeToBuffer) {
            if (primitive) {
                buf.append(raw);
            }
            obj.raw = buf.subarray(objOffset, objOffset + raw.length);
        }
        return raw;
    }
    wDictionary(buf, obj, writeToBuffer = true) {
        const res = new PdfBuffer();
        res.append([CharWords.startDictionary, CharCodes.endLine]);
        buf.begin();
        if (writeToBuffer) {
            buf.append([CharWords.startDictionary, CharCodes.endLine]);
        }
        for (const item of obj.items) {
            const name = PdfBuffer.stringToRaw(`/${item[0]} `);
            if (writeToBuffer) {
                buf.append(name);
            }
            const value = this.write(buf, item[1], false, writeToBuffer);
            if (writeToBuffer) {
                buf.append(CharCodes.endLine);
            }
            res.append([name, value, CharCodes.endLine]);
        }
        if (writeToBuffer) {
            buf.append([CharWords.endDictionary]);
        }
        res.append([CharWords.endDictionary]);
        return res.raw;
    }
    wStream(buf, obj, writeToBuffer = true) {
        const res = new PdfBuffer().begin();
        if (obj.Length === -1) {
            obj.Length = obj.rawValue.byteLength;
        }
        const dictionary = this.wDictionary(buf, obj, writeToBuffer);
        buf.begin();
        if (writeToBuffer) {
            buf.append(CharCodes.endLine);
        }
        res.append([dictionary, CharCodes.endLine]);
        if (writeToBuffer) {
            buf.append([CharWords.stream, obj.rawValue, CharWords.endstream], CharCodes.endLine);
        }
        res.append([CharWords.stream, obj.rawValue, CharWords.endstream], CharCodes.endLine);
        return res.end().raw;
    }
    wArray(buf, obj, writeToBuffer = true) {
        const res = new PdfBuffer().begin();
        res.append([CharCodes.leftSquareBracket, CharCodes.space]);
        buf.begin();
        if (writeToBuffer) {
            buf.append([CharCodes.leftSquareBracket, CharCodes.space]);
        }
        for (const item of obj) {
            const raw = this.write(buf, item, false, writeToBuffer);
            if (writeToBuffer) {
                buf.append(CharCodes.space);
            }
            res.append([raw, CharCodes.space]);
        }
        if (writeToBuffer) {
            buf.append(CharCodes.rightSquareBracket);
        }
        return res.append(CharCodes.rightSquareBracket).end().raw;
    }
    wRefObj(obj) {
        return PdfBuffer.stringToRaw(`${obj.id} 0 R`);
    }
    wBoolean(obj) {
        return PdfBuffer.stringToRaw(String(obj.value));
    }
    wNumber(obj) {
        return Writer.numberToUint8(obj);
    }
    wName(obj) {
        return PdfBuffer.stringToRaw(`/${fromBinary(StringConverter.writeName(obj.value))}`);
    }
    wString(obj) {
        if (obj instanceof PdfHexString) {
            return Writer.hexToUint8(obj);
        }
        if (obj instanceof PdfLiteralString) {
            return Writer.literalToUint8(obj);
        }
        throw new Error("wString(): Неподдерживаемый формат строки");
    }
    static addPadding(value, padding) {
        return value.padEnd(padding, " ");
    }
    static numberToUint8(obj) {
        return PdfBuffer.stringToRaw(Writer.addPadding(obj.value.toString(), obj.padding));
    }
    static hexToUint8(obj) {
        return toBinary(Writer.addPadding(`<${StringConverter.writeHex(obj.value, true)}>`, obj.padding));
    }
    static literalToUint8(obj) {
        return toBinary(Writer.addPadding(`(${fromBinary(StringConverter.writeLiteral(obj.value))})`, obj.padding));
    }
}
_Writer_doc = new WeakMap();

class CIDFontWidthsConverter {
    static flatten(data) {
        const result = [];
        for (let i = 0; i < data.length; i++) {
            const first = data[i];
            const last = data[i + 1];
            const w = data[i + 2];
            if (typeof first === "number" && Array.isArray(last)) {
                for (const w of last) {
                    result.push(w);
                }
                i++;
            }
            else if (typeof first === "number" && typeof last === "number" && typeof w === "number") {
                for (let j = first; j <= last; j++) {
                    result.push(w);
                }
                i += 2;
            }
            else {
                throw new Error(`Неизвестный формат W-массива в позиции ${i}. Должен быть один из форматов: C [W1 W2… Wn] или C1 C2 W`);
            }
        }
        return result;
    }
    static expand(data) {
        const result = [];
        let i = 0;
        while (i < data.length) {
            const c1 = i;
            let w = data[i];
            let c2 = c1;
            while (i + 1 < data.length && data[i + 1] === w) {
                c2++;
                i++;
            }
            if (c1 === c2) {
                const widths = [w];
                while (i + 1 < data.length && data[i + 1] !== w && data[i + 1] !== data[i + 2]) {
                    i++;
                    w = data[i];
                    widths.push(w);
                }
                result.push(c1, widths);
            }
            else {
                result.push(c1, c2, w);
            }
            i++;
        }
        return result;
    }
    static toPdfArray(doc, data) {
        const array = doc.createArray();
        for (const entry of data) {
            if (Array.isArray(entry)) {
                array.push(this.toPdfArray(doc, entry));
            }
            else {
                array.push(doc.createNumber(Math.round(entry)));
            }
        }
        return array;
    }
}

var _Document_xref, _Document_pagesList;
class Document {
    constructor() {
        _Document_xref.set(this, void 0);
        _Document_pagesList.set(this, new Map());
        this.fonts = new Map();
        this.header = new Header();
        this.buffer = new PdfBuffer();
    }
    get xref() {
        if (__classPrivateFieldGet(this, _Document_xref, "f")) {
            return __classPrivateFieldGet(this, _Document_xref, "f");
        }
        throw new Error("Документ не содержит xref");
    }
    set xref(v) {
        __classPrivateFieldSet(this, _Document_xref, v, "f");
    }
    read(file) {
        this.buffer = new PdfBuffer(file);
        const reader = new Parser(this);
        this.header = reader.readHeader();
        this.xref = reader.readXRef();
    }
    save() {
        if (this.xref.raw.length || !this.xref.objects.size) {
            return this.buffer.raw;
        }
        const writer = new Writer(this);
        const res = writer.save();
        this.createUpdate();
        return res;
    }
    async copy(params = {}) {
        this.save();
        const copier = new Copier({ doc: Document.create(params.typeXRef) });
        await copier.copy(this, params.rules);
        return { doc: copier.doc, log: copier.logRules };
    }
    createUpdate() {
        if (!this.xref.raw.length) {
            return;
        }
        let update;
        if (this.xref instanceof XRefTable) {
            update = XRefTable.createByParams({ doc: this });
        }
        else {
            update = XRefStream.createByParams({ doc: this });
        }
        update.Size = this.xref.Size;
        update.prev = this.xref;
        if (this.xref instanceof PdfStream && this.xref.parent && this.xref.parent instanceof PdfIndirectObject) {
            update.trailer.Prev = this.xref.parent.offset;
        }
        else {
            update.trailer.Prev = this.xref.raw.offset;
        }
        update.trailer.ID = this.xref.trailer.ID;
        update.trailer.Info = this.xref.trailer.Info;
        update.trailer.Root = this.xref.trailer.Root;
        this.xref = update;
    }
    createIndirectObject(value, type) {
        this.createUpdate();
        const obj = new PdfIndirectObject({ xref: this.xref, id: this.xref.Size++, type });
        obj.value = value;
        value.parent = obj;
        this.xref.push(obj);
        return obj;
    }
    static create(xrefType = XRefType.XRefStream) {
        const doc = new Document();
        const xref = xrefType === XRefType.XRefTable ? new XRefTable() : new XRefStream();
        doc.xref = xref;
        xref.doc = doc;
        if (xref instanceof XRefStream) {
            xref.xref = xref;
            xref.trailer;
            xref.set(Names.Type, xref.doc.createName(Names.XRef));
        }
        else {
            xref.trailer = Trailer.create(xref);
        }
        xref.trailer.Root = Catalog.create(xref).ref();
        return doc;
    }
    addFont(fontData, name) {
        if (this.fonts.has(name)) {
            throw new Error(`Шрифт с именем ${name} уже существует в документе`);
        }
        const font = Fonts.getCustom(fontData);
        const fontStreamRef = this.createStream({ stream: font.fontData }).ref();
        const fontBBox = this.createArray();
        for (const val of font.fontBBox) {
            fontBBox.push(this.createNumber(Math.round(val)));
        }
        const fontDescriptorRef = this.createDictionary({
            Type: this.createName(Names.FontDescriptor),
            FontName: this.createName(name),
            Flags: this.createNumber(font.flags.value),
            FontBBox: fontBBox,
            ItalicAngle: this.createNumber(font.italicAngle),
            Ascent: this.createNumber(font.ascent),
            Descent: this.createNumber(font.descent),
            CapHeight: this.createNumber(font.capHeight),
            XHeight: this.createNumber(font.xHeight),
            StemV: this.createNumber(0),
        }).ref();
        if (font.font.cff) {
            fontDescriptorRef.set(Names.FontFile3, fontStreamRef);
        }
        else {
            fontDescriptorRef.set(Names.FontFile2, fontStreamRef);
        }
        const expandedW = CIDFontWidthsConverter.expand(font.widths);
        const w = CIDFontWidthsConverter.toPdfArray(this, expandedW);
        const cidFontDictRef = this.createDictionary({
            Type: this.createName(Names.Font),
            Subtype: this.createName(font.font.cff ? Names.CIDFontType0 : Names.CIDFontType2),
            CIDToGIDMap: this.createName(Names.Identity),
            BaseFont: this.createName(name),
            CIDSystemInfo: this.createDictionary({
                Registry: this.createLiteral(Names.Adobe),
                Ordering: this.createLiteral(Names.Identity),
                Supplement: this.createNumber(0),
            }),
            FontDescriptor: fontDescriptorRef,
            W: w,
        }).ref();
        const bfChars = this.createBfChars(font.glyphs());
        const cmap = this.createCmap(bfChars);
        const unicodeCMapRef = this.createStream({ stream: PdfBuffer.stringToRaw(cmap) }).ref();
        const dictionary = this.createDictionary({
            Type: this.createName(Names.Font),
            Subtype: this.createName(Names.Type0),
            BaseFont: this.createName(name),
            Encoding: this.createName(Names.IdentityH),
            DescendantFonts: this.createArray(cidFontDictRef),
            ToUnicode: unicodeCMapRef,
        }).ref();
        const unicode = new Map();
        for (const char of bfChars) {
            unicode.set(char[1], char[0]);
        }
        const fontObj = { unicode, dictionary };
        this.fonts.set(name, fontObj);
        return fontObj;
    }
    createBfChars(glyphs) {
        const bfChars = new Array(glyphs.length);
        for (let idx = 0, len = glyphs.length; idx < len; idx++) {
            const glyph = glyphs[idx];
            const id = glyph.id.toString(16).toUpperCase().padStart(4, "0");
            const unicode = glyph.codePoints[0].toString(16).toUpperCase().padStart(4, "0");
            bfChars[idx] = [id, unicode];
        }
        return bfChars;
    }
    createCmap(bfChars) {
        return `/CIDInit /ProcSet findresource begin
12 dict begin
begincmap
/CIDSystemInfo <</Registry (Adobe) /Ordering (UCS) /Supplement 0>> def
/CMapName /Adobe-Identity-UCS def
/CMapType 2 def
1 begincodespacerange
<0000> <ffff>
endcodespacerange
${bfChars.length} beginbfchar
<0000> <ffff>
${bfChars.map(([glyphId, codePoint]) => `<${glyphId}> <${codePoint}>`).join("\n")}
endbfchar
endcmap
CMapName currentdict
CMap defineresource pop
end
end
`;
    }
    findPagesList() {
        const pagesAr = this.findPageDict(this.xref.trailer.Root.pages);
        const mapPages = new Map();
        if (!pagesAr.length) {
            return mapPages;
        }
        for (let index = 0; index < pagesAr.length; index++) {
            mapPages.set(index + 1, pagesAr[index]);
        }
        __classPrivateFieldSet(this, _Document_pagesList, mapPages, "f");
        return __classPrivateFieldGet(this, _Document_pagesList, "f");
    }
    findPageDict(dict) {
        const type = dict.get(Names.Type, PdfName);
        switch (type.value) {
            case Names.Pages:
                {
                    const kids = dict.get(Names.Kids, PdfArray);
                    if (!kids.length) {
                        return [];
                    }
                    let pages = [];
                    for (let index = 0; index < kids.length; index++) {
                        const page = kids.get(index, PdfDictionary);
                        const ar = this.findPageDict(page);
                        pages = pages.concat(ar);
                    }
                    return pages;
                }
            case Names.Page:
                return [dict];
            default:
                throw new Error("findPageDict(): Неподдерживаемый тип страницы");
        }
    }
    findPage(numPage) {
        var _a;
        const page = __classPrivateFieldGet(this, _Document_pagesList, "f").get(numPage);
        if (page) {
            return page;
        }
        const pages = this.findPagesList();
        return (_a = pages.get(numPage)) !== null && _a !== void 0 ? _a : null;
    }
    getPagesList() {
        return this.findPagesList();
    }
    getPage(numPage) {
        const res = this.findPage(numPage);
        if (!res) {
            throw new Error(`Страница ${numPage} не найдена`);
        }
        return res;
    }
    createNull() {
        return PdfNull.create(this.xref);
    }
    createBoolean(v) {
        const res = PdfBoolean.create(this.xref);
        res.value = v;
        return res;
    }
    createNumber(v) {
        const res = PdfNumber.create(this.xref);
        res.value = v;
        return res;
    }
    createFlags(type, v = 0) {
        const res = type.create(this.xref);
        if (v) {
            res.value = v;
        }
        return res;
    }
    createName(v) {
        const res = PdfName.create(this.xref);
        res.value = v;
        return res;
    }
    createHexString(v) {
        const res = PdfHexString.create(this.xref);
        if (typeof v === "string") {
            res.value = v;
            return res;
        }
        let value = "";
        for (let i = 0; i < v.length; i++) {
            value += String.fromCharCode(v[i]);
        }
        res.value = value;
        return res;
    }
    createLiteral(v) {
        const res = PdfLiteralString.create(this.xref);
        if (typeof v === "string") {
            res.value = v;
            return res;
        }
        const t = new TextDecoder("ascii");
        res.value = t.decode(v);
        return res;
    }
    createArray(...objs) {
        const res = PdfArray.create(this.xref);
        res.push(...objs);
        return res;
    }
    createStream(params) {
        const res = PdfStream.create(this.xref);
        const { dict = {}, stream = new Uint8Array(), filters = [] } = params !== null && params !== void 0 ? params : {};
        for (const key in dict) {
            res.set(key, dict[key]);
        }
        res.filters.setNewFilters(...filters);
        res.value = stream;
        return res;
    }
    createDictionary(object = {}) {
        const res = PdfDictionary.create(this.xref);
        for (const key in object) {
            res.set(key, object[key]);
        }
        return res;
    }
    createFormattedDateTime(date = new Date) {
        const year = String(date.getUTCFullYear()).padStart(4, "0");
        const month = String(date.getUTCMonth() + 1).padStart(2, "0");
        const day = String(date.getUTCDate()).padStart(2, "0");
        const hours = String(date.getUTCHours()).padStart(2, "0");
        const mins = String(date.getUTCMinutes()).padStart(2, "0");
        const secs = String(date.getUTCSeconds()).padStart(2, "0");
        return `D:${year}${month}${day}${hours}${mins}${secs}Z`;
    }
    createImage(imageBuf) {
        const imageInfo = ImageAnalyzer.getImageInfo(imageBuf);
        const res = Image.create(this.xref);
        res.width = imageInfo.info.width;
        res.height = imageInfo.info.height;
        res.set(Names.ColorSpace, this.createName(imageInfo.info.colorSpace));
        res.set(Names.BitsPerComponent, this.createNumber(imageInfo.info.bitsPerComponent));
        switch (imageInfo.type) {
            case ImageTypes.JPEG:
                res.value = imageBuf;
                res.set(Names.Filter, this.createName(Names.DCTDecode));
                break;
            case ImageTypes.PNG:
                res.value = imageInfo.buf;
                if (imageInfo.info.alphaChannel) {
                    const sMask = Image.create(this.xref);
                    sMask.value = imageInfo.info.alphaChannel;
                    sMask.width = imageInfo.info.width;
                    sMask.height = imageInfo.info.height;
                    sMask.set(Names.ColorSpace, this.createName(Names.DeviceGray));
                    sMask.set(Names.BitsPerComponent, this.createNumber(8));
                    res.set("SMask", sMask.ref());
                }
                break;
            default:
                throw new Error("Неподдерживаемый тип изображения.");
        }
        return res;
    }
    createImageTransformationMatrix(imageParams, imageName) {
        let view = "";
        switch (imageParams.rotation) {
            case -90:
            case 270:
                view = `q\n0 -1 1 0 0 ${imageParams.width} cm\n${imageParams.width} 0 0 ${imageParams.height} 0 0 cm\n/${imageName} Do\nQ`;
                break;
            case 180:
            case -180:
                view = `q\n-1 0 0 -1 ${imageParams.width} ${imageParams.height} cm\n${imageParams.width} 0 0 ${imageParams.height} 0 0 cm\n/${imageName} Do\nQ`;
                break;
            case 90:
            case -270:
                view = `q\n0 1 -1 0 ${imageParams.height} 0 cm\n${imageParams.width} 0 0 ${imageParams.height} 0 0 cm\n/${imageName} Do\nQ`;
                break;
            default:
                view = `q\n1 0 0 1 0 0 cm\n${imageParams.width} 0 0 ${imageParams.height} 0 0 cm\n/${imageName} Do\nQ`;
        }
        return view;
    }
}
_Document_xref = new WeakMap(), _Document_pagesList = new WeakMap();

Registry.set(RegistryTypes.ObjectStream, ObjectStream);
Registry.set(RegistryTypes.PdfView, PdfView);
Registry.set(RegistryTypes.Parser, Parser);
Registry.set(RegistryTypes.Writer, Writer);
Registry.set(RegistryTypes.Copier, Copier);
Registry.set(RegistryTypes.PdfIndirectObject, PdfIndirectObject);
Registry.set(RegistryTypes.PdfDictionary, PdfDictionary);
Registry.set(RegistryTypes.PdfArray, PdfArray);

export { ASCII85Decode, ASCIIHexDecode, AnnotFlags, AnnotFlagsName, CIDFontWidthsConverter, Catalog, CharCodes, CharOperators, CharTypes, CharWords, ColorNames, Copier, CustomFont, Document, Encoding, FilterCodec, FlateDecode, FontFlags, Fonts, Header, Image, ImageAnalyzer, ImageTypes, IndirectObjectType, JpegInfo, Logger, Names, ObjectStream, Pages, Parser, PdfAnnotFlags, PdfArray, PdfBoolean, PdfBuffer, PdfComment, PdfDictionary, PdfFlags, PdfFontFlags, PdfHexString, PdfIndirectObject, PdfLiteralString, PdfName, PdfNull, PdfNumber, PdfObject, PdfOperator, PdfStream, PdfString, PdfView, PngInfo, Predictor, RawData, Registry, RegistryTypes, StringConverter, Trailer, Writer, XRefStream, XRefTable, XRefType, decodeString, ensure1ByteHex, escapeSpecialSymbols, formatHex, fromBase64, fromBinary, generateUUID, generateUniqueID, hasMoreThan1ByteChars, hasUtf16BeBOM, hasUtf8BOM, hexTo2ByteHex, hexToBinary, isEqualRaw, toBase64, toBinary, toUtf16Be, unescapeSpecialSymbols };
