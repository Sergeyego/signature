import * as syntax from "./syntax";
import type { Document } from "./document";
import { PdfBuffer } from "./internal";
import { Logger, Record } from "./logger";

export interface IImagePage {
  data: Uint8Array,
  width: number,
  height: number,
  rotation: number,
}

/**
 * Параметры, необходимые для создания экземпляра класса Copier.
 */
export interface CopierParams {
  /**
   * Документ в который будут копироваться элементы.
   */
  doc: Document;
}

/**
 * Правила копирования элементов PDF-документа.
 */
export interface Rules {
  /**
   * Правила исключения страниц. (Исключенные страницы преобразуются в изображения).
   */
  exclusion?: RulesExclusion,
  /**
   * Правила для удаления элементов.
   */
  delete?: RuleDelete[],
  /**
   * Правила для копирования элементов.
   */
  copy?: RuleCopy[],
}

/**
 * Правила исключения страниц из обычного копирования PDF-документа.
 */
export interface RulesExclusion {
  rules: RuleExclusion[],
  convert(doc: Document, numPages: number[]): Promise<Map<number, IImagePage>>,
}

/**
 * Правило исключения из обычного копирования страницы PDF документа.
 * Исключенная страница копируется через преобразование в изображение.
 */
export interface RuleExclusion extends RuleBase {
  /**
   * Проверяет, является ли данная страница той, которую нужно исключить.
   * @param obj - страница, которую необходимо проверить.
   * @returns Запись изменения в документе.
   */
  detect(obj: syntax.PdfDictionary): Promise<Record | null>,
}

/**
 * Правило удаления элемента из PDF-документа.
 */
export interface RuleDelete extends RuleBase {
  /**
   * Проверяет, является ли данный тип объекта тем, который нужно удалить.
   * @param obj - тип объекта, который необходимо проверить.
   * @returns Запись изменения в документе.
   */
  detect(obj: syntax.PdfObjectType): Promise<Record | null>,
}

/**
 * Правило копирования элемента из PDF-документа.
 */
export interface RuleCopy extends RuleBase {
  /**
   * Флаг, указывающий, что после применения данного правила, остальные правила игнорируются.
   */
  only: boolean,
  /**
   * Корректирует элемент при копировании.
   * @param doc - документ, в который копируются элементы.
   * @param obj - элемент, который необходимо скопировать.
   * @returns Запись изменения в документе.
   */
  correction(doc: Document, obj: syntax.PdfDictionary): Promise<Record | null>,
}

/**
 * Базовый интерфейс правил.
 */
export interface RuleBase {
  title: string;
  /**
   * Флаг, указывающий, что правило отключено.
   */
  disabled?: boolean;
}

export type RuleConstructor<T extends RuleBase = RuleBase> = new () => T;

type MapIO = Map<number, syntax.PdfIndirectObject | null>;

/**
 * Класс копирования из одного документа в другой или в новый.
 */
export class Copier {
  public doc: Document;
  private rules: Rules = {};
  private mapIO: MapIO = new Map();
  /**
   * Logger фиксирующий изменения в документе.
   */
  public logRules: Logger = new Logger();

  public constructor(params: CopierParams) {
    this.doc = params.doc;
  }

  public get data(): Uint8Array {
    return this.doc.save();
  }

  /**
   * Копирует документ из одного файла в другой или в новый.
   * @param inputFile - документ, который необходимо скопировать.
   * @param rules - правила копирования и удаления элементов.
   * @returns Скопированный документ.
   */
  public async copy(inputFile: Document, rules?: Rules): Promise<Document> {
    this.mapIO.clear();
    this.logRules.clear();

    if (rules) {
      this.rules = rules;
    }

    await this.copyTrailer(inputFile.xref.trailer);

    return this.doc;
  }

  /**
   * Копирование Trailer.
   * @param obj
   */
  private async copyTrailer(obj: syntax.Trailer) {
    await this.copyCatalog(obj.Root);
    if (obj.ID) {
      this.doc.xref.trailer.ID = obj.ID;
    }
  }

  /**
   * Копирование каталога. (Root)
   * @param obj
   */
  private async copyCatalog(obj: syntax.Catalog) {
    const root = this.doc.xref.trailer.Root;

    const pages = obj.get(syntax.Names.Pages, syntax.PdfDictionary);
    if (!(pages.parent && pages.parent instanceof syntax.PdfIndirectObject)) {
      throw new Error("Pages должен быть Indirect Object");
    }
    await this.copyPages(pages.parent);

    for (const [key, element] of obj.values) {
      if (key === syntax.Names.Pages) {
        continue;
      }
      const newElement = await this.copyIndirectObjectType(element);
      if (newElement) {
        root.set(key, newElement);
      }
    }
  }

  /**
   * Копирование страниц.
   * @param obj
   */
  private async copyPages(obj: syntax.PdfIndirectObject) {
    const pages = this.doc.xref.trailer.Root.pages;

    if (!pages.parent || !(pages.parent instanceof syntax.PdfIndirectObject)) {
      throw new Error("Ошибочное получение Pages.ID");
    }

    // Применение правил исключения.
    await this.pageExclusionRules(obj.doc);

    // Фиксируем в map соотношений.
    this.mapIO.set(obj.id, pages.parent);

    // Перебираем все элементы самого первого Pages.
    for (const [key, element] of (obj.value as syntax.Pages).values) {
      const newElement = await this.copyIndirectObjectType(element);
      if (newElement) {
        pages.set(key, newElement);
      }
    }
  }


  private copyPrimitiveObjectType(copingObj: syntax.PdfObjectType): syntax.PdfBoolean | syntax.PdfNumber | syntax.PdfString | syntax.PdfName | syntax.PdfNull {
    if (copingObj instanceof syntax.PdfBoolean) {
      return this.doc.createBoolean(copingObj.value);
    } else if (copingObj instanceof syntax.PdfNumber) {
      return this.doc.createNumber(copingObj.value);
    } else if (copingObj instanceof syntax.PdfLiteralString) {
      return this.doc.createLiteral(copingObj.value);
    } else if (copingObj instanceof syntax.PdfHexString) {
      return this.doc.createHexString(copingObj.value);
    } else if (copingObj instanceof syntax.PdfName) {
      return this.doc.createName(copingObj.value);
    } else if (copingObj instanceof syntax.PdfNull) {
      return this.doc.createNull();
    } else {
      throw new Error(`Ошибка: неподдерживаемый тип ${copingObj.constructor.name}`);
    }
  }

  private async copyObjectType(copingObj: syntax.PdfObjectType, targetObj: syntax.PdfObjectType): Promise<syntax.PdfObjectType | null> {
    if (copingObj instanceof syntax.PdfStream && targetObj instanceof syntax.PdfStream) {
      return this.copyPdfStream(copingObj, targetObj);
    } else if (copingObj instanceof syntax.PdfDictionary && targetObj instanceof syntax.PdfDictionary) {
      return this.copyPdfDictionary(copingObj, targetObj);
    } else if (copingObj instanceof syntax.PdfArray && targetObj instanceof syntax.PdfArray) {
      return this.copyPdfArray(copingObj, targetObj);
    } else {
      throw new Error(`Ошибка копирования: ${copingObj.constructor.name}`);
    }
  }

  private async copyPdfArray(obj: syntax.PdfArray, newObj: syntax.PdfArray): Promise<syntax.PdfArray | null> {
    for (const element of obj) {
      const newElement = await this.copyIndirectObjectType(element);
      if (newElement) {
        newObj.push(newElement);
      }
    }

    if (!newObj.length) {
      return null;
    }

    return newObj;
  }

  private async copyPdfStream(obj: syntax.PdfStream, newObj: syntax.PdfStream): Promise<syntax.PdfStream | null> {
    await this.copyPdfDictionary(obj, newObj);

    newObj.rawValue = obj.rawValue;

    return newObj;
  }

  private async copyPdfDictionary(obj: syntax.PdfDictionary, newObj: syntax.PdfDictionary): Promise<syntax.PdfDictionary | null> {
    // Правила копирования.
    await this.copyRules(this.doc, obj);

    for (const [key, element] of obj.values) {
      const newElement = await this.copyIndirectObjectType(element);
      if (newElement) {
        newObj.set(key, newElement);
      }
    }

    if (!newObj.values.size) {
      return null;
    }

    return newObj;
  }

  private async copyIndirectObjectType(obj: syntax.PdfIndirectObjectType): Promise<syntax.PdfIndirectObjectType | null> {
    let value: syntax.PdfIndirectObjectType;

    if (obj.parent instanceof syntax.PdfIndirectObject) {
      obj = obj.parent;
    }

    if (obj instanceof syntax.PdfIndirectObject) {
      // Если уже копировали.
      if (this.mapIO.has(obj.id)) {
        const newIO = this.mapIO.get(obj.id);
        if (newIO === undefined) {
          throw new Error("Ошибочная запись в mapIO");
        }

        return newIO;
      }

      value = obj.value;
      this.mapIO.set(obj.id, null);
    } else {
      value = obj;
    }

    // Правила на удаление объектов.
    if (await this.deletionRules(value)) {
      return null;
    }

    // Создаем болванку.
    let newObj: syntax.PdfObjectType;
    if (value instanceof syntax.PdfStream) {
      newObj = this.doc.createStream();
    } else if (value instanceof syntax.PdfDictionary) {
      newObj = this.doc.createDictionary();
    } else if (value instanceof syntax.PdfArray) {
      newObj = this.doc.createArray();
    } else {
      newObj = this.copyPrimitiveObjectType(value);
    }

    if (obj instanceof syntax.PdfIndirectObject) {
      // Создаем Indirect Object с болванкой.
      const newIO = this.doc.createIndirectObject(newObj);
      this.mapIO.set(obj.id, newIO);
    }

    // Заполняем болванку.
    if (value instanceof syntax.PdfStream || value instanceof syntax.PdfDictionary || value instanceof syntax.PdfArray) {
      await this.copyObjectType(value, newObj);
    }

    return newObj;
  }

  /**
   * Перебирает и применяет правила исключения к страницам документа.
   * @param doc
   * @returns
   */
  private async pageExclusionRules(doc: Document) {
    if (!this.rules.exclusion) {
      return;
    }

    const list = doc.getPagesList();
    const keysBadPages: number[] = [];

    for (const [keyPage, value] of list) {
      for (const rule of this.rules.exclusion.rules) {
        if (rule.disabled) {
          continue;
        }
        const record = await rule.detect(value);
        if (record) {
          keysBadPages.push(keyPage);

          record[syntax.Names.Page] = keyPage;
          this.logRules.addValue(rule.title, record);

          break;
        }
      }
    }

    // Получаем изображения исключенных страниц.
    const images = await this.rules.exclusion.convert(doc, keysBadPages);

    // Заменяем исключенные страницы на изображения.
    for (const keyPage of keysBadPages) {
      const pageInfo = images.get(keyPage);
      if (!pageInfo) {
        throw new Error("Информация о странице не найдена");
      }

      const page = list.get(keyPage);
      if (!page) {
        throw new Error("Страница не найдена в списке");
      }

      const image = doc.createImage(pageInfo.data);
      const uuid = "img-1";

      page.set(syntax.Names.Contents, doc.createArray(
        doc.createStream({
          stream: PdfBuffer.stringToRaw(
            doc.createImageTransformationMatrix(pageInfo, uuid)
          )
        }).ref()),
      );
      page.set(syntax.Names.Resources, doc.createDictionary({
        XObject: doc.createDictionary({ [uuid]: image.ref() })
      }));
    }
  }

  /**
   * Перебирает и применяет правила удаления к obj.
   * @param obj
   * @returns
   */
  private async deletionRules(obj: syntax.PdfIndirectObjectType): Promise<boolean> {
    if (!this.rules.delete) {
      return false;
    }

    let value: syntax.PdfObjectType;
    let id = 0;

    if (obj instanceof syntax.PdfIndirectObject) {
      value = obj.value;
      id = obj.id;
    } else {
      value = obj;
      if (obj.parent instanceof syntax.PdfIndirectObject) {
        id = obj.parent.id;
      }
    }

    for (const rule of this.rules.delete) {
      if (rule.disabled) {
        continue;
      }
      const record = await rule.detect(value);
      if (record) {
        record[syntax.Names.ID] = id;
        this.logRules.addValue(rule.title, record);

        return true;
      }
    }

    return false;
  }

  /**
   * Перебирает и применяет правила копирования к obj.
   * @param doc
   * @param obj
   * @returns
   */
  private async copyRules(doc: Document, obj: syntax.PdfDictionary) {
    if (!this.rules.copy) {
      return;
    }

    for (const rule of this.rules.copy) {
      if (rule.disabled) {
        continue;
      }
      const record = await rule.correction(doc, obj);
      if (record) {
        this.logRules.addValue(rule.title, record);
        if (rule.only) {
          return;
        }
      }
    }
  }
}
