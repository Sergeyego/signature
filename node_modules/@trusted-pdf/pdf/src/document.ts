import * as syntax from "./syntax";

import { Filter, PdfBuffer, ImageAnalyzer, ImageTypes, Fonts } from "./internal";
import { Parser } from "./parser";
import { Writer } from "./writer";
import { Copier, IImagePage, type Rules } from "./copier";
import { Logger } from "./logger";
import { CIDFontWidthsConverter } from "./font";

export interface IDocumentCreateStreamParams {
  dict?: Record<string, syntax.PdfIndirectObjectType>;
  stream?: Uint8Array;
  filters?: Filter[];
}

export interface CopyResponse {
  doc: Document;
  log: Logger;
}

export interface CopyParams {
  /**
   * Массив правил копирования.
   */
  rules?: Rules;
  /**
   * Тип структуры XRef.
   */
  typeXRef?: syntax.XRefType;
}

export interface Font {
  unicode: Map<string, string>;
  dictionary: syntax.PdfDictionary;
}

/**
 * Карта страниц с ключом по номеру странниц.
 * Номер страниц начинается с 1.
 */
export type PagesList = ReadonlyMap<number, syntax.PdfDictionary>;

export class Document {
  #xref?: syntax.XRef;
  #pagesList: PagesList = new Map();

  public fonts: Map<string, Font> = new Map();
  public header: syntax.Header = new syntax.Header();
  public buffer = new PdfBuffer();

  public get xref(): syntax.XRef {
    if (this.#xref) {
      return this.#xref;
    }
    throw new Error("Документ не содержит xref");
  }

  public set xref(v: syntax.XRef) {
    this.#xref = v;
  }

  /**
   * Чтение и распознание PDF документа.
   * @param file PDF документ.
   */
  public read(file: Uint8Array): void {
    // Заполнение внутреннего буфера.
    this.buffer = new PdfBuffer(file);

    // Распознание документа.
    const reader = new Parser(this);
    this.header = reader.readHeader();
    this.xref = reader.readXRef();
  }

  /**
   * Сохранение текущих изменений, добавляя новый блок EOF.
   * Если изменений нет то сохранение не выполняется.
   * @returns Возвращает RAW всего документа.
   */
  public save(): Uint8Array {
    // Возвращаем текущий RAW документа если:
    // 1. последний XRef уже сохранен (имеет свой RAW)
    // 2. в последнем XRef нет новых или измененных объектов.
    if (this.xref.raw.length || !this.xref.objects.size) {
      return this.buffer.raw;
    }

    // Генерируем RAW и записываем в объекты.
    const writer = new Writer(this);

    const res = writer.save();

    // Создаем новый update.
    this.createUpdate();

    return res;
  }

  /**
   * Создает копию текущего документа согласно указанным правилам.
   *
   * @returns Возвращает новый документ.
   */
  public async copy(params: CopyParams = {}): Promise<CopyResponse> {
    this.save();

    const copier = new Copier({ doc: Document.create(params.typeXRef) });

    await copier.copy(this, params.rules);

    return { doc: copier.doc, log: copier.logRules };
  }

  /**
   * Создает новый XRef если предыдущий сохранен.
   * @returns
   */
  public createUpdate(): void {
    // Если в последнем XRef нет RAW то создавать новый XRef не нужно.
    if (!this.xref.raw.length) {
      return;
    }

    // Создаем новый XRef и заполняем обязательные поля.
    let update: syntax.XRef;
    if (this.xref instanceof syntax.XRefTable) {
      update = syntax.XRefTable.createByParams({ doc: this });
    } else {
      update = syntax.XRefStream.createByParams({ doc: this });
    }

    update.Size = this.xref.Size;
    update.prev = this.xref;

    // Формируем trailer.
    if (this.xref instanceof syntax.PdfStream && this.xref.parent && this.xref.parent instanceof syntax.PdfIndirectObject) {
      update.trailer.Prev = this.xref.parent.offset;
    } else {
      update.trailer.Prev = this.xref.raw.offset;
    }

    update.trailer.ID = this.xref.trailer.ID;
    update.trailer.Info = this.xref.trailer.Info;
    update.trailer.Root = this.xref.trailer.Root;

    this.xref = update;
  }

  /**
   * Создание и добавление Indirect Object в документ.
   * @param value Содержимое Indirect Object.
   * @param type Указывает тип Indirect Object: compressed, in-use, free.
   * @returns
   */
  public createIndirectObject(value: syntax.PdfObject, type?: syntax.IndirectObjectType): syntax.PdfIndirectObject {
    // Проверяем нужно ли создать новый update.
    this.createUpdate();

    // Создаем Indirect Object.
    const obj = new syntax.PdfIndirectObject({ xref: this.xref, id: this.xref.Size++, type });
    obj.value = value as syntax.PdfObjectType;
    value.parent = obj;

    // Добавляем Indirect Object в последний XRef.
    this.xref.push(obj);

    return obj;
  }

  /**
   * Создание пустого PDF документа с двумя объектами: Root и Pages.
   * @param xrefType Указывает тип структуры XRef.
   * @returns
   */
  public static create(xrefType: syntax.XRefType = syntax.XRefType.XRefStream): Document {
    // Создаем документ.
    const doc = new Document();

    // Создаем XRef. Используем new так как необходимо вручную настроить все взаимосвязи.
    const xref = xrefType === syntax.XRefType.XRefTable ? new syntax.XRefTable() : new syntax.XRefStream();

    // Связываем документ с XRef.
    doc.xref = xref;
    xref.doc = doc;

    if (xref instanceof syntax.XRefStream) {
      // Так как XRefStream наследник от PdfStream у него должен быть xref.
      xref.xref = xref;
      // Trailer это часть xref, создаем внутренние зависимости через вызов.
      xref.trailer;
      xref.set(syntax.Names.Type, xref.doc.createName(syntax.Names.XRef));
    } else {
      xref.trailer = syntax.Trailer.create(xref);
    }

    // Инициализируем trailer в XRef.
    xref.trailer.Root = syntax.Catalog.create(xref).ref();

    return doc;
  }

  /**
   * Добавление шрифта в документ.
   * @param fontData
   * @param name
   * @returns
   */
  public addFont(fontData: Uint8Array, name: string): Font {
    if (this.fonts.has(name)) {
      throw new Error(`Шрифт с именем ${name} уже существует в документе`);
    }

    const font = Fonts.getCustom(fontData);

    const fontStreamRef = this.createStream({ stream: font.fontData }).ref();

    const fontBBox = this.createArray();
    for (const val of font.fontBBox) {
      fontBBox.push(this.createNumber(Math.round(val)));
    }

    const fontDescriptorRef = this.createDictionary({
      Type: this.createName(syntax.Names.FontDescriptor),
      FontName: this.createName(name),
      Flags: this.createNumber(font.flags.value),
      FontBBox: fontBBox,
      ItalicAngle: this.createNumber(font.italicAngle),
      Ascent: this.createNumber(font.ascent),
      Descent: this.createNumber(font.descent),
      CapHeight: this.createNumber(font.capHeight),
      XHeight: this.createNumber(font.xHeight),
      StemV: this.createNumber(0),
    }).ref();
    if (font.font.cff) {
      fontDescriptorRef.set(syntax.Names.FontFile3, fontStreamRef);
    } else {
      fontDescriptorRef.set(syntax.Names.FontFile2, fontStreamRef);
    }

    // Создаем W-массив.
    const expandedW = CIDFontWidthsConverter.expand(font.widths);
    const w = CIDFontWidthsConverter.toPdfArray(this, expandedW);

    const cidFontDictRef = this.createDictionary({
      Type: this.createName(syntax.Names.Font),
      Subtype: this.createName(font.font.cff ? syntax.Names.CIDFontType0 : syntax.Names.CIDFontType2),
      CIDToGIDMap: this.createName(syntax.Names.Identity),
      BaseFont: this.createName(name),
      CIDSystemInfo: this.createDictionary({
        Registry: this.createLiteral(syntax.Names.Adobe),
        Ordering: this.createLiteral(syntax.Names.Identity),
        Supplement: this.createNumber(0),
      }),
      FontDescriptor: fontDescriptorRef,
      W: w,
    }).ref();

    const bfChars = this.createBfChars(font.glyphs());
    const cmap = this.createCmap(bfChars);
    const unicodeCMapRef = this.createStream({ stream: PdfBuffer.stringToRaw(cmap) }).ref();

    const dictionary = this.createDictionary({
      Type: this.createName(syntax.Names.Font),
      Subtype: this.createName(syntax.Names.Type0),
      BaseFont: this.createName(name),
      Encoding: this.createName(syntax.Names.IdentityH),
      DescendantFonts: this.createArray(cidFontDictRef),
      ToUnicode: unicodeCMapRef,
    }).ref();

    const unicode = new Map();
    for (const char of bfChars) {
      unicode.set(char[1], char[0]);
    }

    const fontObj = { unicode, dictionary };
    this.fonts.set(name, fontObj);

    return fontObj;
  }

  private createBfChars(glyphs: fontkit.Glyph[]) {
    const bfChars: string[][] = new Array(glyphs.length);
    for (let idx = 0, len = glyphs.length; idx < len; idx++) {
      const glyph = glyphs[idx];

      const id = glyph.id.toString(16).toUpperCase().padStart(4, "0");
      const unicode = glyph.codePoints[0].toString(16).toUpperCase().padStart(4, "0");

      bfChars[idx] = [id, unicode];
    }

    return bfChars;
  }

  private createCmap(bfChars: string[][]) {
    return `/CIDInit /ProcSet findresource begin
12 dict begin
begincmap
/CIDSystemInfo <</Registry (Adobe) /Ordering (UCS) /Supplement 0>> def
/CMapName /Adobe-Identity-UCS def
/CMapType 2 def
1 begincodespacerange
<0000> <ffff>
endcodespacerange
${bfChars.length} beginbfchar
<0000> <ffff>
${bfChars.map(([glyphId, codePoint]) => `<${glyphId}> <${codePoint}>`).join("\n")}
endbfchar
endcmap
CMapName currentdict
CMap defineresource pop
end
end
`;
  }

  //#region Pages
  /**
   * Поиск всех страниц документа.
   * @returns Возвращает map страниц с ключом по номеру страниц. Страницы в документе начинаются с 1.
   */
  private findPagesList(): PagesList {
    // Поиск всех страниц в рекурсии.
    const pagesAr = this.findPageDict(this.xref.trailer.Root.pages);

    // Создаем карту страниц с ключом по номеру страницы.
    const mapPages: Map<number, syntax.PdfDictionary> = new Map();

    // Если страницы не найдены то возвращаем null.
    if (!pagesAr.length) {
      return mapPages;
    }

    // Заполняем карту найденными страницами.
    for (let index = 0; index < pagesAr.length; index++) {
      mapPages.set(index + 1, pagesAr[index]);
    }

    this.#pagesList = mapPages;

    return this.#pagesList;
  }

  /**
   * Поиск всех страниц в документе. Рекурсивный метод.
   * Страницы в документе начинаются с 1.
   * @param dict
   * @returns
   */
  private findPageDict(dict: syntax.PdfDictionary): syntax.PdfDictionary[] {
    // Проверяем тип Dictionary.
    const type = dict.get(syntax.Names.Type, syntax.PdfName);
    switch (type.value) {
      // Каталог страниц.
      case syntax.Names.Pages:
        {
          // Получаем массив потомков.
          const kids = dict.get(syntax.Names.Kids, syntax.PdfArray);

          // Если список пуст то выходим.
          if (!kids.length) {
            return [];
          }

          let pages: syntax.PdfDictionary[] = [];

          // Перебираем всех потомков с запуском рекурсии.
          for (let index = 0; index < kids.length; index++) {
            const page = kids.get(index, syntax.PdfDictionary);
            const ar = this.findPageDict(page);

            // Все найденные страницы объединяем в один массив.
            pages = pages.concat(ar);
          }

          return pages;
        }
      // Страница.
      case syntax.Names.Page:
        return [dict];
      default:
        throw new Error("findPageDict(): Неподдерживаемый тип страницы");
    }
  }

  /**
   * Поиск страницы по номеру.
   * @param numPage Номер страницы. Страницы в документе начинаются с 1.
   * @returns
   */
  public findPage(numPage: number): syntax.PdfDictionary | null {
    // Проверяем в текущем списке страниц.
    const page = this.#pagesList.get(numPage);
    if (page) {
      return page;
    }

    // Выполняем повторный поиск страниц по всему документу.
    const pages = this.findPagesList();

    return pages.get(numPage) ?? null;
  }

  /**
   * Получение всех страниц документа.
   * @returns Возвращает map страниц с ключом по номеру страниц. Страницы в документе начинаются с 1.
   */
  public getPagesList(): PagesList {
    return this.findPagesList();
  }

  /**
   * Получение страницы по номеру.
   * @param numPage Номер страницы. Страницы в документе начинаются с 1.
   * @returns
   */
  public getPage(numPage: number): syntax.PdfDictionary {
    const res = this.findPage(numPage);

    if (!res) {
      throw new Error(`Страница ${numPage} не найдена`);
    }

    return res;
  }
  //#endregion

  //#region Create Objects
  /**
   * Создает createNull.
   * @returns
   */
  public createNull(): syntax.PdfNull {
    return syntax.PdfNull.create(this.xref);
  }

  /**
   * Создает PdfBoolean со значением v.
   * @param v PdfBoolean значение.
   * @returns
   */
  public createBoolean(v: boolean): syntax.PdfBoolean {
    const res = syntax.PdfBoolean.create(this.xref);
    res.value = v;

    return res;
  }

  /**
   * Создает PdfNumber со значением v.
   * @param v PdfNumber значение.
   * @returns
   */
  public createNumber(v: number): syntax.PdfNumber {
    const res = syntax.PdfNumber.create(this.xref);
    res.value = v;

    return res;
  }

  /**
   * Создает объект для работы со флагами типа type со значением v.
   * @param type
   * @param v
   * @returns
   */
  public createFlags<T extends syntax.PdfNumber>(type: syntax.PdfObjectConstructor<T>, v = 0): T {
    const res = type.create(this.xref);
    if (v) {
      res.value = v;
    }

    return res;
  }

  /**
   * Создает PdfNumber со значением v.
   * @param v PdfNumber значение.
   * @returns
   */
  public createName(v: string): syntax.PdfName {
    const res = syntax.PdfName.create(this.xref);
    res.value = v;

    return res;
  }

  /**
   * Создает PdfHexString со значением v.
   * @param v PdfHexString значение.
   * @returns
   */
  public createHexString(v: string | Uint8Array): syntax.PdfHexString {
    const res = syntax.PdfHexString.create(this.xref);
    if (typeof v === "string") {
      res.value = v;

      return res;
    }

    let value = "";
    for (let i = 0; i < v.length; i++) {
      value += String.fromCharCode(v[i]);
    }

    res.value = value;

    return res;
  }

  /**
   * Создает PdfLiteralString со значением v.
   * @param v PdfLiteralString значение.
   * @returns
   */
  public createLiteral(v: string | Uint8Array): syntax.PdfLiteralString {
    const res = syntax.PdfLiteralString.create(this.xref);
    if (typeof v === "string") {
      res.value = v;

      return res;
    }

    const t = new TextDecoder("ascii");
    res.value = t.decode(v);

    return res;
  }

  /**
   * Создает PdfArray c вложенными объектами.
   * @param object Вкладываемые объекты.
   * @returns
   */
  public createArray(...objs: syntax.PdfIndirectObjectType[]): syntax.PdfArray {
    const res = syntax.PdfArray.create(this.xref);
    res.push(...objs);

    return res;
  }

  /**
   * Создает PdfStream.
   * @param params Парамеры создания PdfStream.
   * @returns
   */
  public createStream(params?: IDocumentCreateStreamParams): syntax.PdfStream {
    const res = syntax.PdfStream.create(this.xref);

    const { dict = {}, stream = new Uint8Array(), filters = [] } = params ?? {};

    for (const key in dict) {
      res.set(key, dict[key]);
    }

    res.filters.setNewFilters(...filters);

    res.value = stream;

    return res;
  }

  /**
   * Создает PdfDictionary c вложенными объектами.
   * @param object Вкладываемые объекты.
   * @returns
   */
  public createDictionary(object: Record<string, syntax.PdfIndirectObjectType> = {}): syntax.PdfDictionary {
    const res = syntax.PdfDictionary.create(this.xref);
    for (const key in object) {
      res.set(key, object[key]);
    }

    return res;
  }

  /**
   * Возвращает время в формате D:20230215164332Z.
   * По умолчанию возвращает текущее время.
   * @param date
   * @returns
   */
  public createFormattedDateTime(date = new Date): string {
    const year = String(date.getUTCFullYear()).padStart(4, "0");
    const month = String(date.getUTCMonth() + 1).padStart(2, "0");
    const day = String(date.getUTCDate()).padStart(2, "0");
    const hours = String(date.getUTCHours()).padStart(2, "0");
    const mins = String(date.getUTCMinutes()).padStart(2, "0");
    const secs = String(date.getUTCSeconds()).padStart(2, "0");

    return `D:${year}${month}${day}${hours}${mins}${secs}Z`;
  }

  /**
   * Создает изображение.
   * @param imageBuf
   * @returns
   */
  public createImage(imageBuf: Uint8Array): syntax.Image {
    // Получаем данные изображения.
    const imageInfo = ImageAnalyzer.getImageInfo(imageBuf);

    // Создаем изображение.
    const res = syntax.Image.create(this.xref);

    // Заполняем общие поля для изображения.
    res.width = imageInfo.info.width;
    res.height = imageInfo.info.height;
    res.set(syntax.Names.ColorSpace, this.createName(imageInfo.info.colorSpace));
    res.set(syntax.Names.BitsPerComponent, this.createNumber(imageInfo.info.bitsPerComponent));

    switch (imageInfo.type) {
      case ImageTypes.JPEG:
        res.value = imageBuf;
        res.set(syntax.Names.Filter, this.createName(syntax.Names.DCTDecode));
        break;
      case ImageTypes.PNG:
        res.value = imageInfo.buf;

        if (imageInfo.info.alphaChannel) {
          const sMask = syntax.Image.create(this.xref);

          sMask.value = imageInfo.info.alphaChannel;
          sMask.width = imageInfo.info.width;
          sMask.height = imageInfo.info.height;

          sMask.set(syntax.Names.ColorSpace, this.createName(syntax.Names.DeviceGray));
          sMask.set(syntax.Names.BitsPerComponent, this.createNumber(8));

          res.set("SMask", sMask.ref());
        }
        break;
      default:
        throw new Error("Неподдерживаемый тип изображения.");
    }

    return res;
  }
  //#endregion

 /**
   * Создает матрицу трансформации изображения.
   * @param pageInfo
   * @param imageName
   * @returns
   */
 public createImageTransformationMatrix (
    imageParams: Pick<IImagePage, "width" | "height"| "rotation">,
    imageName: string
  ): string {
    let view = "";
    switch (imageParams.rotation) {
      case -90:
      case 270:
        view = `q\n0 -1 1 0 0 ${imageParams.width} cm\n${imageParams.width} 0 0 ${imageParams.height} 0 0 cm\n/${imageName} Do\nQ`;
        break;
      case 180:
      case -180:
        view = `q\n-1 0 0 -1 ${imageParams.width} ${imageParams.height} cm\n${imageParams.width} 0 0 ${imageParams.height} 0 0 cm\n/${imageName} Do\nQ`;
        break;
      case 90:
      case -270:
        view = `q\n0 1 -1 0 ${imageParams.height} 0 cm\n${imageParams.width} 0 0 ${imageParams.height} 0 0 cm\n/${imageName} Do\nQ`;
        break;
      default:
        view = `q\n1 0 0 1 0 0 cm\n${imageParams.width} 0 0 ${imageParams.height} 0 0 cm\n/${imageName} Do\nQ`;
    }

    return view;
  }
}
