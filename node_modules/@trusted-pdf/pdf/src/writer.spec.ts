import * as assert from "node:assert";
import * as pdf from "./index";

import { PdfObjectType } from "./syntax/objects/object_type";
import { Writer } from "./writer";

describe("Writer", () => {
  describe("Save(XRefTable)", () => {
    it("save empty document", () => {
      const doc = pdf.Document.create(pdf.XRefType.XRefTable);
      doc.save();

      // Документ должен создаваться без страниц.
      assert.equal(doc.getPagesList().size, 0);
      // В созданном пустом документе не должно быть prev xref.
      assert.ok(!doc.xref.prev?.prev);
      // В документе должны быть созданы Catalog и Pages и нулевой объект.
      assert.equal(doc.xref.Size, 3);

      // Проверяем в документе Catalog.
      const catalog = doc.xref.trailer.Root;
      assert.equal(catalog.get(pdf.Names.Type, pdf.PdfName).value, pdf.Names.Catalog);

      // Проверяем в документе Root.
      const pages = catalog.pages;
      assert.equal(pages.get(pdf.Names.Type, pdf.PdfName).value, pdf.Names.Pages);
      assert.equal(pages.get(pdf.Names.Count, pdf.PdfNumber).value, 0);
      assert.equal(pages.get(pdf.Names.Kids, pdf.PdfArray).value.length, 0);
    });

    it("save document with 1 element", () => {
      const doc = pdf.Document.create(pdf.XRefType.XRefTable);
      doc.createNumber(1).ref();
      doc.save();

      // В документе должны быть созданы Catalog, Pages, нулевой объект и Числовой объект.
      assert.equal(doc.xref.Size, 4);

      const obj = doc.xref.getIndirectObject(3).value;
      assert.ok(obj instanceof pdf.PdfNumber);
      assert.equal(obj.value, 1);
    });

    it("save document with 1 update", () => {
      const doc = pdf.Document.create(pdf.XRefType.XRefTable);
      doc.save();

      doc.createNumber(1).ref();
      doc.save();

      // В последнем XRef проверяем size.
      assert.equal(doc.xref.Size, 4);

      // Проверяем добавленный элемент.
      const obj = doc.xref.getIndirectObject(3).value;
      assert.ok(obj instanceof pdf.PdfNumber);
      assert.equal(obj.value, 1);

      // Проверяем последний сохраненный XRef.
      const xref = doc.xref.prev;
      assert.ok(xref);
      // Проверяем что XRef есть ссылка на первый XRef.
      assert.ok(xref.prev);
      // В последнем XRef должен быть только 1 элемент.
      assert.equal(xref.objects.size, 1);
    });
  });

  describe("Save(XRefStream)", () => {
    it("save empty document", () => {
      const doc = pdf.Document.create();
      doc.save();

      // Документ должен создаваться без страниц.
      assert.equal(doc.getPagesList().size, 0);
      // В созданном пустом документе не должно быть prev xref.
      assert.ok(!doc.xref.prev?.prev);
      // В документе должны быть созданы Catalog и Pages и нулевой объект.
      assert.equal(doc.xref.Size, 4);

      // Проверяем в документе Catalog.
      const catalog = doc.xref.trailer.Root;
      assert.equal(catalog.get(pdf.Names.Type, pdf.PdfName).value, pdf.Names.Catalog);

      // Проверяем в документе Root.
      const pages = catalog.pages;
      assert.equal(pages.get(pdf.Names.Type, pdf.PdfName).value, pdf.Names.Pages);
      assert.equal(pages.get(pdf.Names.Count, pdf.PdfNumber).value, 0);
      assert.equal(pages.get(pdf.Names.Kids, pdf.PdfArray).value.length, 0);
    });

    it("save empty document with filter", () => {
      const doc = pdf.Document.create();

      assert.ok(doc.xref instanceof pdf.XRefStream);
      doc.xref.filters.setNewFilters({ name: pdf.Names.FlateDecode });

      doc.save();

      // Документ должен создаваться без страниц.
      assert.equal(doc.getPagesList().size, 0);
      // В созданном пустом документе не должно быть prev xref.
      assert.ok(!doc.xref.prev?.prev);
      // В документе должны быть созданы Catalog и Pages и нулевой объект.
      assert.equal(doc.xref.Size, 4);

      // Проверяем в документе Catalog.
      const catalog = doc.xref.trailer.Root;
      assert.equal(catalog.get(pdf.Names.Type, pdf.PdfName).value, pdf.Names.Catalog);

      // Проверяем в документе Root.
      const pages = catalog.pages;
      assert.equal(pages.get(pdf.Names.Type, pdf.PdfName).value, pdf.Names.Pages);
      assert.equal(pages.get(pdf.Names.Count, pdf.PdfNumber).value, 0);
      assert.equal(pages.get(pdf.Names.Kids, pdf.PdfArray).value.length, 0);
    });

    it("save document with 1 element", () => {
      const doc = pdf.Document.create();
      doc.createNumber(1).ref();
      doc.save();

      // В документе должны быть созданы Catalog, Pages, нулевой объект и Числовой объект.
      assert.equal(doc.xref.Size, 5);

      const obj = doc.xref.getIndirectObject(3).value;
      assert.ok(obj instanceof pdf.PdfNumber);
      assert.equal(obj.value, 1);
    });

    it("save document with 1 compressed element", () => {
      const doc = pdf.Document.create();
      doc.createDictionary({ Test: doc.createBoolean(true) }).ref(pdf.IndirectObjectType.compressed);
      doc.save();

      // В документе должны быть созданы Catalog, Pages, нулевой объект и Числовой объект.
      assert.equal(doc.xref.Size, 6);

      const obj = doc.xref.getIndirectObject(3).value;
      assert.ok(obj instanceof pdf.PdfDictionary);
    });

    it("save document with 1 update", () => {
      const doc = pdf.Document.create();
      doc.save();

      doc.createNumber(1).ref();
      doc.save();

      // В последнем XRef проверяем size.
      assert.equal(doc.xref.Size, 6);

      // Проверяем добавленный элемент.
      const obj = doc.xref.getIndirectObject(4).value;
      assert.ok(obj instanceof pdf.PdfNumber);
      assert.equal(obj.value, 1);

      // Проверяем последний сохраненный XRef.
      const xref = doc.xref.prev;
      assert.ok(xref);
      // Проверяем что XRef есть ссылка на первый XRef.
      assert.ok(xref.prev);
      // В последнем XRef должен быть только 2 элемента, добавленный + сам xref.
      assert.equal(xref.objects.size, 2);
    });
  });

  describe("Update()", () => {
    const testCases: {
      title: string;
      addObj: (doc: pdf.Document) => PdfObjectType;
      updObj: (obj: PdfObjectType, doc: pdf.Document,) => void;
      want: string;
    }[] = [
        {
          title: "PdfArray",
          addObj: (doc) => doc.createArray(),
          updObj: (obj, doc) => {
            if (!(obj instanceof pdf.PdfArray)) {
              throw new Error("Неверный тип объекта");
            }
            obj.push(doc.createNumber(1));
          },
          want: "[ 1 ]",
        },
        {
          title: "PdfBoolean",
          addObj: (doc) => doc.createBoolean(true),
          updObj: (obj) => {
            if (!(obj instanceof pdf.PdfBoolean)) {
              throw new Error("Неверный тип объекта");
            }
            obj.value = false;
          },
          want: "false",
        },
        {
          title: "PdfDictionary",
          addObj: (doc) => doc.createDictionary(),
          updObj: (obj, doc) => {
            if (!(obj instanceof pdf.PdfDictionary)) {
              throw new Error("Неверный тип объекта");
            }
            obj.set(doc.createName(pdf.Names.N), doc.createNumber(1));
          },
          want: "<<\n/N 1\n>>",
        },
        {
          title: "PdfDictionary with Ref",
          addObj: (doc) => doc.createDictionary({
            value: doc.createNumber(1),
          }),
          updObj: (obj) => {
            if (!(obj instanceof pdf.PdfDictionary)) {
              throw new Error("Неверный тип объекта");
            }
            obj.get("value", pdf.PdfNumber).value = 2;
          },
          want: "<<\n/value 2\n>>",
        },
        {
          title: "PdfHexString",
          addObj: (doc) => doc.createHexString("begin"),
          updObj: (obj) => {
            if (!(obj instanceof pdf.PdfHexString)) {
              throw new Error("Неверный тип объекта");
            }
            obj.value = "end";
          },
          want: "<656e64>",
        },
        {
          title: "PdfHexString with padding",
          addObj: (doc) => {
            const obj = doc.createHexString("begin");
            obj.padding = 10;

            return obj;
          },
          updObj: (obj) => {
            if (!(obj instanceof pdf.PdfHexString)) {
              throw new Error("Неверный тип объекта");
            }
            obj.value = "end";
          },
          want: "<656e64>  ",
        },
        {
          title: "PdfLiteralString",
          addObj: (doc) => doc.createLiteral("begin"),
          updObj: (obj) => {
            if (!(obj instanceof pdf.PdfLiteralString)) {
              throw new Error("Неверный тип объекта");
            }
            obj.value = "end";
          },
          want: "(end)",
        },
        {
          title: "PdfLiteralString with padding",
          addObj: (doc) => {
            const obj = doc.createLiteral("begin");
            obj.padding = 10;

            return obj;
          },
          updObj: (obj) => {
            if (!(obj instanceof pdf.PdfLiteralString)) {
              throw new Error("Неверный тип объекта");
            }
            obj.value = "end";
          },
          want: "(end)     ",
        },
        {
          title: "PdfName",
          addObj: (doc) => doc.createName("begin"),
          updObj: (obj) => {
            if (!(obj instanceof pdf.PdfName)) {
              throw new Error("Неверный тип объекта");
            }
            obj.value = "end";
          },
          want: "/end",
        },
        {
          title: "PdfNumber",
          addObj: (doc) => doc.createNumber(1),
          updObj: (obj) => {
            if (!(obj instanceof pdf.PdfNumber)) {
              throw new Error("Неверный тип объекта");
            }
            obj.value = 2;
          },
          want: "2",
        },
        {
          title: "PdfNumber with pudding",
          addObj: (doc) => {
            const obj = doc.createNumber(1);
            obj.padding = 10;

            return obj;
          },
          updObj: (obj) => {
            if (!(obj instanceof pdf.PdfNumber)) {
              throw new Error("Неверный тип объекта");
            }
            obj.value = 2;
          },
          want: "2         ",
        },
        {
          title: "PdfStream",
          addObj: (doc) => doc.createStream(),
          updObj: (obj) => {
            if (!(obj instanceof pdf.PdfStream)) {
              throw new Error("Неверный тип объекта");
            }
            obj.value = Buffer.from("end");
          },
          want: "<<\n/Length 3\n>>\nstream\nend\nendstream",
        },
      ];

    for (const tc of testCases) {
      it(tc.title, () => {
        const doc = pdf.Document.create(pdf.XRefType.XRefTable);
        const o = tc.addObj(doc).ref();
        doc.save();

        tc.updObj(o, doc);
        doc.save();

        let countXref = 1;
        let xref = doc.xref;
        while (xref.prev) {
          countXref++;
          xref = xref.prev;
        }

        if (countXref != 3) {
          throw new Error("Документ должен иметь одно обновление");
        }

        const writer = new Writer(doc);
        assert.equal(Buffer.from(writer.write(doc.buffer, o, true, false)).toString(), tc.want);
      });
    }

    it("ReWriteRaw Number", () => {
      const doc = pdf.Document.create(pdf.XRefType.XRefTable);
      const o = doc.createNumber(1).ref();
      o.padding = 10;
      doc.save();

      o.reWriteValue(125);
      doc.save();

      let countXref = 1;
      let xref = doc.xref;
      while (xref.prev) {
        countXref++;
        xref = xref.prev;
      }

      if (countXref != 2) {
        throw new Error("Документ не должен иметь обновления");
      }

      assert.equal(o.raw.length, 10);
      assert.equal(Buffer.from(o.raw.getRaw()).toString(), "125       ");
      const obj = doc.xref.getIndirectObject(3).value;
      assert.ok(obj instanceof pdf.PdfNumber);
      assert.equal(obj.value, 125);
    });

    it("ReWriteRaw Hex", () => {
      const doc = pdf.Document.create(pdf.XRefType.XRefTable);
      const o = doc.createHexString("1").ref();
      o.padding = 12;
      doc.save();

      o.reWriteValue("1234");
      doc.save();

      let countXref = 1;
      let xref = doc.xref;
      while (xref.prev) {
        countXref++;
        xref = xref.prev;
      }

      if (countXref != 2) {
        throw new Error("Документ не должен иметь обновления");
      }

      assert.equal(o.raw.length, 12);
      assert.equal(Buffer.from(o.raw.getRaw()).toString(), "<31323334>  ");
      const obj = doc.xref.getIndirectObject(3).value;
      assert.ok(obj instanceof pdf.PdfHexString);
      assert.equal(obj.value, "1234");
    });
  });

  describe("Objects", () => {
    describe("PdfNumber", () => {
      const testCases: {
        title: string,
        value: number,
        want: string,
      }[] = [
          {
            title: "123",
            value: 123,
            want: "123"
          },
          {
            title: "-123",
            value: -123,
            want: "-123"
          },
          {
            title: "12.3",
            value: 12.3,
            want: "12.3"
          },
          {
            title: ".34",
            value: .34,
            want: "0.34"
          },
        ];

      for (const tc of testCases) {
        it(tc.title, () => {
          const doc = pdf.Document.create(pdf.XRefType.XRefTable);
          const writer = new Writer(doc);

          const obj = doc.createNumber(tc.value);
          const got = writer.write(doc.buffer, obj);
          const gotString = Buffer.from(got).toString();

          assert.equal(gotString, tc.want);
        });
      }
    });

    describe("PdfBoolean", () => {
      const testCases: {
        title: string,
        value: boolean,
        want: string,
      }[] = [
          {
            title: "true",
            value: true,
            want: "true"
          },
          {
            title: "false",
            value: false,
            want: "false"
          },
        ];

      for (const tc of testCases) {
        it(tc.title, () => {
          const doc = pdf.Document.create(pdf.XRefType.XRefTable);
          const writer = new Writer(doc);

          const obj = doc.createBoolean(tc.value);
          const got = writer.write(doc.buffer, obj);
          const gotString = Buffer.from(got).toString();

          assert.equal(gotString, tc.want);
        });
      }
    });

    describe("PdfName", () => {
      const testCases: {
        title: string,
        value: string,
        want: string,
      }[] = [
          {
            title: "page",
            value: pdf.Names.Page,
            want: "/Page"
          },
          {
            title: "cyrillic",
            value: "Кириллица",
            want: "/#41a#438#440#438#43b#43b#438#446#430"
          },
          {
            title: "space",
            value: "With space)",
            want: "/With#20space#29"
          },
        ];

      for (const tc of testCases) {
        it(tc.title, () => {
          const doc = pdf.Document.create(pdf.XRefType.XRefTable);
          const writer = new Writer(doc);

          const obj = doc.createName(tc.value);
          const got = writer.write(doc.buffer, obj);
          const gotString = Buffer.from(got).toString();

          assert.equal(gotString, tc.want);
        });
      }
    });

    describe("PdfHexString", () => {
      const testCases: {
        title: string,
        value: string,
        want: string,
      }[] = [
          {
            title: "text",
            value: "text",
            want: "<74657874>"
          },
        ];

      for (const tc of testCases) {
        it(tc.title, () => {
          const doc = pdf.Document.create(pdf.XRefType.XRefTable);
          const writer = new Writer(doc);

          const obj = doc.createHexString(tc.value);
          const got = writer.write(doc.buffer, obj);
          const gotString = Buffer.from(got).toString();

          assert.equal(gotString, tc.want);
        });
      }

      it("from Uint8Array", () => {
        const doc = pdf.Document.create(pdf.XRefType.XRefTable);
        const writer = new Writer(doc);

        const obj = doc.createHexString(new Uint8Array(10));
        const got = writer.write(doc.buffer, obj);
        const gotString = Buffer.from(got).toString();

        assert.equal(gotString, "<00000000000000000000>");
      });
    });

    describe("PdfLiteralString", () => {
      const testCases: {
        title: string,
        value: string,
        want: string,
      }[] = [
          {
            title: "text",
            value: "text",
            want: "(text)"
          },
        ];

      for (const tc of testCases) {
        it(tc.title, () => {
          const doc = pdf.Document.create(pdf.XRefType.XRefTable);
          const writer = new Writer(doc);

          const obj = doc.createLiteral(tc.value);
          const got = writer.write(doc.buffer, obj);
          const gotString = Buffer.from(got).toString();

          assert.equal(gotString, tc.want);
        });
      }
    });

    describe("PdfArray", () => {
      const doc = pdf.Document.create(pdf.XRefType.XRefTable);

      const testCases: {
        title: string,
        items: pdf.PdfIndirectObjectType[],
        want: string,
      }[] = [
          {
            title: "boolean",
            items: [doc.createBoolean(true)],
            want: "[ true ]"
          },
          {
            title: "number",
            items: [doc.createNumber(123)],
            want: "[ 123 ]"
          },
          {
            title: "name",
            items: [doc.createName("name")],
            want: "[ /name ]"
          },
          {
            title: "array",
            items: [doc.createArray()],
            want: "[ [ ] ]"
          },
          {
            title: "few objs",
            items: [doc.createName("name"), doc.createNumber(123)],
            want: "[ /name 123 ]"
          },
        ];

      for (const tc of testCases) {
        it(tc.title, () => {
          const writer = new Writer(doc);

          const obj = doc.createArray();
          for (const item of tc.items) {
            obj.push(item);
          }
          const got = writer.write(doc.buffer, obj);
          const gotString = Buffer.from(got).toString();

          assert.equal(gotString, tc.want);
        });
      }
    });

    describe("PdfDictionary", () => {
      const doc = pdf.Document.create(pdf.XRefType.XRefTable);

      const testCases: {
        title: string,
        items: {
          name: string,
          value: pdf.PdfIndirectObjectType,
        }[],
        want: string,
      }[] = [
          {
            title: "boolean",
            items: [
              {
                name: "name",
                value: doc.createBoolean(true),
              },
            ],
            want: "<<\n/name true\n>>"
          },
        ];

      for (const tc of testCases) {
        it(tc.title, () => {
          const writer = new Writer(doc);

          const obj = doc.createDictionary();
          for (const item of tc.items) {
            obj.set(item.name, item.value);
          }
          const got = writer.write(doc.buffer, obj);
          const gotString = Buffer.from(got).toString();

          assert.equal(gotString, tc.want);
        });
      }
    });
  });
});
