import { Registry, RegistryTypes } from "../../internal/registry";
import { IPdfDictionaryParams, PdfDictionary, PdfNumber, PdfObjectType, PdfStream } from "../objects";
import { IPairsNumbers } from "../../parser";
import { PdfBuffer } from "../../internal/buffer";
import { Names } from "../names";

export interface IObjectStreamParams extends IPdfDictionaryParams {
  objects?: PdfDictionary[];
}

/**
 * Представление для структуры ObjectStream.
 */
export class ObjectStream extends PdfStream {
  private n = 0;
  private first = 0;
  private extends: ObjectStream | null = null;

  /**
   * @internal
   */
  public pairsNumbers?: Array<IPairsNumbers>;

  /**
   * @internal
   */
  public objects = new Map<number, PdfObjectType>();

  public constructor(param: IObjectStreamParams = {}) {
    super(param);

    if (param.objects) {
      for (let i = 0; i < param.objects.length; i++) {
        this.objects.set(i, param.objects[i]);
      }
    }
  }

  /**
   *  Количество объектов хранящихся в данном потоке.
   */
  public get N(): number {
    if (!this.n) {
      this.n = this.get(Names.N, PdfNumber).value;
    }

    return this.n;
  }

  /**
   *  Количество объектов хранящихся в данном потоке.
   */
  public set N(v: number) {
    if (!this.n || this.n !== v) {
      this.n = this.get(Names.N, PdfNumber).value = v;
    }
  }

  /**
   * Байтовый отступ в распакованном потоке указывающий на первый сжатый объект.
   */
  public get First(): number {
    if (!this.first) {
      this.first = this.get(Names.First, PdfNumber).value;
    }

    return this.first;
  }

  /**
   * Байтовый отступ в распакованном потоке указывающий на первый сжатый объект.
   */
  public set First(v: number) {
    if (!this.first || this.first !== v) {
      this.first = this.get(Names.First, PdfNumber).value = v;
    }
  }

  /**
   *  Ссылка на другой объектный поток.
   */
  public get Extends(): ObjectStream | null {
    return this.extends;
  }

  /**
   * Возвращает объект по индексу из внутреннего стрима.
   * @param index индекс объекта.
   * @returns
   */
  public getObject(index: number): PdfObjectType {
    const buffer = new PdfBuffer(this.value);
    const count = this.N;

    const res = this.objects.get(index);
    if (res) {
      return res;
    }

    const ParserClass = Registry.get(RegistryTypes.Parser);

    if (!this.pairsNumbers) {
      this.pairsNumbers = ParserClass.readHeaderObjectStream(buffer);

      if (this.pairsNumbers.length !== count) {
        throw new Error("readObjectStream(): параметр N или количество записей в stream некорректно.");
      }
    }

    if (index > count) {
      throw new Error(`Object Stream содержит меньшее число элементов чем ${index}`);
    }

    let offset = this.pairsNumbers[index].num2;
    offset = ParserClass.skipWhiteSpaces(buffer, offset + this.First);
    const resDict = ParserClass.read(buffer, this.xref, offset);
    if (!resDict.ok) {
      throw new Error(`readDictionary(): не удалось прочитать Dictionary по офсету: ${offset}`);
    }

    if (resDict.value instanceof PdfStream) {
      throw new Error(`readDictionary(): некорректный формат Dictionary ${offset}`);
    }

    this.objects.set(index, resDict.value as PdfObjectType);

    return resDict.value as PdfObjectType;
  }

  public override onCreate(): void {
    this.set(Names.Type, this.doc.createName(Names.ObjStm));
    this.set(Names.N, this.doc.createNumber(0));
    this.set(Names.First, this.doc.createNumber(0));
  }
}
