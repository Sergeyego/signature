import type { PdfDictionary } from "../../syntax/objects/dictionary";
import { FlateDecode, IFilter, ASCII85Decode, ASCIIHexDecode } from "./filters";

export interface Filter {
  name: string;
  params?: PdfDictionary;
}

export abstract class FilterCodec {
  // TODO: LZWDecode, RunLengthDecode
  private static items: Record<string, IFilter> = {
    FlateDecode: new FlateDecode,
    ASCII85Decode: new ASCII85Decode,
    ASCIIHexDecode: new ASCIIHexDecode,
  };

  /**
   * Применяет кодировку фильтров к data.
   * @param data Данные, которые необходимо кодировать.
   * @param filters Один или несколько фильтров, которыми нужно кодировать data.
   * Если передано несколько фильтров, то они будут применены в обратном порядке.
   * @returns Возвращает кодированные данные.
   */
  public static encode(data: Uint8Array, ...filters: Filter[]): Uint8Array {
    let res = data;

    // Применяем массив фильтров к данным в обратном порядке.
    for (let i = filters.length - 1; i >= 0; i--) {
      const filter = filters[i];
      const filterClass = this.items[filter.name];
      if (filterClass) {
        res = filterClass.encode(res, filter.params || null);
      }
    }

    return res;
  }

  /**
   * Применяет раскодировку фильтров к data.
   * @param data Данные, которые необходимо раскодировать.
   * @param filters Один или несколько фильтров, которыми нужно раскодировать data.
   * Если передано несколько фильтров, то они будут применены в прямом порядке.
   * @returns Возвращает раскодированные данные.
   */
  public static decode(data: Uint8Array, ...filters: Filter[]): Uint8Array {
    let res = data;

    // Применяем массив фильтров к данным в прямом порядке.
    for (let i = 0; i <= filters.length - 1; i++) {
      const filter = filters[i];
      const filterClass = this.items[filter.name];
      if (filterClass) {
        res = filterClass.decode(res, filter.params || null);
      }
    }

    return res;
  }
}
