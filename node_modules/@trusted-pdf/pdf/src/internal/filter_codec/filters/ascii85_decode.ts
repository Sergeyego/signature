import { Names } from "packages/pdf/src/syntax/names";
import { PdfBuffer } from "../../buffer";
import { FilterName, IFilter } from "./filter";

const base = 85;
const groupedZeroesChar = "z";
const ascii85CodesStart = 33;

export class ASCII85Decode implements IFilter {
  public readonly name: FilterName = Names.ASCII85Decode;

  public encode(data: Uint8Array): Uint8Array {
    const pows = [base ** 4, base ** 3, base ** 2, base ** 1, base ** 0];
    let result = "";
    let buffer = 0;

    for (let i = 0; i < data.length; i++) {
      buffer = (buffer << 8 >>> 0) + data[i];

      if ((i + 1) % 4 === 0) {
        // Группа нулей кодируется символом "z"
        if (buffer === 0) {
          result += groupedZeroesChar;
        } else {
          for (let j = 0; j <= pows.length - 1; j++) {
            const code = Math.floor(buffer / pows[j]) % base + ascii85CodesStart;
            result += String.fromCharCode(code);
          }
        }

        buffer = 0;
      }
    }

    const remainingBytes = data.length % 4;

    if (remainingBytes !== 0) {
      // Если остались байты вне группы из 4 символов, дополняем её нулями
      const pow = 4 - (data.length % 4);
      buffer = buffer << (8 * pow) >>> 0;

      for (let j = 0; j <= pows.length - 1; j++) {
        const code = Math.floor(buffer / pows[j]) % base + ascii85CodesStart;
        result += String.fromCharCode(code);
      }

      result = result.slice(0, result.length - pow);
    }

    result += "~>";

    return PdfBuffer.stringToRaw(result);
  }

  public decode(data: Uint8Array): Uint8Array {
    const output: number[] = [];

    const decoder = new TextDecoder();
    let input = decoder.decode(data);

    // Если в строке есть маркер конца строки ~>, то обрезаем строку до него
    const endMarkPosition = input.search("~>");
    if (endMarkPosition !== -1) {
      input = input.slice(0, endMarkPosition);
    }

    let symbolsCount = 0;
    let buffer = 0;

    for (let i = 0, len = input.length; i < len; i++) {
      const c = input.charCodeAt(i);

      // "z" - сгруппированные нули
      if (c === groupedZeroesChar.charCodeAt(0)) {
        output.push(0, 0, 0, 0);
        continue;
      }

      // Игнорируем пробельные символы
      if (c === 32 || (c >= 9 && c <= 13)) {
        continue;
      }

      if (c < ascii85CodesStart || c > 117) {
        throw new Error("Недопустимый в ASCII85 символ.");
      }

      buffer *= base;
      buffer += c - ascii85CodesStart;
      symbolsCount++;

      // Раскодируем группы по 5 символов
      if (symbolsCount % 5) {
        continue;
      }

      output.push((buffer >>> 24) & 0xff, (buffer >>> 16) & 0xff, (buffer >>> 8) & 0xff, buffer & 0xff);
      buffer = 0;
      symbolsCount = 0;
    }

    // Если осталась неполная группа символов, дополняем её символами "u" и раскодируем
    if (symbolsCount) {
      const padding = 5 - symbolsCount;

      input = input + "u".repeat(padding);

      for (let i = 0; i < padding; i++) {
        buffer *= base;
        buffer += base - 1;
      }

      for (let i = 3, len = padding - 1; i > len; i--) {
        output.push((buffer >>> (i * 8)) & 0xFF);
      }
    }

    return new Uint8Array(output);
  }
}
