import { Document } from "../../document";
import { Names } from "../names";
import { PdfArray, PdfIndirectObject, PdfNumber, PdfStream } from "../objects";
import { Trailer } from "./trailer";
import { XRef } from "./xref";
import { XRefTrailerParams } from "./xref_table";

export interface XRefStreamPrevParams {
  xref: XRefStream;
}

type XRefStreamParams = XRefStreamPrevParams | XRefTrailerParams;

/**
 * Представление структуры XRefStream.
 * ```
 * <<
 *  /Type /XRef
 *  /Index [0 32]   %This section has one subsection with 32 objects
 *  /W [1 2 2]      %Each entry has 3 fields: 1, 2 & 2 bytes in width respectively
 *  /Filter /ASCIIHexDecode     %For readability in this example
 *  /Size 32
 *  ...
 * >>
 * stream
 *   00 0000 FFFF
 *   ... cross-references for objects 1 through 10 ...
 *   02 000F 0000
 *   02 000F 0001
 *   02 000F 0002
 *   ... cross-reference for object 14 ...
 *   01 BA5E 0000
 *   ...
 * endstream
 * endobj
 *
 * startxref
 * 54321
 * %%EOF
 * ```
 */
export class XRefStream extends PdfStream implements XRef {
  #trailer?: Trailer;
  #doc?: Document;

  public prev?: XRef | undefined;
  public objects: Map<number, PdfIndirectObject> = new Map();

  public get W(): PdfArray {
    return this.get(Names.W, PdfArray);
  }

  public set W(v: PdfArray) {
    this.set(Names.W, v);
  }

  public get Index(): PdfArray {
    let index = this.find("Index", PdfArray);
    if (!index) {
      index = new PdfArray({
        value: [
          new PdfNumber(),
          new PdfNumber({ value: this.Size }),
        ]
      });
    }

    return index;
  }

  public set Index(v: PdfArray) {
    this.set("Index", v);
  }

  public get Size(): number {
    return this.trailer.Size;
  }

  public set Size(v: number) {
    this.trailer.Size = v;
  }

  public get trailer(): Trailer {
    if (!this.#trailer) {
      const tr = new Trailer();
      tr.xref = this;
      tr.raw = this.raw;
      tr.parent = this.parent;
      tr.values = this.values;

      if (!this.find(Names.Size)) {
        tr.set(Names.Size, this.doc.createNumber(1));
      }

      this.#trailer = tr;
    }

    return this.#trailer;
  }

  public set trailer(v: Trailer) {
    this.#trailer = v;
  }

  public override get doc(): Document {
    if (this.#doc) {
      return this.#doc;
    }

    throw new Error("XRefTable не содержит document");
  }

  public override set doc(v: Document) {
    this.#doc = v;
  }

  public push(...object: PdfIndirectObject[]): void {
    for (const obj of object) {
      obj.xref = this;
      this.objects.set(obj.id, obj);
    }
  }

  public findIndirectObject(id: number): PdfIndirectObject | null {
    let res = this.objects.get(id) ?? null;
    if (!res && this.prev) {
      res = this.prev.findIndirectObject(id);
    }

    return res;
  }

  public getIndirectObject(id: number): PdfIndirectObject {
    const obj = this.findIndirectObject(id);
    if (!obj) {
      throw new Error(`IndirectObject не найден ${id}`);
    }

    return obj;
  }

  /**
   * Создает новый XRefStream с использованием параметров.
   * @param params Параметры.
   * @returns
   */
  public static createByParams(params: XRefStreamParams): XRefStream {
    const xref = new XRefStream();

    if ("doc" in params) {
      xref.doc = params.doc;

      try {
        params.doc.xref;
      } catch (error) {
        params.doc.xref = xref;
      }

      // создание из trailer.
      xref.trailer = params.trailer || xref.trailer; // TODO if params => reset raw and prev.
    } else if ("xref" in params) {
      // TODO добавить копирование.

      // создание из предыдущего xref.
      xref.trailer = params.xref.trailer; // TODO add clone ?
      xref.doc = params.xref.doc;
    } else {
      throw new Error("XRefTable: Неизвестные параметры");
    }

    // Так как XRefStream наследник от PdfStream у него должен быть xref.
    xref.xref = xref;
    xref.set(Names.Type, xref.doc.createName(Names.XRef));

    return xref;
  }
}
