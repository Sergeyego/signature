import * as utils from "./utils";
import { CharTypes } from "../../syntax/char_set";
import { PdfBuffer } from "../buffer";

export abstract class StringConverter {
  /**
   * Раскодирует hex строку.
   * @param raw Данные, содержащие закодированную строку.
   * @returns Раскодированная строка символов.
   */
  public static readHex(raw: Uint8Array): string {
    // Игнорируем пробельные символы
    const rawNoWhiteSpaces = raw.filter(char => !CharTypes.whiteSpaces.includes(char));
    let hexStr = new TextDecoder().decode(rawNoWhiteSpaces);

    // Добавляем в конце 0, если длина строки нечётная
    hexStr = hexStr + (hexStr.length % 2 == 1 ? "0" : "");

    const hexStrAsArr = utils.hexToBinary(hexStr);

    let encoding;

    if (utils.hasUtf16BeBOM(hexStrAsArr)) {
      encoding = utils.Encoding.Utf16Be;
    } else if (utils.hasUtf8BOM(hexStrAsArr)) {
      encoding = utils.Encoding.Utf8;
    } else {
      encoding = utils.Encoding.Binary;
    }

    const decodedStr = utils.decodeString(hexStrAsArr, encoding);

    return decodedStr;
  }

  /**
   * Кодирует входной текст в шестнадцатеричную строку или в байтовый массив в формате UTF-8 или UTF-16BE.
   * @param {string} text - Входной текст, который требуется закодировать.
   * @param {boolean} string - Опциональный параметр. Если установлен в `true`, функция вернет шестнадцатеричную строку. По умолчанию возвращается байтовый массив.
   * @returns {Uint8Array | string} Закодированный текст в формате UTF-8 или UTF-16BE в виде байтового массива или шестнадцатеричной строки.
   */
  public static writeHex(text: string, string: true): string;
  public static writeHex(text: string): Uint8Array;
  public static writeHex(text: string, string?: boolean): Uint8Array | string {
    let result = "";

    // Если в строке есть символы, занимающие > 1 байта, то кодируем её в UTF-16BE, иначе в UTF-8.
    let asUtf16Be: boolean;
    if (utils.hasMoreThan1ByteChars(text)) {
      asUtf16Be = true;
      result = "feff";
    } else {
      asUtf16Be = false;
    }

    for (let i = 0; i < text.length; i++) {
      const curCharCode = text.charCodeAt(i);
      const hex = curCharCode.toString(16);

      result += utils.formatHex(hex, asUtf16Be);
    }

    return string ? result : PdfBuffer.stringToRaw(result);
  }

  /**
   * Раскодирует literal строку.
   * @param raw Данные, содержащие закодированную строку.
   * @returns Раскодированная строка символов.
   */
  public static readLiteral(raw: Uint8Array): string {
    let decodedStr = "";

    // Обрабатываем экранированные специальные символы
    const unescapedRaw = utils.unescapeSpecialSymbols(raw);

    if (utils.hasUtf8BOM(unescapedRaw)) {
      // UTF-8 кодировка
      decodedStr = utils.decodeString(unescapedRaw, utils.Encoding.Utf8);
    } else if (utils.hasUtf16BeBOM(unescapedRaw)) {
      // UTF-16BE кодировка
      decodedStr = utils.decodeString(unescapedRaw, utils.Encoding.Utf16Be);
    } else {
      // binary кодировка
      decodedStr = utils.decodeString(unescapedRaw, utils.Encoding.Binary);
    }

    return decodedStr;
  }

  /**
   * Кодирует строку символов в literal строку.
   * @param raw Строка, которую нужно закодировать.
   * @returns Literal строка.
   */
  public static writeLiteral(text: string): Uint8Array {
    // Если в строке есть символы, занимающие больше 1 байта, то кодируем строку в UTF-16, иначе в binary
    const isUtf16Be = utils.hasMoreThan1ByteChars(text);
    let encodedText = isUtf16Be ? utils.fromBinary(utils.toUtf16Be(text)) : text;
    encodedText = utils.escapeSpecialSymbols(encodedText);

    if (isUtf16Be) {
      encodedText = `\xFE\xFF${encodedText}`;
    }

    return utils.toBinary(encodedText);
  }

  /**
   * Раскодирует name строку.
   * @param raw Данные, содержащие закодированную строку.
   * @returns Раскодированная строка символов.
   */
  public static readName(raw: Uint8Array): string {
    const nameStr = new TextDecoder().decode(raw);

    // Обрабатываем символы, представленные шестнадцатеричными кодами
    const decodedStr = nameStr.replace(/#[0-9A-Fa-f]{2}/g, (match) => {
      const symbolCode = match.slice(-2);
      const symbol = String.fromCharCode(parseInt(symbolCode, 16));

      return symbol;
    });

    return decodedStr;
  }

  /**
   * Кодирует строку символов в Name строку.
   * @param raw Строка, которую нужно закодировать.
   * @returns Name строка.
   */
  public static writeName(text: string): Uint8Array {
    // Заменяем спец. символы на их коды
    const result = text.replace(/[^!-~]|[[\]<>(){}#%/]/g, (substring) => `#${substring.charCodeAt(0).toString(16).padStart(2, "0")}`);

    return PdfBuffer.stringToRaw(result);
  }
}
