import { RawData } from "./raw_data";
import { Document } from "../../document";
import type { IndirectObjectType, PdfIndirectObjectType } from "./indirect_object";

import type { XRef } from "../structure/xref";
import type { PdfObjectType } from "./object_type";
import { Registry, RegistryTypes } from "../../internal/registry";

export interface PdfObjectConstructor<T extends PdfObject = PdfObject> {
  new(param?: IPdfObjectParams): T;
  create<T extends PdfObject>(this: PdfObjectConstructor<T>, xref: XRef): T;
}

export interface IPdfObjectParams {
  padding?: number;
}

export class PdfObject extends RawData {
  #xref?: XRef;
  public padding: number;

  public parent?: PdfIndirectObjectType;

  public constructor(param: IPdfObjectParams = {}) {
    super();
    this.padding = param.padding ?? 0;
  }

  public get doc(): Document {
    return this.xref.doc;
  }

  public get xref(): XRef {
    if (!this.#xref) {
      throw new Error("XRef пустой");
    }

    return this.#xref;
  }
  public set xref(v: XRef) {
    this.#xref = v;
  }

  /**
   * Делает объект PDFIndirectObject. Если уже PDFIndirectObject, то оставляет как есть.
   * @param type Указатель типа IndirectObject: compressed, in-use, free.
   * @returns
   */
  public ref(type?: IndirectObjectType): this {
    if (!this.parent) {
      this.parent = this.xref.doc.createIndirectObject(this, type);
    }

    return this;
  }

  /**
   * Добавляет объект в последний xref.
   *
   * этот метод вызывается каждый раз при любом изменении данных объекта.
   */
  public change(): void {
    this.onChange();

    // Поднимаемся вверх до PdfIndirectObject.
    let parent: PdfIndirectObjectType | undefined = this.parent;
    while (parent && !(parent instanceof Registry.get(RegistryTypes.PdfIndirectObject))) {
      parent = parent.parent;
    }

    // Если нет родителя то выходим.
    if (!parent || (this as unknown) === parent) {
      return;
    }

    // Если самый верхний родитель PdfIndirectObject, то вызываем у него метод change.
    parent.change();
  }

  protected onChange(): void {
    //
  }

  public static create<T extends PdfObject>(this: PdfObjectConstructor<T>, xref: XRef): T {
    const obj = new this();
    obj.xref = xref;

    obj.onCreate();

    return obj;
  }

  protected onCreate(): void {
    //
  }

  protected reWriteRaw(v: PdfObjectType): void {
    if (!this.raw.length) {
      throw new Error("Нет RAW");
    }
    const WriterClass = Registry.get(RegistryTypes.Writer);

    const writer = new WriterClass(this.doc);
    const newRaw = writer.write(this.doc.buffer, v, true, false);

    if (newRaw.length > this.raw.length) {
      throw new Error(`reWriteRaw(): Указанная длинна '${this.raw.length}' меньше чем длинна значения '${newRaw.length}'`);
    }

    this.onSetValue(v);

    this.raw.getRaw().set(newRaw);
  }

  protected onSetValue(_v: PdfObjectType): void {
    throw new Error("метод не реализован");
  }

  public convert<T extends PdfObject>(type: new (params?: IPdfObjectParams) => T): T {
    if (this.constructor === type || this instanceof type) {
      return this as unknown as T;
    }

    const res = new type();

    if (!(res instanceof this.constructor)) {
      throw new Error(`Ошибка преобразования '${this.constructor.name}' в '${type.name}'.`);
    }

    res.raw = this.raw;
    res.parent = this.parent;
    res.xref = this.xref;

    this.onConvert(res);

    return res;
  }

  protected onConvert(_obj: PdfObject): void {
    // ничего не делаем
  }
}
