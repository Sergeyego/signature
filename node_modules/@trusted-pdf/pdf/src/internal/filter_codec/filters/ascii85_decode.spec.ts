import * as assert from "node:assert";
import * as fs from "node:fs";
import { ASCII85Decode } from "./ascii85_decode";
import { Names } from "packages/pdf/src/syntax";

const FLATE_TESTS_DIR = `${__dirname}/../../../../testdata/filters/ascii85`;

describe(Names.ASCII85Decode, function () {
  describe("encode()", function () {
    const fileVectors: {
      fileName: string,
    }[] = [
        {
          fileName: "1",
        },
        {
          fileName: "2",
        },
      ];

    fileVectors.forEach((vector) => {
      it(vector.fileName, function () {
        const expected = new Uint8Array(fs.readFileSync(`${FLATE_TESTS_DIR}/${vector.fileName}.encoded`));
        const data = new Uint8Array(fs.readFileSync(`${FLATE_TESTS_DIR}/${vector.fileName}.decoded`));

        const result = new ASCII85Decode().encode(data);

        assert.deepStrictEqual(result, expected);
      });
    });

    const stringVectors: {
      title: string,
      str: string,
      expected: string,
    }[] = [
        {
          title: "easy",
          str: "easy",
          expected: "ARTY*~>",
        },
        {
          title: "moderate",
          str: "moderate",
          expected: "D/WrrEaa'$~>",
        },
        {
          title: "somewhat difficult",
          str: "somewhat difficult",
          expected: "F)Po,GA(E,+Co1uAnbatCif~>",
        },
        {
          title: "spaces",
          str: "         ",
          expected: "+<VdL+<VdL+9~>",
        },
        {
          title: "1 zero",
          str: "\0",
          expected: "!!~>",
        },
        {
          title: "4 zeroes",
          str: "\0\0\0\0",
          expected: "z~>",
        },
        {
          title: "5 zeroes",
          str: "\0\0\0\0\0",
          expected: "z!!~>",
        },
        {
          title: "binary",
          str: "\x60\xD1\x05\x8B\x3D\xB2\xB4\x71\x5A\x66\x5B\x05\xC3\xC7\x14\x1C\x4F\x3D\x17\x1E\x5F\x0C\x68",
          expected: "@*o.94gMG7>%UtB_oEH2:H]L8?OUT~>",
        },
        {
          title: "binary remaining bytes",
          str: "\xC4\xD1",
          expected: "`6e~>",
        },
      ];

    stringVectors.forEach((vector) => {
      it(vector.title, function () {
        const expected = new Uint8Array(Buffer.from(vector.expected));
        const data = new Uint8Array(Buffer.from(vector.str, "binary"));

        const result = new ASCII85Decode().encode(data);

        assert.deepStrictEqual(result, expected);
      });
    });
  });

  describe("decode()", function () {
    const fileVectors: {
      fileName: string,
    }[] = [
        {
          fileName: "1",
        },
        {
          fileName: "2",
        },
      ];

    fileVectors.forEach((vector) => {
      it(vector.fileName, function () {
        const data = new Uint8Array(fs.readFileSync(`${FLATE_TESTS_DIR}/${vector.fileName}.encoded`));
        const expected = new Uint8Array(fs.readFileSync(`${FLATE_TESTS_DIR}/${vector.fileName}.decoded`));

        const result = new ASCII85Decode().decode(data);

        assert.deepStrictEqual(result, expected);
      });
    });

    const stringVectors: {
      title: string,
      encoded: string,
      expected: string,
    }[] = [
        {
          title: "easy",
          encoded: "ARTY*~>",
          expected: "easy",
        },
        {
          title: "moderate",
          encoded: "D/WrrEaa'$~>",
          expected: "moderate",
        },
        {
          title: "somewhat difficult",
          encoded: "F)Po,GA(E,+Co1uAnbatCif~>",
          expected: "somewhat difficult",
        },
        {
          title: "spaces",
          encoded: "+<VdL+<VdL+9~>",
          expected: "         ",
        },
        {
          title: "1 zero",
          encoded: "!!~>",
          expected: "\0",
        },
        {
          title: "4 zeroes",
          encoded: "z~>",
          expected: "\0\0\0\0",
        },
        {
          title: "5 zeroes",
          encoded: "z!!~>",
          expected: "\0\0\0\0\0",
        },
        {
          title: "binary",
          encoded: "@*o.94gMG7>%UtB_oEH2:H]L8?OUT~>",
          expected: "\x60\xD1\x05\x8B\x3D\xB2\xB4\x71\x5A\x66\x5B\x05\xC3\xC7\x14\x1C\x4F\x3D\x17\x1E\x5F\x0C\x68",
        },
        {
          title: "binary remaining bytes",
          encoded: "`6e~>",
          expected: "\xC4\xD1",
        },
        {
          title: "trailing symbols",
          encoded: "ARTY*~>trailing symbols",
          expected: "easy",
        },
        {
          title: "ignoring spaces",
          encoded: "A\tR T\nY*~>",
          expected: "easy",
        },
      ];

    stringVectors.forEach((vector) => {
      it(vector.title, function () {
        const data = new Uint8Array(Buffer.from(vector.encoded, "binary"));
        const expected = new Uint8Array(Buffer.from(vector.expected, "binary"));
        const result = new ASCII85Decode().decode(data);

        assert.deepStrictEqual(result, expected);
      });
    });

    it("on providing non-ascii85 symbols", function () {
      const data = new Uint8Array(Buffer.from("кириллица"));

      assert.throws(() => new ASCII85Decode().decode(data),
        { message: "Недопустимый в ASCII85 символ." });
    });
  });
});

