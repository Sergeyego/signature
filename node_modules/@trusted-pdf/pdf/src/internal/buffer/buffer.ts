import { Registry, RegistryTypes } from "../registry";
import type { PdfView } from "./view";

export class PdfBuffer {

  public get length(): number {
    return this.raw.length + this.#streamLength;
  }

  public constructor(public raw: Uint8Array = new Uint8Array()) { }

  #stream = false;
  #lines: Array<Uint8Array> = [];
  #streamLength = 0;

  public begin(): this {
    this.#stream = true;

    return this;
  }

  public end(endLine?: Uint8Array): this {
    this.#stream = false;
    this.#streamLength = 0;

    if (!this.#lines.length) {
      return this;
    }

    if (endLine) {
      this.append(this.#lines, endLine);
    } else {
      this.append(this.#lines);
    }

    this.#lines = [];

    return this;
  }

  /**
   * Добавляет в текущий массив данных новые данные.
   * @param raw Новые данные.
   * @returns
   */
  public append(raw: Uint8Array | PdfBuffer): this;
  /**
   * Добавляет в текущий массив данных новые данные с возможностью добавлять промежуточные данные.
   * @param raw Массив новых данных.
   * @param endLine Разделитель, добавляется только между добавляемыми данными.
   * @returns
   */
  public append(raw: Array<Uint8Array | PdfBuffer>, endLine?: Uint8Array): this;
  public append(raw: Array<Uint8Array | PdfBuffer> | Uint8Array | PdfBuffer, endLine?: Uint8Array): this {
    const objs: Uint8Array[] = [];

    if (!Array.isArray(raw)) {
      if (raw instanceof PdfBuffer) {
        objs.push(raw.raw);
      } else {
        objs.push(raw);
      }
    } else {
      for (const r of raw) {
        if (r instanceof PdfBuffer) {
          objs.push(r.raw);
        } else {
          objs.push(r);
        }
      }
    }

    // Если пришел пустой набор.
    if (!objs.length) {
      return this;
    }

    if (this.#stream) {
      for (let index = 0; index < objs.length; index++) {
        const obj = objs[index];

        this.#streamLength += obj.length;
        this.#lines.push(obj);

        // Исключаем добавление endLine для последней строки.
        if (index !== objs.length - 1 && endLine) {
          this.#streamLength += endLine.length;
          this.#lines.push(endLine);
        }
      }

      return this;
    }

    // Замена массива.
    this.raw = this.addData(objs, endLine);

    return this;
  }

  private addData(objs: Uint8Array[], endLine?: Uint8Array): Uint8Array {
    let size = this.length;
    const endLineLength = endLine ? endLine.length : 0;

    // Определяем длину нового массива.
    for (let index = 0; index < objs.length; index++) {
      size += objs[index].length;

      // Исключаем добавление endLine для последней строки.
      if (index !== objs.length - 1 && endLine) {
        size += endLineLength;
      }
    }

    // Новый массив.
    const res = new Uint8Array(size);
    res.set(this.raw);

    // Заполнение нового массива.
    let offset = this.length;
    for (let index = 0; index < objs.length; index++) {
      const obj = objs[index];

      res.set(obj, offset);
      offset += obj.length;

      // Исключаем добавление endLine для последней строки.
      if (index !== objs.length - 1 && endLine) {
        res.set(endLine, offset);
        offset += endLineLength;
      }
    }

    return res;
  }

  /**
   * Создает абстрактный подмассив из PdfBuffer.
   * @param begin Начало массива. По умолчанию: 0.
   * @param end Конец массива. По умолчанию: конец массива.
   */
  public subarray(begin = 0, end?: number): PdfView {
    const view = Registry.get(RegistryTypes.PdfView);

    return new view(this, begin, end);
  }

  /**
   * Преобразует число в Uint8Array в виде строки с добавлением ведущих нулей
   * @param value Число, которое нужно преобразовать
   * @param length Длина результирующего массива(опционально)
   * @returns Массив типа Uint8Array, содержащий преобразованное число в виде строки
   */
  public static numberToTextRaw(value: number, length = 0): Uint8Array {
    return this.stringToRaw(value.toString().padStart(length, "0"));
  }

  /**
   * Преобразует строку в массив Uint8Array
   * @param text Строка, которую нужно преобразовать
   * @returns Массив типа Uint8Array, содержащий преобразованную строку
   */
  public static stringToRaw(text: string): Uint8Array {
    const s = unescape(encodeURIComponent(text));
    const uintArray = new Uint8Array(s.length);

    for (let i = 0; i < s.length; i++) {
      uintArray[i] = s.charCodeAt(i);
    }

    return uintArray;
  }

  /**
    * Преобразует число в массив Uint8Array
    * @param num Число, которое нужно преобразовать
    * @param length Длина результирующего массива (опционально)
    * @returns Массив типа Uint8Array, содержащий преобразованное число
   */
  public static numberToRaw(num: number, length?: number): Uint8Array {
    if (length === undefined) {
      length = Math.max(1, Math.ceil(Math.log2(num + 1) / 8));
    }
    const bytes = new Uint8Array(length);
    for (let i = length - 1; i >= 0; i--) {
      bytes[i] = num & 0xff;
      num >>= 8;
    }

    return bytes;
  }
}
