import * as assert from "node:assert";
import * as pdf from "./index";
import * as fs from "node:fs";
import { testHelvetica } from "../testdata/helvetica";

class TestFlags extends pdf.PdfFlags<typeof TestEnumFlags>{
  public constructor(options?: pdf.IPdfFlagsParams<typeof TestEnumFlags>) {
    super(TestEnumFlags, options);
  }
}

export enum TestEnumFlags {
  Flag1 = 1 << 0,
  Flag2 = 1 << 1,
}

describe("Document", () => {
  describe("Flags", () => {
    it("empty", () => {
      const vectors: {
        title: string,
        createFlags: (doc: pdf.Document) => TestFlags,
        wantValue: number,
        wantArray: string[],
      }[] = [
          {
            title: "Default",
            createFlags: (doc: pdf.Document) => {
              return doc.createFlags(TestFlags);
            },
            wantValue: 0,
            wantArray: [],
          },
          {
            title: "set Flag1",
            createFlags: (doc: pdf.Document) => {
              const flags = doc.createFlags(TestFlags);
              flags.set("Flag1");

              return flags;
            },
            wantValue: 1,
            wantArray: ["Flag1"],
          },
          {
            title: "set Flag1 twice",
            createFlags: (doc: pdf.Document) => {
              const flags = doc.createFlags(TestFlags);
              flags.set("Flag1");
              flags.set("Flag1");

              return flags;
            },
            wantValue: 1,
            wantArray: ["Flag1"],
          },
          {
            title: "set Flag1 and Flag2",
            createFlags: (doc: pdf.Document) => {
              const flags = doc.createFlags(TestFlags);
              flags.set("Flag1");
              flags.set("Flag2");

              return flags;
            },
            wantValue: 3,
            wantArray: ["Flag1", "Flag2"],
          },
          {
            title: "unset Flag1",
            createFlags: (doc: pdf.Document) => {
              const flags = doc.createFlags(TestFlags, 3);
              flags.unset("Flag1");

              return flags;
            },
            wantValue: 2,
            wantArray: ["Flag2"],
          },
        ];

      vectors.forEach(vector => {
        it(vector.title, () => {
          const doc = pdf.Document.create(pdf.XRefType.XRefTable);
          const flags = vector.createFlags(doc);

          assert.equal(flags.value, vector.wantValue);
          assert.deepEqual(flags.get(), vector.wantArray);
        });
      });
    });
  });

  describe("Fonts", () => {
    it("addFont", () => {
      const doc = pdf.Document.create(pdf.XRefType.XRefTable);

      const pageContent = doc.createStream({
        stream: pdf.PdfBuffer.stringToRaw(
          "BT\n/FontName 12 Tf\n10 822.65 Td\n<039303b403ac03a603a903b6> Tj\nET"
        )
      }).ref();

      const page = doc.createDictionary({
        Type: doc.createName(pdf.Names.Page),
        Name: doc.createName("Page1"),
        Parent: doc.xref.trailer.Root.pages,
        MediaBox: doc.createArray(
          doc.createNumber(0),
          doc.createNumber(0),
          doc.createNumber(595.28),
          doc.createNumber(841.89),
        ),
        Contents: pageContent,
      }).ref();
      doc.xref.trailer.Root.pages.kids.push(page);
      doc.xref.trailer.Root.pages.count = 1;

      const fontName = "PDFA+Helvetica";
      const font = doc.addFont(pdf.fromBase64(testHelvetica), fontName);

      page.set(pdf.Names.Resources, doc.createDictionary({
        Font: doc.createDictionary({
          FontName: font.dictionary
        }),
      }));

      doc.save();

      const docFont = doc.fonts.get(fontName);
      assert.ok(docFont);
      assert.equal(docFont.dictionary.get(pdf.Names.Type, pdf.PdfName).value, pdf.Names.Font);
      assert.equal(docFont.dictionary.get(pdf.Names.Subtype, pdf.PdfName).value, pdf.Names.Type0);
      assert.equal(docFont.dictionary.get(pdf.Names.BaseFont, pdf.PdfName).value, fontName);
      assert.equal(docFont.dictionary.get(pdf.Names.Encoding, pdf.PdfName).value, pdf.Names.IdentityH);

      const descendantFonts = docFont.dictionary.get(pdf.Names.DescendantFonts, pdf.PdfArray).get(0, pdf.PdfDictionary);
      assert.ok(descendantFonts);
      assert.equal(descendantFonts.get(pdf.Names.Type, pdf.PdfName).value, pdf.Names.Font);
      assert.equal(descendantFonts.get(pdf.Names.Subtype, pdf.PdfName).value, pdf.Names.CIDFontType2);
      assert.equal(descendantFonts.get(pdf.Names.CIDToGIDMap, pdf.PdfName).value, pdf.Names.Identity);
      assert.equal(descendantFonts.get(pdf.Names.BaseFont, pdf.PdfName).value, fontName);
      assert.ok(descendantFonts.get(pdf.Names.CIDSystemInfo, pdf.PdfDictionary));
      assert.ok(descendantFonts.get(pdf.Names.W, pdf.PdfArray));

      const toUnicode = docFont.dictionary.get(pdf.Names.ToUnicode, pdf.PdfStream);
      assert.ok(toUnicode);

      const fontDescriptor = descendantFonts.get(pdf.Names.FontDescriptor, pdf.PdfDictionary);
      assert.ok(fontDescriptor);
      assert.equal(fontDescriptor.get(pdf.Names.Type, pdf.PdfName).value, pdf.Names.FontDescriptor);
      assert.equal(fontDescriptor.get(pdf.Names.FontName, pdf.PdfName).value, fontName);
      assert.ok(fontDescriptor.get(pdf.Names.Flags, pdf.PdfNumber));
      assert.ok(fontDescriptor.get(pdf.Names.FontBBox, pdf.PdfArray));
      assert.ok(fontDescriptor.get(pdf.Names.ItalicAngle, pdf.PdfNumber));
      assert.ok(fontDescriptor.get(pdf.Names.Ascent, pdf.PdfNumber));
      assert.ok(fontDescriptor.get(pdf.Names.Descent, pdf.PdfNumber));
      assert.ok(fontDescriptor.get(pdf.Names.CapHeight, pdf.PdfNumber));
      assert.ok(fontDescriptor.get(pdf.Names.XHeight, pdf.PdfNumber));
      assert.ok(fontDescriptor.get(pdf.Names.StemV, pdf.PdfNumber));
      assert.ok(fontDescriptor.get(pdf.Names.FontFile2, pdf.PdfStream));

      // fs.writeFileSync(`${__dirname}/../testdata/temp.pdf`, doc.buffer.raw);
    });
  });

  describe("PagesList", () => {
    it("empty", () => {
      const doc = pdf.Document.create(pdf.XRefType.XRefTable);
      doc.save();

      assert.equal(doc.findPage(1), null);
      assert.throws(() => doc.getPage(1));
      assert.equal(doc.getPagesList().size, 0);
    });
    it("2 pages", () => {
      const doc = pdf.Document.create(pdf.XRefType.XRefTable);
      const kids = doc.xref.trailer.Root.pages.kids;
      kids.push(doc.createDictionary({ Type: doc.createName(pdf.Names.Page), Name: doc.createName("Page1") }));
      kids.push(doc.createDictionary({ Type: doc.createName(pdf.Names.Page), Name: doc.createName("Page2") }));
      doc.save();

      assert.ok(doc.findPage(1));
      assert.ok(doc.getPage(2));
      assert.equal(doc.getPagesList().size, 2);
    });
  });

  describe(pdf.Names.Image, () => {
    it("jpeg", () => {
      const doc = pdf.Document.create(pdf.XRefType.XRefTable);
      const pages = doc.xref.trailer.Root.pages;

      // Добавление изображения.
      const imageBuf = fs.readFileSync(`${__dirname}/../testdata/shtamp.jpeg`);
      const image = doc.createImage(imageBuf);

      //#region Добавление страницы.
      const uuid = "img-jpeg";
      pages.count = 1;

      pages.kids.push(
        doc.createDictionary({
          Type: doc.createName(pdf.Names.Page),
          Parent: pages.ref(),
          MediaBox: doc.createArray(
            doc.createNumber(0),
            doc.createNumber(0),
            doc.createNumber(700),
            doc.createNumber(800),
          ),
          Contents: doc.createArray(
            doc.createStream({
              stream: pdf.PdfBuffer.stringToRaw(
                `q\n1 0 0 1 0 0 cm\n${image.width} 0 0 ${image.height} 0 0 cm\n/${uuid} Do\nQ`
              )
            }).ref()
          ),
          Resources: doc.createDictionary({
            XObject: doc.createDictionary({
              [uuid]: image.ref(),
            })
          }),
        }).ref(),
      );

      doc.save();
      // fs.writeFileSync(`${__dirname}/../testdata/temp.pdf`, doc.buffer.raw);
      //#endregion
    });
    it("png1", () => {
      const doc = pdf.Document.create(pdf.XRefType.XRefTable);
      const pages = doc.xref.trailer.Root.pages;
      pages.count = 1;

      // Добавление изображения.
      const imageBuf = fs.readFileSync(`${__dirname}/../testdata/png1.png`);
      const image = doc.createImage(imageBuf);

      //#region Добавление страницы.
      const uuid = "img-png1";

      pages.kids.push(
        doc.createDictionary({
          Type: doc.createName(pdf.Names.Page),
          Parent: pages.ref(),
          MediaBox: doc.createArray(
            doc.createNumber(0),
            doc.createNumber(0),
            doc.createNumber(image.width),
            doc.createNumber(image.height),
          ),
          Contents: doc.createArray(
            doc.createStream({
              stream: pdf.PdfBuffer.stringToRaw(
                `q\n1 0 0 1 0 0 cm\n${image.width} 0 0 ${image.height} 0 0 cm\n/${uuid} Do\nQ`
              )
            }).ref()
          ),
          Resources: doc.createDictionary({
            XObject: doc.createDictionary({
              [uuid]: image.ref(),
            })
          }),
        }).ref(),
      );

      doc.save();
      // fs.writeFileSync(`${__dirname}/../testdata/temp.pdf`, doc.buffer.raw);
      //#endregion
    });

    it("png2", () => {
      const doc = pdf.Document.create(pdf.XRefType.XRefTable);
      const pages = doc.xref.trailer.Root.pages;
      pages.count = 1;

      // Добавление изображения.
      const imageBuf = fs.readFileSync(`${__dirname}/../testdata/png2.png`);
      const image = doc.createImage(imageBuf);

      //#region Добавление страницы.
      const uuid = "img-png2";

      pages.kids.push(
        doc.createDictionary({
          Type: doc.createName(pdf.Names.Page),
          Parent: pages.ref(),
          MediaBox: doc.createArray(
            doc.createNumber(0),
            doc.createNumber(0),
            doc.createNumber(image.width),
            doc.createNumber(image.height),
          ),
          Contents: doc.createArray(
            doc.createStream({
              stream: pdf.PdfBuffer.stringToRaw(
                `q\n1 0 0 1 0 0 cm\n${image.width} 0 0 ${image.height} 0 0 cm\n/${uuid} Do\nQ`
              )
            }).ref()
          ),
          Resources: doc.createDictionary({
            XObject: doc.createDictionary({
              [uuid]: image.ref(),
            })
          }),
        }).ref(),
      );

      doc.save();
      // fs.writeFileSync(`${__dirname}/../testdata/temp.pdf`, doc.buffer.raw);
      //#endregion
    });
  });

  describe("PDFDictionary", () => {

    let doc: pdf.Document;

    beforeEach(() => {
      doc = pdf.Document.create(pdf.XRefType.XRefTable);
    });

    describe("#findInherited", () => {
      it("should return the direct value if present", () => {
        const page = doc.createDictionary({ Type: doc.createName(pdf.Names.Page) }).ref();
        const obj = page.findInherited("Type");
        assert.ok(obj instanceof pdf.PdfName);
        assert.strictEqual(obj.value, pdf.Names.Page);

        const objName = page.findInherited("Type", pdf.PdfName);
        assert.ok(objName);
        assert.strictEqual(objName.value, pdf.Names.Page);
      });

      it("should return null if the key is not found and no parent exists", () => {
        const page = doc.createDictionary({ Type: doc.createName(pdf.Names.Page) }).ref();
        const found = page.findInherited("MissingKey");
        assert.strictEqual(found, null);

        const found2 = page.findInherited("MissingKey", pdf.PdfName);
        assert.strictEqual(found2, null);
      });

      it("should return null if the Parent field is not a dictionary", () => {
        const dict = doc.createDictionary({}).ref();
        const arr = doc.createArray(dict).ref();
        dict.set(pdf.Names.Parent, arr);

        const found = dict.findInherited("MissingKey");
        assert.strictEqual(found, null);
      });

      it("should return the inherited value from the parent if the key is not found in the current object", () => {
        const parentDict = doc.createDictionary({ InheritedKey: doc.createName("InheritedValue") }).ref();
        const childDict = doc.createDictionary({ Parent: parentDict }).ref();

        const found = childDict.getInherited("InheritedKey", pdf.PdfName);
        assert.strictEqual(found.value, "InheritedValue");
      });

      it("should recurse through multiple levels of parents to find the inherited value", () => {
        const grandParentDict = doc.createDictionary({ InheritedKey: doc.createName("InheritedValue") }).ref();
        const parentDict = doc.createDictionary({ Parent: grandParentDict }).ref();
        const childDict = doc.createDictionary({ Parent: parentDict }).ref();
        const found = childDict.getInherited("InheritedKey", pdf.PdfName);
        assert.strictEqual(found.value, "InheritedValue");
      });

      it("should return null if the key is not found even in the topmost parent", () => {
        const parentDict = doc.createDictionary({}).ref();
        const childDict = doc.createDictionary({ Parent: parentDict }).ref();
        const found = childDict.findInherited("MissingKey");
        assert.strictEqual(found, null);
      });
    });

    describe("#getInherited", () => {
      it("should throw an error if the key is not found and no parent exists", () => {
        const dict = doc.createDictionary({}).ref();
        assert.throws(() => {
          dict.getInherited("MissingKey");
        }, /Элемент через родителей не найден/);
      });

      it("should throw an error if the Parent field is not a dictionary", () => {
        const dict = doc.createDictionary({}).ref();
        const arr = doc.createArray(dict).ref();
        dict.set(pdf.Names.Parent, arr);

        assert.throws(() => {
          dict.getInherited("MissingKey");
        }, /Элемент через родителей не найден/);
      });
    });
  });

});
