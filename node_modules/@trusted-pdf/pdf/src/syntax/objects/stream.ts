import { RawData } from "./raw_data";
import { PdfView, isEqualRaw } from "../../internal";
import { IPdfObjectParams, PdfObject } from "./object";
import { PdfDictionary } from "./dictionary";
import { PdfNumber } from "./number";
import { FilterList } from "./filter_list";
import { Names } from "../names";

export class PdfStream extends PdfDictionary {
  /**
   * Значение с фильтрами что находится в raw. Закодированное.
   */
  #rawValue?: Uint8Array;
  /**
   * Значение без фильтров. Декодированное.
   */
  #value?: Uint8Array;

  public filters: FilterList;
  public stream: PdfView = RawData.EMPTY_VIEW;

  public constructor(param: IPdfObjectParams = {}) {
    super(param);
    this.filters = new FilterList({ pdfStream: this });
  }

  public get Length(): number {
    return this.get(Names.Length, PdfNumber).value;
  }

  public set Length(value: number) {
    const length = this.find(Names.Length, PdfNumber);
    if (!length) {
      this.set(Names.Length, this.doc.createNumber(value));
    } else {
      length.value = value;
    }
  }

  public set rawValue(raw: Uint8Array) {
    this.#rawValue = raw;
    this.#value = undefined;
    this.Length = this.#rawValue.byteLength;
  }

  /**
   * Значение с фильтрами что находится в raw. Закодированное.
   */
  public get rawValue(): Uint8Array {
    let rawValue = this.#rawValue;
    // Если есть закодированное значение то мы его возвращаем как есть.
    if (rawValue && rawValue.length) {
      return rawValue;
    }

    // Если есть незакодированное значение то мы его кодируем и возвращаем.
    const value = this.#value;
    if (value && value.length) {
      // Декодирование с параметрами.
      rawValue = this.filters.encode(value);

      this.rawValue = rawValue;

      return rawValue;
    }

    // Если нет ничего то пробуем получить из raw.
    rawValue = this.stream.getRaw();
    this.rawValue = rawValue;

    return rawValue;
  }

  /**
   * Значение без фильтров. Декодированное.
   */
  public get value(): Uint8Array {
    let value = this.#value;
    if (value) {
      return value;
    }

    const rawValue = this.rawValue;
    if (!rawValue) {
      throw new Error("Stream: содержимое не найдено");
    }

    // Декодирование.
    value = this.filters.decode(rawValue);
    if (!value) {
      throw new Error("Stream: содержимое не декодировано");
    }

    this.#value = value;

    return value;
  }

  /**
   * Value не должно быть закодировано фильтрами.
   */
  public set value(v: Uint8Array) {
    let value = this.#value;
    if (value && isEqualRaw(value, v)) {
      return;
    }

    value = v;

    // Сбрасываем старое значение.
    this.#rawValue = undefined;
    this.Length = -1;

    this.#value = value;

    this.change();
  }

  protected override onCreate(): void {
    this.#value = new Uint8Array();
    this.Length = 0;
  }

  protected override onConvert(obj: PdfObject): void {
    if (!(obj instanceof PdfStream)) {
      throw new Error(`Ошибка преобразования PdfStream в '${obj.constructor.name}'.`);
    }

    super.onConvert(obj);
    obj.filters = this.filters.copy(obj);
    obj.stream = this.stream;
  }
}
