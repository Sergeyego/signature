import { Filter, FilterCodec } from "../../internal/filter_codec";
import { Names } from "../names";
import { PdfArray } from "./array";
import { PdfDictionary } from "./dictionary";
import { PdfName } from "./name";
import { PdfNull } from "./null";
import { PdfStream } from "./stream";

/**
 * Параметры создания класса FilterList.
 */
export interface IFilterListParams {
  pdfStream: PdfStream;
}

/**
 * Управляет фильтрами внутри PdfStream.
 */
export class FilterList {
  /**
   * PdfStream в котором идет управление фильтрами.
   */
  private pdfStream: PdfStream;
  /**
   * Массив текущих фильтров.
   */
  private filters: Filter[] = [];

  public constructor(params: IFilterListParams) {
    this.pdfStream = params.pdfStream;
    this.filters = this.getPdfStreamFilters();
  }

  /**
   * Кодирует данные используя текущие установленные фильтры.
   * @param value входящие данные.
   * @returns
   */
  public encode(value: Uint8Array): Uint8Array {
    return FilterCodec.encode(value, ...this.list());
  }

  /**
   * Декодирует данные используя текущие установленные фильтры.
   * @param value входящие данные.
   * @returns
   */
  public decode(value: Uint8Array): Uint8Array {
    return FilterCodec.decode(value, ...this.list());
  }

  /**
   * Возвращает массив Filter из PdfStream.
   * @returns
   *
   * @remarks
   * Функция формирует новый список фильтров на основе найденных имен и параметров,
   * а не из кэша (this.filters).
   */
  public list(): ReadonlyArray<Filter> {
    return this.getPdfStreamFilters();
  }

  /**
   * Возвращает массив Filter из PdfStream.
   * @returns
   */
  private getPdfStreamFilters(): Filter[] {
    const names = this.findFilters();
    const params = this.findDecodeParms();

    // Создаем новый массив фильтров на основе найденных имен и параметров
    const newFilters = names.map((name, index) => ({
      name,
      params: params[index] ?? undefined,
    }));

    return newFilters;
  }

  /**
   * Задает новый список фильтров, удаляя предыдущий.
   * @param filters
   * @returns
   */
  public setNewFilters(...filters: Filter[]): void {
    if (!filters.length) {
      return;
    }

    // Если фильтр один то его следует добавлять без Array.
    if (filters.length === 1) {
      const { name, params } = filters[0];

      this.pdfStream.set(Names.Filter, this.pdfStream.doc.createName(name));

      if (params) {
        this.pdfStream.set(Names.DecodeParms, params);
      }

      return;
    }

    // Добавление фильтров и параметров как Array.
    const names = this.pdfStream.doc.createArray();
    const decodeParms = this.pdfStream.doc.createArray();

    let writeDecodeParms = false;

    for (const filter of filters) {
      names.push(this.pdfStream.doc.createName(filter.name));

      let params: PdfDictionary | PdfNull;
      if (filter.params) {
        writeDecodeParms = true;
        params = filter.params;
      } else {
        params = this.pdfStream.doc.createNull();
      }

      decodeParms.push(params);

    }

    this.pdfStream.set(Names.Filter, names);

    if (writeDecodeParms) {
      this.pdfStream.set(Names.DecodeParms, decodeParms);
    }
  }

  /**
   * Возвращает массив Filter из PdfStream.
   * @returns
   */
  private findFilters(): string[] {
    const objFilters = this.pdfStream.find(Names.Filter);

    // Если фильтры не найдены.
    if (!objFilters) {
      return [];
    }

    const names = [];
    if (objFilters instanceof PdfName) {
      names.push(objFilters.value);
    } else if (objFilters instanceof PdfArray) {
      for (let index = 0; index < objFilters.length; index++) {
        names.push(objFilters.get(index, PdfName).value);
      }
    } else {
      throw new Error(`Некорректный тип фильтров в ${typeof objFilters}`);
    }

    return names;
  }

  /**
   * Возвращает массив DecodeParms из PdfStream.
   * @returns
   */
  private findDecodeParms(): Array<PdfDictionary | null> {
    const decodeParms: Array<PdfDictionary | null> = [];
    const dp = this.pdfStream.find(Names.DecodeParms);
    if (dp) {
      if (dp instanceof PdfDictionary) {
        decodeParms.push(dp);
      } else if (dp instanceof PdfArray) {
        for (const params of dp) {
          if (params instanceof PdfDictionary) {
            decodeParms.push(params);
          } else {
            decodeParms.push(null);
          }
        }
      } else {
        throw new Error("Неподдерживаемый формат DecodeParms");
      }
    }

    return decodeParms;
  }

  public copy(target: PdfStream): FilterList {
    const list = new FilterList({ pdfStream: target });
    list.filters = this.filters;

    return list;
  }
}
