import { type Document } from "./document";
import { PdfBuffer } from "./internal/buffer";
import { XRefStream } from "./syntax/structure/xref_stream";
import { CharCodes, CharWords } from "./syntax/char_set";
import { PdfArray } from "./syntax/objects/array";
import { PdfBoolean } from "./syntax/objects/boolean";
import { PdfDictionary } from "./syntax/objects/dictionary";
import { PdfHexString } from "./syntax/objects/hex_string";
import { PdfIndirectObject, PdfIndirectObjectType, IndirectObjectType } from "./syntax/objects/indirect_object";
import { PdfLiteralString } from "./syntax/objects/literal_string";
import { PdfName } from "./syntax/objects/name";
import { PdfNumber } from "./syntax/objects/number";
import { PdfStream } from "./syntax/objects/stream";
import { PdfString } from "./syntax/objects/string";
import { XRef, XRefType } from "./syntax/structure/xref";
import { XRefTable } from "./syntax/structure/xref_table";
import { ObjectStream } from "./syntax/structure/object_stream";
import { StringConverter } from "./internal";
import { fromBinary, toBinary } from "./internal/string_converter/utils";
import { Names } from "./syntax/names";
import { PdfNull } from "./syntax/objects/null";

const HEADER = new Uint8Array([0x25, 0x50, 0x44, 0x46, 0x2d, 0x31, 0x2e, 0x35, 0x0a, 0x25, 0xff, 0xff, 0xff, 0xff]);

const FIRST_NULL_ELEMENT = new Uint8Array([0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x20, 0x36, 0x35, 0x35, 0x33, 0x35, 0x20, 0x66]);

export class Writer {
  #doc: Document;

  public constructor(doc: Document) {
    this.#doc = doc;
  }

  /**
   * Проверяет что все xref в документе одного типа.
   * @param typeXRef
   * @param xref
   * @returns
   */
  private isCorrectXRefType(typeXRef: XRefType, xref: XRef): boolean {
    if (xref instanceof XRefTable && typeXRef !== XRefType.XRefTable) {
      return false;
    } else if (xref instanceof XRefStream && typeXRef !== XRefType.XRefStream) {
      return false;
    }

    if (xref.prev) {
      return this.isCorrectXRefType(typeXRef, xref.prev);
    }

    return true;
  }

  /**
   * Сериализация документа.
   * @returns
   */
  public save(): Uint8Array {
    // Обновление не требуется.
    if (this.#doc.xref.raw.length) {
      return this.#doc.buffer.raw;
    }

    const buf = this.#doc.buffer;

    // Если буфер создается с нуля, то добавляем header.
    if (!buf.length) {
      this.wHeader(buf);
    }

    // Добавляем XRef.
    this.wXRef(buf);

    // Возвращаем массив байт всего документа.
    return buf.raw;
  }

  /**
   * Добавление Header.
   * @param buf
   */
  private wHeader(buf: PdfBuffer): void {
    buf.append(HEADER);
    this.#doc.header.raw = buf.subarray();
    buf.append(CharCodes.endLine);
  }

  private wXRef(buf: PdfBuffer): void {
    const targetXRefType = this.#doc.xref instanceof XRefTable
      ? XRefType.XRefTable
      : XRefType.XRefStream;

    if (!this.isCorrectXRefType(targetXRefType, this.#doc.xref)) {
      throw new Error("Документ содержит несколько типов структур");
    }

    if (this.#doc.xref instanceof XRefStream) {
      this.wXRefStream(buf, this.#doc.xref);
    } else {
      this.wXRefTable(buf, this.#doc.xref);
    }
  }

  private getAllObjects(xref: XRef): Map<number, PdfIndirectObject> {
    let objects: Map<number, PdfIndirectObject>;
    if (xref instanceof XRefTable) {
      objects = this.getXRefTableObjects(xref);
    } else if (xref instanceof XRefStream) {
      objects = this.getXRefStreamObjects(xref);
    } else {
      throw new Error("getAllObjects: Неподдерживаемый тип XRef");
    }

    return objects;
  }

  /**
   * Удаляет из списка PdfIndirectObject у которых тип Free (удален).
   * @param objects
   * @returns
   */
  private removeFreeObjects(objects: Map<number, PdfIndirectObject>): Map<number, PdfIndirectObject> {
    return new Map([...objects.entries()].filter((value: [number, PdfIndirectObject]) => value[1].type !== IndirectObjectType.free));
  }

  /**
   * Получение объектов XRefTable.
   * @param xref
   * @returns
   */
  private getXRefTableObjects(xref: XRefTable): Map<number, PdfIndirectObject> {
    let objects: Map<number, PdfIndirectObject> = this.removeFreeObjects(xref.objects);

    if (xref.prev) {
      objects = new Map([...objects, ...this.getAllObjects(xref.prev)]);
    }

    return objects;
  }

  /**
   * Получение объектов XRefStream.
   * @param xref
   * @returns
   */
  private getXRefStreamObjects(xref: XRefStream): Map<number, PdfIndirectObject> {
    let objects: Map<number, PdfIndirectObject> = this.removeFreeObjects(xref.objects);

    if (xref.prev) {
      objects = new Map([...objects, ...this.getAllObjects(xref.prev)]);
    }

    // TODO удалить из списка ObjectStream и XRefStream.

    return objects;
  }

  /**
   * Добавляет в objStream объекты из mapObjects а также формирует и добавляет raw в stream.
   * @param objStream
   * @param mapObjects
   */
  private wObjectStream(buf: PdfBuffer, objStream: ObjectStream, mapObjects: Map<number, PdfIndirectObject>) {
    const parent = objStream.ref().parent;
    if (!parent || !(parent instanceof PdfIndirectObject)) {
      throw new Error("Неудалось сформировать IndirectObject для ObjectStream");
    }
    parent.offset = buf.length;

    const objects = new Map([...mapObjects.entries()].sort((a: [number, PdfIndirectObject], b: [number, PdfIndirectObject]) => a[0] - b[0]));

    // Создание raw Stream.
    const bufStream = new PdfBuffer().begin();
    const bufValues = new PdfBuffer().begin();

    let index = 0;
    for (const [key, obj] of objects) {
      obj.index = index++;
      obj.objStream = parent.id;

      if (obj.value instanceof PdfStream) {
        throw new Error("ObjectStream не может содержать Stream объекты");
      }

      objStream.objects.set(key, obj.value);

      bufStream.append([
        PdfBuffer.numberToTextRaw(key),
        CharCodes.space,
        PdfBuffer.numberToTextRaw(!bufValues.length ? 0 : bufValues.length),
        CharCodes.space,
      ]);

      this.write(bufValues, obj.value, true, true);
      bufValues.append(CharCodes.endLine);
    }

    objStream.First = bufStream.length;
    objStream.N = objects.size;

    // Объединение буферов.
    bufStream.append([
      bufValues.end(),
    ]);
    bufStream.end();

    objStream.set(Names.Filter, parent.doc.createName(Names.FlateDecode));

    // Присвоение незакодированного raw.
    objStream.value = bufStream.raw;
    /* Пример raw.
        11 0 12 547 13 665
      <<
        /Type /Font
        /Subtype /TrueType
        ... other keys ...
        /FontDescriptor 12 0 R
      >>
      <<
        /Type /FontDescriptor
        /Ascent 891
        ... other keys ...
        /FontFile2 22 0 R
      >>
      <<
        /Type /Font
        /Subtype /Type0
        ... other keys ...
        /ToUnicode 10 0 R
      >>
      ...
     */

    // Запись в буфер.
    this.writeObject(buf, parent);
  }

  /**
   * Формирование raw stream для XRefStream.
   * @param xref
   * @returns
   */
  private wXRefStreamValue(xref: XRefStream): Uint8Array {
    const buf = new PdfBuffer().begin();

    // Калькуляция W.
    const w1 = 1;

    const w2 = PdfBuffer.numberToRaw(xref.doc.buffer.length).length;

    const w3Value = PdfBuffer.numberToRaw(xref.Size).length;
    const w3 = w3Value < 2 ? 2 : w3Value;

    // Добавляем W в XRefStream.
    xref.W = new PdfArray({
      value: [
        new PdfNumber({ value: w1 }),
        new PdfNumber({ value: w2 }),
        new PdfNumber({ value: w3 }),
      ]
    });

    // Сортируем Объекты по номеру.
    const objects = new Map([...xref.objects.entries()].sort((a: [number, PdfIndirectObject], b: [number, PdfIndirectObject]) => a[0] - b[0]));

    if (!xref.prev) {
      // Добавить 00 0000 FFFF
      buf.append([
        PdfBuffer.numberToRaw(0, w1),
        PdfBuffer.numberToRaw(0, w2),
        new Uint8Array(w3).fill(0xFF), // TODO проверить все ли байты должны быть FF
      ]);
    }

    // Добавляем записи об объектах.
    for (const [, obj] of objects) {
      switch (obj.type) {
        case IndirectObjectType.free:
          buf.append([
            // 00
            PdfBuffer.numberToRaw(0, w1),
            // Номер объекта, следующего за данным free объектом.
            PdfBuffer.numberToRaw(0, w2),
            // Значение generation номера, которое будет использовано, если данный номер объекта будет использован повторно.
            PdfBuffer.numberToRaw(obj.generation + 1, w3),
          ]);
          break;
        case IndirectObjectType.inUse:
          buf.append([
            // 01
            PdfBuffer.numberToRaw(1, w1),
            // Байтовое смещение объекта, начиная с начала файла.
            PdfBuffer.numberToRaw(obj.offset, w2),
            // Значение generation номера для объекта.
            PdfBuffer.numberToRaw(obj.generation, w3),
          ]);
          break;
        case IndirectObjectType.compressed:
          buf.append([
            // 02
            PdfBuffer.numberToRaw(2, w1),
            // Номер IndirectObject потока, в котором хранится данный объект.
            PdfBuffer.numberToRaw(obj.objStream, w2),
            // Индекс данного объекта внутри IndirectObject.
            PdfBuffer.numberToRaw(obj.index, w3),
          ]);
          break;

        default:
          throw new Error(`Неподдерживаемый тип IndirectObject ${obj.type}`);
      }
    }

    /* Пример raw.
      00 0000 FFFF
      ... cross-references for objects 1 through 10 ...
      02 000F 0000
      02 000F 0001
      02 000F 0002
      ... cross-reference for object 14 ...
      01 BA5E 0000
      ...
    */

    return buf.end().raw;
  }

  private wXRefStream(buf: PdfBuffer, xref: XRefStream) {
    // Сортируем объекты данного xref по ID.
    const objects = new Map([...xref.objects.entries()].sort((a: [number, PdfIndirectObject], b: [number, PdfIndirectObject]) => a[0] - b[0]));

    if (!objects.size) {
      throw new Error("Метод добавления XRefStream без элементов не реализован");
    }

    //#region  Формирование Index.
    // Формируем массив ключей.
    const keys: number[] = [];

    // Добавляем нулевой объект если нет prev.
    if (!xref.prev) {
      keys.push(0);
    }

    // Добавляем все ключи объектов текущего XRef.
    keys.push(...objects.keys());

    const indexArray = new PdfArray();

    let count = 1;  // Инициализация счетчика
    let firstKey = keys[0];

    for (let index = 1; index < keys.length; index++) {
      const key = keys[index];

      if (key === firstKey + count) {
        // Если текущий ключ последовательный
        count++;
      } else {
        // Если ключ не последовательный
        indexArray.push(
          new PdfNumber({ value: firstKey }),
          new PdfNumber({ value: count }),
        );

        firstKey = key;
        count = 1;  // начнем новый диапазон с текущего ключа
      }
    }

    // Добавляем последний диапазон
    indexArray.push(
      new PdfNumber({ value: firstKey }),
      new PdfNumber({ value: count }),
    );

    xref.Index = indexArray;
    //#endregion

    buf.begin();

    // Добавление объектов compressed
    const compressObj = new Map([...objects.entries()].filter((value: [number, PdfIndirectObject]) => value[1].type === IndirectObjectType.compressed));
    if (compressObj.size) {
      this.wObjectStream(buf, ObjectStream.create(xref), compressObj);
      xref.Index.get(xref.Index.value.length - 1, PdfNumber).value++;
    }

    // Добавление объектов inuse
    const inuseObj = new Map([...objects.entries()].filter((value: [number, PdfIndirectObject]) => value[1].type === IndirectObjectType.inUse));
    for (const [, obj] of inuseObj) {
      obj.offset = buf.length;
      this.writeObject(buf, obj);
    }

    const xrefOffset = buf.length;
    xref.value = this.wXRefStreamValue(xref);

    const parent = xref.ref().parent;
    if (!parent || !(parent instanceof PdfIndirectObject)) {
      throw new Error("Неудалось сформировать IndirectObject для XRefStream");
    }

    parent.offset = xrefOffset;

    this.writeObject(buf, parent);

    buf.append([
      // Добавление слова startxref.
      CharWords.startxref,

      // Добавление offset на начало XRef.
      PdfBuffer.numberToTextRaw(xrefOffset),
      // Добавление %%EOF
      CharWords.eof
    ], CharCodes.endLine);

    buf.append(CharCodes.endLine);

    // Добавляем запись в Document.
    buf.end();
    this.#doc.buffer = buf;

    // Добавляем raw в XRef.
    xref.raw = buf.subarray(xrefOffset);
  }

  private wXRefTable(buf: PdfBuffer, xref: XRefTable) {
    const objects = new Map([...xref.objects.entries()].sort((a: [number, PdfIndirectObject], b: [number, PdfIndirectObject]) => a[0] - b[0]));

    let tableLines: Uint8Array[] = [CharWords.xref];

    let groupLines: Uint8Array[] = [];

    let count = 0;
    let begin = 0;

    // Добавление первого элемента.
    if (!xref.prev) {
      groupLines.push(FIRST_NULL_ELEMENT);
      count++;
    }

    // Открываем поточную запись в буфере.
    buf.begin();

    // Подготовка объектов и формирование таблицы.
    for (const object of objects) {
      const obj = object[1];

      if (!groupLines.length) {
        begin = obj.id;
        count = 0;
      }

      // Добавление offset в IndirectObject.
      obj.offset = buf.length;

      // Формирование raw объектов.
      this.writeObject(buf, obj);

      // Добавление строк таблицы.
      if (obj.id === begin + count) {
        // Если последовательность сохраняется.
        const line = this.createLineTable(obj);
        groupLines.push(line);
        count++;
      } else {
        // Если последовательность не сохраняется.
        tableLines.push(PdfBuffer.stringToRaw(`${begin} ${count}`));
        tableLines = tableLines.concat(groupLines);

        groupLines = [];

        begin = obj.id;
        count = 1;

        const line = this.createLineTable(obj);
        groupLines.push(line);
      }
    }

    // Добавление последнего набора.
    tableLines.push(PdfBuffer.stringToRaw(`${begin} ${count}`));
    tableLines = tableLines.concat(groupLines);

    const xrefOffset = buf.length;

    // add table.
    buf.append(tableLines, CharWords.eol);
    buf.append(CharWords.eol);

    // add trailer
    // Добавление слова trailer.
    buf.append([CharWords.trailer, CharCodes.endLine]);
    // Добавление dictionary трейлера.
    this.wDictionary(buf, xref.trailer);
    buf.append(CharCodes.endLine);

    buf.append([
      // Добавление слова startxref.
      CharWords.startxref,

      // Добавление offset на начало XRef.
      PdfBuffer.numberToTextRaw(xrefOffset),
      // %%EOF
      CharWords.eof
    ], CharCodes.endLine);

    buf.append(CharCodes.endLine);

    // Добавляем запись в Document.
    buf.end();
    this.#doc.buffer = buf;

    // Добавляем raw в XRef.
    xref.raw = buf.subarray(xrefOffset);
  }

  /**
   * Создает линию таблицы обновления без eol в конце строки.
   * @param obj
   * @param flag
   * @returns
   */
  private createLineTable(obj: PdfIndirectObject): Uint8Array {
    const line = new PdfBuffer().begin();

    line.append([
      // add offset.
      PdfBuffer.numberToTextRaw(obj.offset, 10),
      // add generation.
      PdfBuffer.numberToTextRaw(obj.generation, 5),
      // add flag.
      obj.type === IndirectObjectType.free ? CharCodes.f : CharCodes.n,
    ], CharCodes.space);

    return line.end().raw;
  }

  //#region write base type.
  private writeObject(buf: PdfBuffer, obj: PdfIndirectObject): Uint8Array {
    return this.wIndObj(buf, obj);
  }

  private wIndObj(buf: PdfBuffer, obj: PdfIndirectObject): Uint8Array {
    buf.begin();

    const offset = buf.length;

    // header.
    const header = PdfBuffer.stringToRaw(`${obj.id} ${obj.generation} obj`);
    buf.append([header, CharCodes.endLine]);

    // value.
    this.write(buf, obj.value, true);

    // Добавление Raw в объект.
    buf.append(CharCodes.endLine);

    // endobj.
    buf.append([CharWords.endobj, CharCodes.endLine]);

    return buf.subarray(offset).getRaw();
  }

  public write(buf: PdfBuffer, obj: PdfIndirectObjectType, writeAsNotRef = false, writeToBuffer = true): Uint8Array {
    buf.begin();
    const objOffset = buf.length;
    let raw: Uint8Array | undefined;
    let primitive = true;

    if (!writeAsNotRef && obj.parent && obj.parent instanceof PdfIndirectObject) {
      raw = this.wRefObj(obj.parent);
      if (writeToBuffer) {
        buf.append(raw);
      }

      return raw;
    }
    if (obj instanceof PdfNull) {
      raw = PdfBuffer.stringToRaw("null");
    } else if (obj instanceof PdfName) {
      raw = this.wName(obj);
    } else if (obj instanceof PdfString) {
      raw = this.wString(obj);
    } else if (obj instanceof PdfNumber) {
      raw = this.wNumber(obj);
    } else if (obj instanceof PdfBoolean) {
      raw = this.wBoolean(obj);
    } else if (obj instanceof PdfIndirectObject) {
      raw = this.wRefObj(obj);

      if (writeToBuffer) {
        buf.append(raw);
      }

      return raw;
    } else if (obj instanceof PdfArray) {
      raw = this.wArray(buf, obj, writeToBuffer);
      primitive = false;
    } else if (obj instanceof PdfStream) {
      raw = this.wStream(buf, obj, writeToBuffer);
      primitive = false;
    } else if (obj instanceof PdfDictionary) {
      raw = this.wDictionary(buf, obj, writeToBuffer);
      primitive = false;
    }

    if (!raw) {
      throw new Error("write(): Неподдерживаемый тип");
    }

    if (writeToBuffer) {
      if (primitive) {
        buf.append(raw);
      }

      // Добавление Raw в объект.
      obj.raw = buf.subarray(objOffset, objOffset + raw.length);
    }

    return raw;
  }

  private wDictionary(buf: PdfBuffer, obj: PdfDictionary, writeToBuffer = true): Uint8Array {
    const res = new PdfBuffer();

    res.append([CharWords.startDictionary, CharCodes.endLine]);

    buf.begin();
    if (writeToBuffer) {
      buf.append([CharWords.startDictionary, CharCodes.endLine]);
    }

    // add fields.
    for (const item of obj.items) {
      const name = PdfBuffer.stringToRaw(`/${item[0]} `);
      if (writeToBuffer) {
        buf.append(name);
      }

      const value = this.write(buf, item[1], false, writeToBuffer);

      if (writeToBuffer) {
        buf.append(CharCodes.endLine);
      }
      res.append([name, value, CharCodes.endLine]);
    }

    if (writeToBuffer) {
      buf.append([CharWords.endDictionary]);
    }

    res.append([CharWords.endDictionary]);

    return res.raw;
  }

  private wStream(buf: PdfBuffer, obj: PdfStream, writeToBuffer = true): Uint8Array {
    const res = new PdfBuffer().begin();

    if (obj.Length === -1) {
      obj.Length = obj.rawValue.byteLength;
    }

    const dictionary = this.wDictionary(buf, obj, writeToBuffer);

    buf.begin();
    if (writeToBuffer) {
      buf.append(CharCodes.endLine);
    }
    res.append([dictionary, CharCodes.endLine]);

    if (writeToBuffer) {
      buf.append([CharWords.stream, obj.rawValue, CharWords.endstream], CharCodes.endLine);
    }
    res.append([CharWords.stream, obj.rawValue, CharWords.endstream], CharCodes.endLine);

    return res.end().raw;
  }

  private wArray(buf: PdfBuffer, obj: PdfArray, writeToBuffer = true): Uint8Array {
    const res = new PdfBuffer().begin();
    res.append([CharCodes.leftSquareBracket, CharCodes.space]);

    buf.begin();
    if (writeToBuffer) {
      buf.append([CharCodes.leftSquareBracket, CharCodes.space]);
    }

    for (const item of obj) {
      const raw = this.write(buf, item, false, writeToBuffer);
      if (writeToBuffer) {
        buf.append(CharCodes.space);
      }
      res.append([raw, CharCodes.space]);
    }

    if (writeToBuffer) {
      buf.append(CharCodes.rightSquareBracket);
    }

    return res.append(CharCodes.rightSquareBracket).end().raw;
  }

  private wRefObj(obj: PdfIndirectObject): Uint8Array {
    return PdfBuffer.stringToRaw(`${obj.id} 0 R`);
  }

  private wBoolean(obj: PdfBoolean): Uint8Array {
    return PdfBuffer.stringToRaw(String(obj.value));
  }

  private wNumber(obj: PdfNumber): Uint8Array {
    return Writer.numberToUint8(obj);
  }

  private wName(obj: PdfName): Uint8Array {
    return PdfBuffer.stringToRaw(`/${fromBinary(StringConverter.writeName(obj.value))}`);
  }

  private wString(obj: PdfString): Uint8Array {
    if (obj instanceof PdfHexString) {
      return Writer.hexToUint8(obj);
    }
    if (obj instanceof PdfLiteralString) {
      return Writer.literalToUint8(obj);
    }

    throw new Error("wString(): Неподдерживаемый формат строки");
  }
  //#endregion

  //#region Converter
  private static addPadding(value: string, padding: number): string {
    return value.padEnd(padding, " ");
  }

  public static numberToUint8(obj: PdfNumber): Uint8Array {
    return PdfBuffer.stringToRaw(Writer.addPadding(obj.value.toString(), obj.padding));
  }

  public static hexToUint8(obj: PdfHexString): Uint8Array {
    return toBinary(Writer.addPadding(`<${StringConverter.writeHex(obj.value, true)}>`, obj.padding));
  }

  public static literalToUint8(obj: PdfLiteralString): Uint8Array {
    return toBinary(Writer.addPadding(`(${fromBinary(StringConverter.writeLiteral(obj.value))})`, obj.padding));
  }
  //#endregion
}
