import { IPdfObjectParams, PdfObject, PdfObjectConstructor } from "./object";
import { PdfIndirectObject, PdfIndirectObjectType } from "./indirect_object";
import { Registry, RegistryTypes } from "../../internal";

export interface IPdfArrayParams extends IPdfObjectParams {
  value?: PdfIndirectObjectType[];
}

export class PdfArray extends PdfObject implements Iterable<PdfIndirectObjectType> {
  /**
   * @internal
   */
  public value: PdfIndirectObjectType[];

  public constructor(param: IPdfArrayParams = {}) {
    super(param);
    this.value = param.value ?? [];
  }

  public get id(): number {
    if (!this.parent) {
      throw new Error("Объект не имеет родителя");
    }

    if (
      this.parent instanceof Registry.get(RegistryTypes.PdfDictionary)
      || this.parent instanceof PdfIndirectObject
      || this.parent instanceof PdfArray
    ) {
      return this.parent.id;
    }

    throw new Error("Родитель должен быть PdfIndirectObject, PdfDictionary или PdfArray");
  }

  public [Symbol.iterator](): Iterator<PdfIndirectObjectType, unknown, undefined> {
    let pointer = 0;
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    const that = this;

    return {
      next(): IteratorResult<PdfIndirectObjectType> {
        if (pointer < that.value.length) {
          return {
            done: false,
            value: that.value[pointer++]
          };
        } else {
          return {
            done: true,
            value: null
          };
        }
      }
    };
  }

  public get length(): number {
    return this.value.length;
  }

  public find(index: number): PdfObject | null;
  public find<T extends PdfObject>(index: number, type: PdfObjectConstructor<T>): T | null;
  public find(index: number, type?: PdfObjectConstructor): PdfObject | null {
    let res = this.value[index] ?? null;

    if (res instanceof Registry.get(RegistryTypes.PdfIndirectObject)) {
      res = res.value;
    }

    if (!res) {
      return null;
    }

    if (!type) {
      return res;
    }

    try {
      return res.convert(type);
    } catch {
      return null;
    }
  }

  public get(index: number): PdfObject;
  public get<T extends PdfObject>(index: number, type: PdfObjectConstructor<T>): T;
  public get(index: number, type?: PdfObjectConstructor): PdfObject {
    const res = this.find(index);
    if (!res) {
      throw new Error("Элемент не найден");
    }

    if (!type) {
      return res;
    }

    return res.convert(type);
  }

  public push(...obj: PdfIndirectObjectType[]): void {
    this.change();

    for (const o of obj) {
      if (!(o instanceof Registry.get(RegistryTypes.PdfIndirectObject)) && !o.parent) {
        o.parent = this;
      }
    }

    this.value.push(...obj);
  }
}
