import * as assert from "node:assert";
import * as fs from "node:fs";
import { Document, Names, PdfDictionary } from "./index";
import { PdfBuffer } from "./internal";
import { Parser } from "./parser";

function readFile(path: string): Uint8Array {
  if (!fs.existsSync(path)) {
    throw Error("File not found");
  }

  return fs.readFileSync(path);
}

describe("Parser", () => {
  describe("#parse()", () => {
    it("XRefTable", () => {
      const buf = readFile(`${__dirname}/../testdata/xref_table.pdf`);
      const doc = new Document();
      doc.read(buf);
      const res = doc.xref.getIndirectObject(2).value;
      doc.xref.trailer.Root.get(Names.Metadata, PdfDictionary);
      assert.ok(res);
    });

    it("XRefStream", () => {
      const buf = readFile(`${__dirname}/../testdata/xref_stream.pdf`);
      const doc = new Document();
      doc.read(buf);
      assert.ok(doc.xref.trailer);
      assert.ok(doc.xref.trailer.Root);
      const res = doc.xref.getIndirectObject(10).value;
      assert.ok(res);
    });

    it("Generation number in XRefTable", () => {
      const buf = readFile(`${__dirname}/../testdata/generation_number_table.pdf`);
      const doc = new Document();
      doc.read(buf);
      const res = doc.xref.getIndirectObject(10);
      assert.equal(res.generation, 1);
    });

    it("Offset 0", () => {
      const buf = readFile(`${__dirname}/../testdata/offset_0.pdf`);
      const doc = new Document();
      doc.read(buf);
      assert.ok(doc.xref.findIndirectObject(6) === null);
    });

    describe("#readObject()", () => {
      describe("#Number", () => {
        const vectors: {
          title: string,
          object: string,
          value?: number | boolean,
        }[] = [
            {
              title: "integer",
              object: "1234567890",
              value: 1234567890,
            },
            {
              title: "number",
              object: "-12345.67890",
              value: -12345.67890,
            },
            {
              title: "with a bad symbol at the beginning",
              object: "/1234567890",
              value: false,
            },
            {
              title: "with a bad symbol at the middle",
              object: "12345g67890",
              value: 12345,
            },
            {
              title: "with a bad symbol at the end",
              object: "1234567890_",
              value: 1234567890,
            },
          ];

        vectors.forEach(vector => {
          it(vector.title, () => {
            const buffer = new PdfBuffer(Buffer.from(vector.object));

            if (vector.value === undefined) {
              // Проверяем что вернет ошибку.
              assert.throws(() => {
                Parser.readNumber(buffer, 0);
              });

            } else if (typeof vector.value === "boolean") {
              // Проверяем что результат будет false.
              const res = Parser.readNumber(buffer, 0);
              assert.ok(!res.ok);

            } else {
              // Проверяем результат.
              const actual = Parser.readNumber(buffer, 0);
              assert.ok(actual.ok);
              assert.equal(actual.value.value, vector.value);
            }
          });
        });
      });

      describe("#String", () => {
        describe("#Literal", () => {
          const vectors: {
            title: string,
            object: string,
            value?: string | boolean,
          }[] = [
              {
                title: "empty",
                object: "()",
                value: "",
              },
              {
                title: "with text",
                object: "(text)",
                value: "text",
              },
              {
                title: "with \\(",
                object: "(te\\(xt)",
                value: "te(xt",
              },
              {
                title: "with internal ()",
                object: "(text with())",
                value: "text with()",
              },
              {
                title: "with few internal ()",
                object: "(text with (bob1) and (bob2), also (bob3 with (bob1)))",
                value: "text with (bob1) and (bob2), also (bob3 with (bob1))",
              },
              {
                title: "without (",
                object: "text)",
                value: false,
              },
              {
                title: "without )",
                object: "(text",
              },
              {
                title: "with bad internal()",
                object: "(text with internal ()",
              },
            ];

          vectors.forEach(vector => {
            it(vector.title, () => {
              const buffer = new PdfBuffer(Buffer.from(vector.object));

              if (vector.value === undefined) {
                // Проверяем что вернет ошибку.
                assert.throws(() => {
                  Parser.readLiteralString(buffer, 0);
                });

              } else if (typeof vector.value === "boolean") {
                // Проверяем что результат будет false.
                const res = Parser.readLiteralString(buffer, 0);
                assert.ok(!res.ok);

              } else {
                // Проверяем результат.
                const actual = Parser.readLiteralString(buffer, 0);
                assert.ok(actual.ok);
                assert.equal(actual.value.value, vector.value);
              }
            });
          });
        });
      });

      describe("#Dictionary", () => {
        const vectors: {
          title: string,
          object: string,
          value?: number,
        }[] = [
            {
              title: "1",
              object: "<</Size 19/Root <<>>/Info ()/ID[<D98B9B06C5174FEB9302CD397ACA0B61><D98B9B06C5174FEB9302CD397ACA0B61>]/Prev 1063>>",
              value: 5,
            },
          ];

        vectors.forEach(vector => {
          it(vector.title, () => {
            const doc = Document.create();
            doc.buffer = new PdfBuffer(Buffer.from(vector.object));
            const parser = new Parser(doc);

            if (!vector.value) {
              assert.throws(() => {
                const res = parser.readObject(0);

                return res;
              });
            } else {
              const actual = parser.readObject(0, PdfDictionary);
              assert.equal(actual.items.size, vector.value);
            }
          });
        });
      });
    });
  });
  describe("#Operator", () => {
    const vectors: {
      title: string,
      object: string,
      tag?: string,
      argumentsLength?: number,
      status: boolean,
    }[] = [
        {
          title: "Tf operator",
          object: "/TT0 1 Tf",
          tag: "Tf",
          argumentsLength: 2,
          status: true,
        },
        {
          title: "q operator",
          object: "q",
          tag: "q",
          argumentsLength: 0,
          status: true,
        }
      ];

    vectors.forEach(vector => {
      it(vector.title, () => {
        const doc = Document.create();
        const buf = new PdfBuffer(Buffer.from(vector.object));
        const objRes = Parser.readOperator(buf, doc.xref, 0);
        assert.equal(objRes.ok, vector.status);
        if (vector.status && objRes.ok) {
          assert.equal(objRes.value.tag, vector.tag);
          assert.equal(objRes.value.params.length, vector.argumentsLength);
          assert.equal(objRes.value.raw.offset, 0);
          assert.equal(objRes.value.raw.length, buf.length);
        }
      });
    });
  });
});
