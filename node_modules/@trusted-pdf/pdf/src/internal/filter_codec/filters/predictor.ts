import { PdfNumber } from "../../../syntax/objects/number";
import type { PdfDictionary } from "../../../syntax/objects/dictionary";
import { Names } from "packages/pdf/src/syntax/names";

export abstract class Predictor {
  public static decode(data: Uint8Array, params: PdfDictionary): Uint8Array {
    let res = data;

    const predictor = params.find("Predictor", PdfNumber)?.value || 1;

    if (predictor <= 1) {
      return res;
    }

    if (predictor !== 2 && (predictor < 10 || predictor > 15)) {
      throw new Error(`Неподдерживаемый Predictor: ${predictor}`);
    }

    const colors = params.find("Colors", PdfNumber)?.value || 1;
    const bits = params.find("BPC", PdfNumber)?.value || params.find(Names.BitsPerComponent, PdfNumber)?.value || 8;
    const columns = params.find("Columns", PdfNumber)?.value || 1;

    const pixBytes = (colors * bits + 7) >> 3;
    const rowBytes = (columns * colors * bits + 7) >> 3;

    if (predictor === 2) {
      res = this.decodeTiff(data, pixBytes, rowBytes);
    } else {
      res = this.decodePNG(data, pixBytes, rowBytes);
    }

    return res;
  }

  private static decodeTiff(data: Uint8Array, pixBytes: number, rowBytes: number): Uint8Array {
    // Исходные переменные
    const streamLength = data.length;
    const result = new Uint8Array(streamLength);

    let resultIndex = 0;
    let dataIndex = 0;

    while (dataIndex < streamLength) {
      // Копируем первые значения пикселей в строке
      for (let i = 0; i < pixBytes; i++) {
        result[resultIndex] = data[dataIndex];
        resultIndex++;
        dataIndex++;
      }

      // Применяем декодирование предикатора 2 для оставшихся пикселей строки
      for (let i = pixBytes; i < rowBytes; i++) {
        result[resultIndex] = (data[dataIndex] + result[resultIndex - pixBytes]) & 0xFF;
        resultIndex++;
        dataIndex++;
      }

      // Пропускаем оставшиеся пиксели строки, если они есть
      dataIndex += Math.max(0, rowBytes - pixBytes);
    }

    return result;
  }

  private static decodePNG(data: Uint8Array, pixBytes: number, rowBytes: number): Uint8Array {
    const streamLength = data.length;

    const result = new Uint8Array(streamLength);

    const row = new Uint8Array(rowBytes);
    let resultIndex = 0;
    let dataIndex = 0;

    while (dataIndex < streamLength) {
      const type = data[dataIndex++];
      row.set(data.subarray(dataIndex, dataIndex + rowBytes));
      dataIndex += rowBytes;

      switch (type) {
        // Фильтр типа 0: None
        case 0:
          result.set(row, resultIndex);
          resultIndex += rowBytes;
          break;

        // Фильтр типа 1: Sub
        case 1:
          for (let i = 0; i < pixBytes; i++) {
            result[resultIndex++] = row[i];
          }
          for (let i = pixBytes; i < rowBytes; i++) {
            result[resultIndex] = (row[i] + result[resultIndex - pixBytes]) & 0xFF;
            resultIndex++;
          }
          break;

        // Фильтр типа 2: Up
        case 2:
          for (let i = 0; i < rowBytes; i++) {
            result[resultIndex] = (row[i] + (result[resultIndex - rowBytes] || 0)) & 0xFF;
            resultIndex++;
          }
          break;

        // Фильтр типа 3: Average
        case 3:
          for (let i = 0; i < pixBytes; ++i) {
            result[resultIndex++] = ((result[resultIndex - rowBytes] || 0) >> 1) + row[i];
          }
          for (let i = pixBytes; i < rowBytes; ++i) {
            result[resultIndex] = (((result[resultIndex - rowBytes] || 0) + (result[resultIndex - pixBytes] || 0) >> 1) + row[i]) & 0xFF;
            resultIndex++;
          }
          break;

        // Фильтр типа 4: Paeth
        case 4:
          for (let i = 0; i < pixBytes; ++i) {
            result[resultIndex++] = ((result[resultIndex - rowBytes] || 0) + row[i]) & 0xFF;
          }
          for (let i = pixBytes; i < rowBytes; ++i) {
            const a = (result[resultIndex - pixBytes] || 0);
            const b = (result[resultIndex - rowBytes] || 0);
            const c = (result[resultIndex - rowBytes - pixBytes] || 0);

            const p = a + b - c;

            let pa = p - a;
            if (pa < 0)
              pa = -pa;

            let pb = p - b;
            if (pb < 0)
              pb = -pb;

            let pc = p - c;
            if (pc < 0)
              pc = -pc;

            if (pa <= pb && pa <= pc) {
              result[resultIndex] = (a + row[i]) & 0xFF;
            } else if (pb <= pc) {
              result[resultIndex] = (b + row[i]) & 0xFF;
            } else {
              result[resultIndex] = (c + row[i]) & 0xFF;
            }
          }
          break;

        default:
          throw new Error(`Неподдерживаемый тип predictor: ${type}`);
      }
    }

    return result;
  }

  public static encode(data: Uint8Array, params: PdfDictionary): Uint8Array {
    // The encoding process will depend on the predictor type
    const predictor = params.find("Predictor", PdfNumber)?.value || 1;

    // If predictor is 1, the data doesn't need to be encoded.
    if (predictor <= 1) {
      return data;
    }

    // For other types of predictors, encoding needs to be implemented.
    const colors = params.find("Colors", PdfNumber)?.value || 1;
    const bits = params.find("BPC", PdfNumber)?.value || params.find(Names.BitsPerComponent, PdfNumber)?.value || 8;
    const columns = params.find("Columns", PdfNumber)?.value || 1;

    const pixBytes = (colors * bits + 7) >> 3;
    const rowBytes = (columns * colors * bits + 7) >> 3;

    let encodedData: Uint8Array;

    // Implement encoding based on the TIFF predictor
    if (predictor === 2) {
      encodedData = this.encodeTiff(data, pixBytes, rowBytes);
    } else {
      throw new Error("метод encodePNG не реализован");
    }

    return encodedData;
  }

  private static encodeTiff(data: Uint8Array, pixBytes: number, rowBytes: number): Uint8Array {
    // Исходные переменные
    const streamLength = data.length;
    const result = new Uint8Array(streamLength);

    let resultIndex = 0;
    let dataIndex = 0;

    while (dataIndex < streamLength) {
      // Копируем первые значения пикселей в строке
      for (let i = 0; i < pixBytes; i++) {
        result[resultIndex] = data[dataIndex];
        resultIndex++;
        dataIndex++;
      }

      // Применяем кодирование предикатора 2 для оставшихся пикселей строки
      for (let i = pixBytes; i < rowBytes; i++) {
        result[resultIndex] = (data[dataIndex] - data[dataIndex - pixBytes]) & 0xFF;
        resultIndex++;
        dataIndex++;
      }

      // Пропускаем оставшиеся пиксели строки, если они есть
      dataIndex += Math.max(0, rowBytes - pixBytes);
    }

    return result;
  }
}
