import * as assert from "node:assert";
import * as fs from "node:fs";
import { FlateDecode } from "./flate_decode";
import { Names } from "packages/pdf/src/syntax/names";

const FLATE_TESTS_DIR = `${__dirname}/../../../../testdata/filters/flate`;

describe(Names.FlateDecode, function () {
  const vectors: {
    fileName: string,
  }[] = [
      {
        fileName: "1",
      },
      {
        fileName: "2",
      },
      {
        fileName: "3",
      },
      {
        fileName: "4",
      },
      {
        fileName: "5",
      },
      {
        fileName: "6",
      },
      {
        fileName: "7",
      },
    ];

  describe("encode()", function () {
    vectors.forEach((vector) => {
      it(vector.fileName, function () {
        const expected = new Uint8Array(fs.readFileSync(`${FLATE_TESTS_DIR}/${vector.fileName}.encoded`));
        const data = new Uint8Array(fs.readFileSync(`${FLATE_TESTS_DIR}/${vector.fileName}.decoded`));

        const result = new FlateDecode().encode(data);

        assert.deepStrictEqual(result, expected);
      });
    });

    it("on providing corrupted data", function () {
      const data = new Uint8Array(fs.readFileSync(`${FLATE_TESTS_DIR}/1.corrupt.encoded`));

      assert.throws(() => new FlateDecode().decode(data),
        { message: "FlateDecode.decode(): ошибка pako.inflate(), вероятно некорректный набор байт" });
    });
  });

  describe("decode()", function () {
    vectors.forEach((vector) => {
      it(vector.fileName, function () {
        const data = new Uint8Array(fs.readFileSync(`${FLATE_TESTS_DIR}/${vector.fileName}.encoded`));
        const expected = new Uint8Array(fs.readFileSync(`${FLATE_TESTS_DIR}/${vector.fileName}.decoded`));

        const result = new FlateDecode().decode(data);

        assert.deepStrictEqual(result, expected);
      });
    });
  });
});
