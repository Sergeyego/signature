import { IPdfObjectParams, PdfObject } from "./object";
import { PdfStream } from "./stream";

import type { PdfObjectType } from "./object_type";
import { PdfNull } from "./null";
import type { XRef } from "../structure";
import { Registry, RegistryTypes } from "../../internal/registry";

export type PdfIndirectObjectType = PdfIndirectObject | PdfObjectType;

export enum IndirectObjectType {
  inUse = "n",
  free = "f",
  compressed = "c",
}

// TODO Разделить параметры по type
export interface IPdfIndirectObjectParams extends IPdfObjectParams {
  xref?: XRef;
  id: number;
  generation?: number;
  offset?: number;
  index?: number;
  objStream?: number;
  type?: IndirectObjectType;
}

export class PdfIndirectObject extends PdfObject {
  public id: number;
  public generation: number;
  public offset: number;
  public index: number;
  public objStream: number;
  public type: IndirectObjectType;


  /**
   * Хранит в себе внутренние значение объекта. Объект считывается из массива данных только при необходимости.
   * @internal
  */
  public privateValue?: PdfObjectType;

  public constructor(param: IPdfIndirectObjectParams) {
    super(param);
    this.id = param.id;
    this.generation = param.generation ?? 0;

    this.type = param.type ?? IndirectObjectType.inUse;

    // Параметр inuse
    this.offset = param.offset ?? 0;

    // Параметры для compressed
    this.index = param.index ?? 0;
    this.objStream = param.objStream ?? 0;

    if (param.xref) {
      this.xref = param.xref;
    }
  }

  public getValue(xref?: XRef): PdfObjectType {
    const ParserClass = Registry.get(RegistryTypes.Parser);

    if (this.id === 0) {
      return new PdfNull();
    }

    let privateValue: PdfObjectType | undefined;

    switch (this.type) {
      case IndirectObjectType.free:
        privateValue = new PdfNull();
        break;
      case IndirectObjectType.inUse: {
        if (xref) {
          const reader = new ParserClass(xref.doc);
          privateValue = reader.readIndirectObject(this.offset, xref);
          privateValue.parent = this;
        } else {
          const reader = new ParserClass(this.xref.doc);
          privateValue = reader.readIndirectObject(this.offset);
          privateValue.parent = this;
        }

        break;
      }
      case IndirectObjectType.compressed: {
        const objIo = this.xref.getIndirectObject(this.objStream);
        if (!(objIo.value instanceof PdfStream)) {
          throw new Error("objStream");
        }

        const objStream = objIo.value.convert(Registry.get(RegistryTypes.ObjectStream));
        privateValue = objStream.getObject(this.index);
        privateValue.parent = this;

        break;
      }
      default:
        throw new Error("Неподдерживаемый формат IndirectObject");
    }

    return privateValue;
  }

  public get value(): PdfObjectType {
    if (this.privateValue) {
      return this.privateValue;
    }
    this.privateValue = this.getValue();

    return this.privateValue;
  }

  public set value(v: PdfObjectType) {
    if (this.privateValue) {
      throw new Error("Indirect object уже имеет значение");
    }
    this.privateValue = v;
  }

  public getHistory(): boolean {
    throw new Error("метод не реализован");
  }

  protected override onChange(): void {
    if (this.type === IndirectObjectType.free) {
      throw new Error(`${this.id} объект имеет статус free`);
    }

    this.doc.createUpdate();

    if (!this.doc.xref.objects.has(this.id)) {
      this.doc.xref.push(this);
    }
  }
}
